(()=>{var __webpack_modules__={"./frontend/js/app.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('var Router = __webpack_require__(/*! ./lib/Router */ "./frontend/js/lib/Router.js");\nvar Home = __webpack_require__(/*! ./controllers/Home */ "./frontend/js/controllers/Home.js");\nvar Register = __webpack_require__(/*! ./controllers/Register */ "./frontend/js/controllers/Register.js");\n\nvar Login = __webpack_require__(/*! ./controllers/Login */ "./frontend/js/controllers/Login.js");\nvar UserModel = __webpack_require__(/*! ./models/User */ "./frontend/js/models/User.js");\nvar Profile = __webpack_require__(/*! ./controllers/Profile */ "./frontend/js/controllers/Profile.js");\nvar FindFriends = __webpack_require__(/*! ./controllers/FindFriends */ "./frontend/js/controllers/FindFriends.js");\n//const User = require("./models/User");\nvar currentPage;\nvar body;\n\nvar showPage = function (newPage) {\n  if (currentPage) {\n    currentPage.teardown();\n  }\n  currentPage = newPage;\n  console.log("changing to the next website");\n  body.innerHTML = "trying to render another page";\n  currentPage.render(body);\n  currentPage.on("navigation.goto", function (e, route) {\n    Router.navigate(route);\n  });\n  window.currentPage = currentPage;\n};\n\nvar renderProfile = function (userModel) {\n  if (userModel.isLogged()) {\n    var p = new Profile();\n    showPage(p);\n  } else {\n    Router.navigate("login");\n  }\n};\n\nvar findFriends = function (userModel) {\n  if (userModel.isLogged()) {\n    var page = new FindFriends();\n    showPage(page);\n  } else {\n    Router.navigate("login");\n  }\n};\n\nvar logoutUser = function (userModel) {\n  userModel.logout(function (error, result) {\n    console.log(error);\n    window.location.href = "/";\n  });\n};\n//ensure our Javascript isn\'t run until\n//resources of the page are fully loaded\n\n// const Window = require("window");\n// const { window } = new Window();\n\n// const { readyState } = require("ready-state");\n// readyState.window.then((state) => {\n\n// const jsdom = require("jsdom");\n// const { JSDOM } = jsdom;\n// const { window } = new JSDOM(``, { runScripts: "outside-only" });\n\n// const { readyState } = require("ready-state");\n\nwindow.onload = function () {\n  // readyState.load.then((state) => {\n  console.log("window just loaded");\n\n  body = document.querySelector("body .container");\n  var userModel = new UserModel();\n  userModel.fetch(function (error, result) {\n    //..router setting\n\n    if (error) {\n      console.error(error);\n    }\n    Router.add("home", function () {\n      var page = new Home();\n      showPage(page);\n    })\n      .add("register", function () {\n        var page = new Register();\n        //var page = Register.onrender();\n        showPage(page);\n      })\n      .add("login", function () {\n        var page = new Login();\n        showPage(page);\n      })\n      .add("find-friends", function () {\n        findFriends(userModel);\n      })\n      .add("logout", function () {\n        logoutUser.call(this, userModel);\n      })\n      .add("profile", function () {\n        renderProfile(userModel);\n      })\n      .add(function () {\n        Router.navigate("home");\n      })\n      .listen()\n      .check();\n  });\n};\n// });\n\n// var userModel = new UserModel();\n// userModel.fetch(function (error, result) {\n//   //..router setting\n//   console.log("fetching some data");\n//   Router.add("home", function () {\n//     var page = new Home();\n//     showPage(page);\n//   })\n//     .add("register", function () {\n//       await sleep(1000);\n//       var page = new Register();\n//       showPage(page);\n//     })\n//     .add("login", function () {\n//       await sleep(1000);\n//       var page = new Login();\n//       showPage(page);\n//     })\n//     .add("find-friends", function () {\n//       findFriends(userModel);\n//     })\n//     .add("logout", function () {\n//       logoutUser.call(this, userModel);\n//     })\n//     .add("profile", function () {\n//       renderProfile(userModel);\n//     })\n//     .add(function () {\n//       Router.navigate("home");\n//     })\n//     .listen()\n//     .check();\n// });\n\n// window.onload() = function() {\n\n//     // the global userModel instance that is used all over\n//     //the application\n//     //userModel function extends the base model where fetch method\n//     //puts the response from the server in the value property of the model\n//     var userModel = new UserModel();\n//     userModel.fetch(function(error, result) {\n//         //..router setting\n//         Router\n//         .add(\'home\', function() {\n//             var page = new Home();\n//             showPage(p);\n//         })\n//         .add(\'register\', function() {\n//             var page = new Register();\n//             showPage(p);\n//           })\n//           .add(\'login\', function() {\n//             var page = new Login();\n//             showPage(page);\n//           })\n//           .add(\'find-friends\', function() {\n//             findFriends(userModel);\n//           })\n//           .add(\'logout\', function() {\n//             logoutUser.call(this, userModel);\n//           })\n//         .add(\'profile\', function() {\n//             renderProfile(userModel);\n//           })\n//         .add(function() {\n//             Router.navigate(\'home\');\n//         })\n//         .listen()\n//         .check();\n//     })\n// };\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/js/app.js?')},"./frontend/js/controllers/FindFriends.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('//var Ractive = require("ractive");\n\nvar Friends = __webpack_require__(/*! ../models/Friends */ "./frontend/js/models/Friends.js");\nvar renderFindFriends = function (model) {\n  var self = this;\n\n  this.on("find", function (e) {\n    self.set("loading", true);\n    self.set("message", "");\n    var searchFor = this.get("friendName");\n    model.find(searchFor, function (err, res) {\n      if (res.friends && res.friends.length > 0) {\n        self.set("foundFriends", res.friends);\n      } else {\n        self.set("foundfriends", null);\n        self.set(\n          "message",\n          "Sorry, there is no friends matching <strong>" +\n            searchFor +\n            "<strong>"\n        );\n      }\n      self.set("loading", false);\n    });\n  });\n};\n\nvar renderAddFriennds = function (model) {\n  this.on("add", function (e, id) {\n    this.set("loading", true);\n    model.add(id, function (err, res) {\n      self.set("foundFriends", null);\n      if (err) {\n        self.set("message", "Operation failed");\n      } else if (res.success === "OK") {\n        self.set("message", "Operation successful");\n      }\n      self.set("loading", false);\n    });\n  });\n};\n\nmodule.exports = Ractive.extend({\n  template: __webpack_require__(/*! ../../tpl/find-friends */ "./frontend/tpl/find-friends.js"),\n  components: {\n    navigatioon: __webpack_require__(/*! ../views/Navigation */ "./frontend/js/views/Navigation.js"),\n    appfooter: __webpack_require__(/*! ../views/Footer */ "./frontend/js/views/Footer.js"),\n  },\n  data: {\n    loading: false,\n    message: "",\n    searchFor: "",\n    foundFriends: null,\n  },\n  onrender: function () {\n    //rendering\n    var model = new Friends();\n    renderFindFriends.call(this, model);\n    renderAddFriennds.call(this, model);\n  },\n});\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/js/controllers/FindFriends.js?')},"./frontend/js/controllers/Home.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('//var Ractive = require("ractive");\nmodule.exports = Ractive.extend({\n  // template: require("../../tpl/home"),\n  template: `\n  <header>\n  <navigation></navigation>\n</header>\n<div class="hero">\n  {{#if posting === true}}\n    <form enctype="multipart/form-data" method="post">\n      <h3>What is on your mind?</h3>\n      {{#if error && error != \'\'}}\n        <div class="error">{{error}}</div>\n      {{/if}}\n      {{#if success && success != \'\'}}\n        <div class="success">{{{success}}}</div>\n      {{/if}}\n      <label for="text">Text</label>\n      <textarea value="{{text}}"></textarea>\n      <input type="file" name="file" />\n      <input type="button" value="Post" on-click="post" />\n    </form>\n    {{#each posts:index}}\n      <div class="content-item">\n        <h2>{{posts[index].userName}}</h2>\n        {{posts[index].text}}\n        {{#if posts[index].file}}\n        <br /><br />\n        <img src="/static/uploads/{{posts[index].file}}" />\n        {{/if}}\n      </div>\n    {{/each}}\n  {{else}}\n    <h1>Social Media App</h1>\n  {{/if}}\n</div>\n<appfooter />`,\n  components: {\n    navigation: __webpack_require__(/*! ../views/Navigation */ "./frontend/js/views/Navigation.js"),\n    appfooter: __webpack_require__(/*! ../views/Footer */ "./frontend/js/views/Footer.js"),\n  },\n  onrender: function () {\n    console.log("Home page rendered");\n  },\n});\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/js/controllers/Home.js?')},"./frontend/js/controllers/Login.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('//var Ractive = require("ractive");\nvar UserModel = __webpack_require__(/*! ../models/User */ "./frontend/js/models/User.js");\nvar userModel = new UserModel();\nconst renderLogin = function () {\n  var self = this;\n  this.observe("email", userModel.setter("email"));\n  this.observe("password", userModel.setter("password"));\n  this.on("login", function () {\n    userModel.login(function (error, result) {\n      if (error) {\n        self.set("error", error.error);\n      } else {\n        self.set("error", false);\n        //redirecting the user to the home page\n        window.location.href = "/";\n      }\n    });\n  });\n};\n\nmodule.exports = Ractive.extend({\n  // template: require("../../tpl/login"),\n  template: `<header>\n  <navigation></navigation>\n</header>\n<div class="hero">\n  <h1>Login</h1>\n</div>\n<form>\n  {{#if error && error != \'\'}}\n  <div class="error">{{error}}</div>\n  {{/if}} {{#if success && success != \'\'}}\n  <div class="success">{{{success}}}</div>\n  {{else}}\n  <label for="email">Email</label>\n  <input type="text" id="email" value="{{email}}" />\n  <label for="password">Password</label>\n  <input type="password" id="password" value="{{password}}" />\n  <button\n    class="green-button"\n    type="button"\n    value="login"\n    on-click="login"\n  >Login</button>\n  \x3c!-- <input class="green-button" type="button" value="login" on-click="login" /> --\x3e\n  {{/if}}\n</form>\n<appfooter />`,\n  components: {\n    navigation: __webpack_require__(/*! ../views/Navigation */ "./frontend/js/views/Navigation.js"),\n    appfooter: __webpack_require__(/*! ../views/Footer */ "./frontend/js/views/Footer.js"),\n  },\n  onrender: function () {\n    console.log("rendering Login page");\n    renderLogin.call(this);\n  },\n});\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/js/controllers/Login.js?')},"./frontend/js/controllers/Profile.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var Friends = __webpack_require__(/*! ../models/Friends */ "./frontend/js/models/Friends.js");\n//var Ractive = require("ractive");\nvar friendsRender = function (userModel) {\n  var self = this;\n  this.set(userModel.get("value"));\n  this.on("updateProfile", function () {\n    userModel.set("value.firstName", this.get("firstName"));\n    userModel.set("value.lastName", this.get("lastName"));\n    if (this.get("password") != "") {\n      userModel.set("value.password", this.get("password"));\n    }\n    userModel.save(function (error, result) {\n      if (error) {\n        self.set("error", error.error);\n      } else {\n        self.set("error", false);\n        self.set("success", "Profile updated successfully.");\n      }\n    });\n  });\n  this.on("deleteProfile", function () {\n    if (confirm("Are you sure! Your account will be deleted permantely")) {\n      userModel.del(function () {\n        window.location.href = "/";\n      });\n    }\n  });\n\n  var friends = new Friends();\n  friends.fetch(function (err, result) {\n    self.set("friends", result.friends);\n  });\n};\nmodule.exports = Ractive.extend({\n  template: __webpack_require__(/*! ../../tpl/profile */ "./frontend/tpl/profile.js"),\n  components: {\n    navigation: __webpack_require__(/*! ../views/Navigation */ "./frontend/js/views/Navigation.js"),\n    appfooter: __webpack_require__(/*! ../views/Footer */ "./frontend/js/views/Footer.js"),\n  },\n  //   data: {\n  //     friends: [],\n  //   },\n  data: function () {\n    return {\n      friends: [],\n    };\n  },\n  onrender: function () {\n    var UserModel = __webpack_require__(/*! ../models/User */ "./frontend/js/models/User.js");\n    var userModel = new UserModel();\n    friendsRender.call(this, userModel);\n  },\n});\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/js/controllers/Profile.js?')},"./frontend/js/controllers/Register.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('//var Ractive = require("ractive");\nvar UserModel = __webpack_require__(/*! ../models/User */ "./frontend/js/models/User.js");\nvar userModel = new UserModel();\nvar registrationRender = function () {\n  var self = this;\n  console.log("Why is this not fucking working!!!");\n  this.observe("firstName", userModel.setter("value.firstName"));\n  this.observe("lastName", userModel.setter("value.lastName"));\n  this.observe("email", userModel.setter("value.email"));\n  this.observe("password", userModel.setter("value.password"));\n\n  this.on("register", function (event) {\n    console.log("User just clicked the button, and now registrating them");\n    userModel.create(function (error, result) {\n      if (error) {\n        self.set("error", error.error);\n      } else {\n        self.set("error", false);\n        self.set(\n          "success",\n          \'Registration successful. Click <a href="/login">here</a> to LEGAL_TCP_SOCKET_OPTIONS.\'\n        );\n      }\n    });\n  });\n};\n\nmodule.exports = Ractive.extend({\n  // template: require("../../tpl/register"),\n  template: `\n  <header>\n  <navigation></navigation>\n</header>\n  <div class="hero">\n  <h1>Register</h1>\n</div>\n<form>\n  {{#if error && error != \'\'}}\n  <div class="error">{{error}}</div>\n  {{/if}} {{#if success && success != \'\'}}\n  <div class="success">{{{success}}}</div>\n  {{else}}\n  <label for="firstName">First name</label>\n  <input type="text" id="firstName" value="{{firstName}}" />\n  <label for="lastName">Last name</label>\n  <input type="text" id="lastName" value="{{lastName}}" />\n  <label for="email">Email</label>\n  <input type="text" id="email" value="{{email}}" />\n  <label for="password">Password</label>\n  <input type="password" id="password" value="{{password}}" />\n  <button\n    class="green-button"\n    type="button"\n    value="register"\n    on-click="register"\n  >\n    Register\n  </button>\n  {{/if}}\n</form>\n<appfooter />`,\n  components: {\n    navigation: __webpack_require__(/*! ../views/Navigation */ "./frontend/js/views/Navigation.js"),\n    appfooter: __webpack_require__(/*! ../views/Footer */ "./frontend/js/views/Footer.js"),\n  },\n  onrender: function () {\n    console.log("rendering registration in the controller");\n    registrationRender.call(this);\n  },\n});\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/js/controllers/Register.js?')},"./frontend/js/lib/Ajax.js":module=>{eval('var getParams = function (data, url) {\n  var arr = [],\n    str;\n  for (var name in data) {\n    arr.push(name + "=" + encodeURIComponent(data[name]));\n  }\n  str = arr.join("&");\n  if (str != "") {\n    return url ? (url.indexOf("?") < 0 ? "?" + str : "&" + str) : str;\n  }\n  return "";\n};\n\nvar handleProcess = function (ops) {\n  var self = this;\n  this.xhr = null;\n  if (window.ActiveXObject) {\n    this.xhr = new ActiveXObject("Microsoft.XMLHTTP");\n  } else if (window.XMLHttpRequest) {\n    console.log("hello is the XMLHttpReqest");\n    this.xhr = new XMLHttpRequest();\n  }\n  if (this.xhr) {\n    this.xhr.onreadystatechange = function () {\n      if (self.xhr.readyState == 4 && self.xhr.status == 200) {\n        var result = self.xhr.responseText;\n        if (ops.json === true && typeof JSON != "undefined") {\n          result = JSON.parse(result);\n        }\n        self.doneCallback &&\n          self.doneCallback.apply(self.host, [result, self.xhr]);\n      } else if (self.xhr.readyState == 4) {\n        // console.log("calling the failback callback");\n        self.failCallback && self.failCallback.apply(self.host, [self.xhr]);\n      }\n      self.alwaysCallback && self.alwaysCallback.apply(self.host, [self.xhr]);\n    };\n  }\n  if (ops.method == "get") {\n    this.xhr.open("GET", ops.url + getParams(ops.data, ops.url), true);\n  } else {\n    if (ops.formData) {\n      this.xhr.open(ops.method, ops.url);\n    } else {\n      this.xhr.open(ops.method, ops.url, true);\n      this.setHeaders({\n        "X-Requested-With": "XMLHttpRequest",\n        "Content-type": "application/x-www-form-urlencoded",\n      });\n    }\n  }\n  if (ops.headers && typeof ops.headers == "object") {\n    this.setHeaders(ops.headers);\n  }\n  setTimeout(function () {\n    if (ops.formData) {\n      self.xhr.send(ops.formData);\n    } else {\n      ops.method == "get"\n        ? self.xhr.send()\n        : self.xhr.send(getParams(ops.data));\n    }\n  }, 20);\n  return this;\n};\n\nvar handleSetHeaders = function (headers) {\n  for (var name in headers) {\n    this.xhr && this.xhr.setRequestHeader(name, headers[name]);\n  }\n};\n\nmodule.exports = {\n  request: function (ops) {\n    if (typeof ops == "string") ops = { url: ops };\n    ops.url = ops.url || "";\n    ops.method = ops.method || "get";\n    ops.data = ops.data || {};\n\n    var api = {\n      host: {},\n      process: function (ops) {\n        console.log("handling the process call for ajax");\n        return handleProcess.call(this, ops);\n      },\n      done: function (callback) {\n        this.doneCallback = callback;\n        return this;\n      },\n      fail: function (callback) {\n        this.failCallback = callback;\n        return this;\n      },\n      always: function (callback) {\n        this.alwaysCallback = callback;\n        return this;\n      },\n      setHeaders: function (headers) {\n        console.log("settings the headers for ajax");\n        handleSetHeaders.call(this, headers);\n      },\n    };\n    return api.process(ops);\n  },\n};\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/js/lib/Ajax.js?')},"./frontend/js/lib/Router.js":module=>{eval('// this covers stirng to string matching\n// but also supports dynamic parameters\n// the dynamic parameters use ":id"\nvar checkFunction = function (f, params) {\n  var fragment, vars;\n  if (typeof f !== "undefined") {\n    fragment = f.replace(/^\\//, "");\n  } else {\n    fragment = this.getFragment();\n  }\n  for (var i = 0; i < this.routes.length; i++) {\n    var match,\n      path = this.routes[i].path;\n    path = path.replace(/^\\//, "");\n    vars = path.match(/:[^\\s/] +/g);\n    var r = new RegExp("^" + path.replace(/:[^\\s/]+/g, "([\\\\w-]+)"));\n    match = fragment.match(r);\n    if (match) {\n      match.shift();\n      var matchObj = {};\n      if (vars) {\n        for (var j = 0; j < vars.length; j++) {\n          var v = vars[j];\n          matchObj[v.substr(1, v.length)] = match[j];\n        }\n      }\n      this.routes[i].handler.apply({}, (params || []).concat([matchObj]));\n      return this;\n    }\n  }\n  return false;\n};\n\n//helps to get the current URL of the browser by using the\n// global window.location object\nvar getFragmentFunction = function () {\n  var fragment = "";\n  fragment = this.clearSlashes(\n    decodeURI(window.location.pathname + location.search)\n    //decodeURI(window.location.pathname + location.search)\n  );\n\n  fragment = fragment.replace(/\\?(.*)$/, "");\n  fragment = this.root !== "/" ? fragment.replace(this.root, "") : fragment;\n  return this.clearSlashes(fragment);\n};\n\n//this registers routes and calls a handler function if the current URL\n//matches the path\nvar addFunction = function (path, handler) {\n  //some code\n  if (typeof path === "function") {\n    handler = path;\n    path = "";\n  }\n  this.routes.push({\n    path: path,\n    handler: handler,\n  });\n  return this;\n};\n\n//removes unnecessary slashes from the beginning and end of the strinng\nvar clearSlashesFunction = function (path) {\n  return path.toString().replace(/\\/$/, "").replace(/^\\//, "");\n};\n//allows for constant monitoring of the current browser location\nvar listenerFunc = function () {\n  var self = this;\n  var current = self.getFragment();\n  var func = function () {\n    if (current !== self.getFragment()) {\n      current = self.getFragment();\n      self.check(current);\n    }\n  };\n  clearInterval(this.interval);\n  //setInterval allows us to run func multiple times\n  this.interval = setInterval(func, 50);\n  return this;\n};\n\nvar navigator = function (path) {\n  path = path ? path : "";\n  //the pushState method changes the string of the browser\'s address bar\n  history.pushState(null, null, this.root + this.clearSlashes(path));\n  return this;\n};\n\nmodule.exports.routes = [];\nmodule.exports.root = "/";\nmodule.exports.add = function (path, handler) {\n  return addFunction.call(this, path, handler);\n};\n\nmodule.exports.check = function (fragment, params) {\n  return checkFunction.call(this, fragment, params);\n};\n\nmodule.exports.getFragment = function () {\n  return getFragmentFunction.call(this);\n};\n\nmodule.exports.clearSlashes = function (path) {\n  return clearSlashesFunction(path);\n};\n\nmodule.exports.listen = function () {\n  return listenerFunc.call(this);\n};\n\nmodule.exports.navigate = function (path) {\n  return navigator.call(this, path);\n};\n\n// module.exports = function () {\n//   return {\n//     routes: [],\n//     root: "/",\n//     add: function (path, handler) {\n//       //return addFunction(path, handler).call(this);\n//       return addFunction.call(this, path, handler);\n//     },\n//     check: function (fragment, params) {\n//       //regex expressions with string-to-string matching\n//       // and also dynamic parameters\n//       return checkFunction(fragment, params);\n//     },\n//     getFragment: function () {\n//       return getFragmentFunction();\n//     },\n//     clearSlashes: function (path) {\n//       return clearSlashesFunction(path);\n//     },\n//     listen: function () {\n//       return listenerFunc.call(this);\n//     },\n//     navigate: function (path) {\n//       return navigator(path);\n//     },\n//   };\n// };\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/js/lib/Router.js?')},"./frontend/js/models/Base.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('//var Ractive = require("ractive");\nvar ajax = __webpack_require__(/*! ../lib/Ajax */ "./frontend/js/lib/Ajax.js");\n\nvar fetcher = function (callback) {\n  var self = this;\n  ajax\n    .request({\n      url: self.get("url"),\n      json: true,\n    })\n    .done(function (result) {\n      self.set("value", result);\n      if (callback) {\n        callback(null, result);\n      }\n    })\n    .fail(function (xhr) {\n      console.log(xhr.key);\n      if (callback) {\n        self.fire("Error fetching ", self.get("url"));\n      }\n    });\n  return this;\n};\n\nvar creator = function (callback) {\n  var self = this;\n  console.log("This is your time", self.get("url"));\n  ajax\n    .request({\n      url: self.get("url"),\n      method: "POST",\n      data: this.get("value"),\n      json: true,\n    })\n    .done(function (result) {\n      if (callback) {\n        callback(null, result);\n      }\n    })\n    .fail(function (xhr) {\n      if (callback) {\n        callback(JSON.parse(xhr.responseText));\n      }\n    });\n  return this;\n};\n\nvar updater = function (callback) {\n  var self = this;\n  ajax\n    .request({\n      url: self.get("url"),\n      method: this.get("value"),\n      data: this.get("value"),\n      json: true,\n    })\n    .done(function (result) {\n      if (callback) {\n        callback(null, result);\n      }\n    })\n    .fail(function (xhr) {\n      if (callback) {\n        callback(JSON.parse(xhr.responseText));\n      }\n    });\n  return this;\n};\n\nvar deleter = function (callback) {\n  var self = this;\n  ajax\n    .request({\n      url: self.get("url"),\n      method: this.get("value"),\n      json: true,\n    })\n    .done(function (result) {\n      if (callback) {\n        callback(null, result);\n      }\n    })\n    .fail(function (xhr) {\n      if (callback) {\n        callback(JSON.parse(xhr.responseText));\n      }\n    });\n  return this;\n};\nvar bindingComponent = function (component) {\n  if (component) {\n    this.observe(\n      "value",\n      function (value) {\n        for (var key in value) {\n          component.set(key, value[key]);\n        }\n      },\n      { init: false }\n    );\n  }\n  return this;\n};\n\nvar Setter = function (key) {\n  var self = this;\n  return function (value) {\n    self.set(key, value);\n  };\n};\n\nmodule.exports = Ractive.extend({\n  data: {\n    value: null,\n    url: "",\n  },\n  fetch: function (callback) {\n    return fetcher.call(this, callback);\n  },\n  bindComponent: function (component) {\n    return bindingComponent.call(this, component);\n  },\n  create: function (callback) {\n    return creator.call(this, callback);\n  },\n  save: function (callback) {\n    return updater.call(this, callback);\n  },\n  del: function (callback) {\n    return deleter.call(this, callback);\n  },\n  setter: function (key) {\n    return Setter.call(this, key);\n  },\n});\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/js/models/Base.js?')},"./frontend/js/models/Friends.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var ajax = __webpack_require__(/*! ../lib/Ajax */ "./frontend/js/lib/Ajax.js");\nvar Base = __webpack_require__(/*! ./Base */ "./frontend/js/models/Base.js");\n\nvar findFriendsFunc = function (searchFor, callback) {\n  ajax\n    .request({\n      url: this.get("url") + "/find",\n      method: "POST",\n      data: {\n        searchFor: searchFor,\n      },\n      json: true,\n    })\n    .done(function (result) {\n      callback(null, result);\n    })\n    //xhr is XMLHttpRequest\n    .fail(function (xhr) {\n      callback(JSON.parse(xhr.responseText));\n    });\n};\n\nvar addFriendsFunc = function (id, callback) {\n  ajax\n    .request({\n      url: this.get("url") + "/add",\n      method: "POST",\n      data: {\n        id: id,\n      },\n      json: true,\n    })\n    .done(function (result) {\n      callback(null, result);\n    })\n    //xhr is XMLHttpRequest\n    .fail(function (xhr) {\n      callback(JSON.parse(xhr.responseText));\n    });\n};\n\nmodule.exports = Base.extend({\n  data: {\n    url: "/api/friends",\n  },\n  find: function (searchFor, callback) {\n    findFriendsFunc(searchFor, callback);\n  },\n  add: function (id, callback) {\n    addFriendsFunc(id, callback);\n  },\n});\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/js/models/Friends.js?')},"./frontend/js/models/User.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var Base = __webpack_require__(/*! ./Base */ "./frontend/js/models/Base.js");\nvar ajax = __webpack_require__(/*! ../lib/Ajax */ "./frontend/js/lib/Ajax.js");\n\nconst loginUser = function (callback) {\n  ajax\n    .request({\n      url: this.get("url") + "/login",\n      method: "POST",\n      data: {\n        email: this.get("email"),\n        password: this.get("password"),\n      },\n      json: true,\n    })\n    .done(function (result) {\n      callback(null, result);\n    })\n    .fail(function (xhr) {\n      // console.log(JSON.parse(xhr.responseText));\n      callback(JSON.parse(xhr.responseText));\n    });\n};\n\n//if a user is logged in, we return what is store in\n// the session object\nvar isLoggedIn = function () {\n  return this.get("value.firstName") && this.get("value.lastName");\n};\n\nmodule.exports = Base.extend({\n  data: {\n    url: "/api/user",\n  },\n  login: function (callback) {\n    loginUser.call(this, callback);\n  },\n  isLogged: function () {\n    return isLoggedIn.call(this);\n  },\n});\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/js/models/User.js?')},"./frontend/js/models/Version.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var Base = __webpack_require__(/*! ./Base */ "./frontend/js/models/Base.js");\nmodule.exports = Base.extend({\n  data: {\n    url: "/api/version",\n  },\n});\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/js/models/Version.js?')},"./frontend/js/ractive.js":function(module,__unused_webpack_exports,__webpack_require__){eval("/*\n\tRactive.js v1.4.0-edge\n\tBuild: 898e38669ba55a7c0b8433cf78646fc4fd069b25\n\tDate: Fri Jun 04 2021 23:16:31 GMT+0000 (Coordinated Universal Time)\n\tWebsite: https://ractive.js.org\n\tLicense: MIT\n*/\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\t0;\n}(this, (function () { 'use strict';\n\n/* istanbul ignore if */\nif (!Object.assign) {\n  Object.assign = function(target) {\n    var sources = [], len = arguments.length - 1;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n    if (target == null) { throw new TypeError('Cannot convert undefined or null to object'); }\n\n    var to = Object(target);\n    var sourcesLength = sources.length;\n\n    for (var index = 0; index < sourcesLength; index++) {\n      var nextSource = sources[index];\n      for (var nextKey in nextSource) {\n        if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey)) { continue; }\n        to[nextKey] = nextSource[nextKey];\n      }\n    }\n\n    return to;\n  };\n}\n\nfunction hasOwn(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nfunction fillGaps(target) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  for (var i = 0; i < sources.length; i++) {\n    var source = sources[i];\n    for (var key in source) {\n      // Source can be a prototype-less object.\n      if (key in target || !hasOwn(source, key)) { continue; }\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction toPairs(obj) {\n  if ( obj === void 0 ) obj = {};\n\n  var pairs = [];\n  for (var key in obj) {\n    // Source can be a prototype-less object.\n    if (!hasOwn(obj, key)) { continue; }\n    pairs.push([key, obj[key]]);\n  }\n  return pairs;\n}\n\nvar obj = Object;\n\nvar assign = obj.assign;\n\nvar create = obj.create;\n\nvar defineProperty = obj.defineProperty;\n\nvar defineProperties = obj.defineProperties;\n\nvar keys = obj.keys;\n\nvar toString = Object.prototype.toString;\n\n\nvar isArray = Array.isArray;\n\nfunction isEqual(a, b) {\n  if (a === null && b === null) {\n    return true;\n  }\n\n  if (isObjectType(a) || isObjectType(b)) {\n    return false;\n  }\n\n  return a === b;\n}\n\n// http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric\nfunction isNumeric(thing) {\n  return !isNaN(parseFloat(thing)) && isFinite(thing);\n}\n\nfunction isObject(thing) {\n  return thing && toString.call(thing) === '[object Object]';\n}\n\nfunction isObjectLike(thing) {\n  return !!(thing && (isObjectType(thing) || isFunction(thing)));\n}\n\nfunction isObjectType(thing) {\n  return typeof thing === 'object';\n}\n\nfunction isFunction(thing) {\n  return typeof thing === 'function';\n}\n\nfunction isString(thing) {\n  return typeof thing === 'string';\n}\n\nfunction isNumber(thing) {\n  return typeof thing === 'number';\n}\n\nfunction isUndefined(thing) {\n  return thing === undefined;\n}\n\n/* istanbul ignore if */\nif (!Array.prototype.find) {\n  defineProperty(Array.prototype, 'find', {\n    value: function value(callback, thisArg) {\n      if (this === null || isUndefined(this))\n        { throw new TypeError('Array.prototype.find called on null or undefined'); }\n\n      if (!isFunction(callback)) { throw new TypeError((callback + \" is not a function\")); }\n\n      var array = Object(this);\n      var arrayLength = array.length >>> 0;\n\n      for (var index = 0; index < arrayLength; index++) {\n        if (!hasOwn(array, index)) { continue; }\n        if (!callback.call(thisArg, array[index], index, array)) { continue; }\n        return array[index];\n      }\n\n      return undefined;\n    },\n    configurable: true,\n    writable: true\n  });\n}\n\n// NOTE: Node doesn't exist in IE8. Nothing can be done.\n/* istanbul ignore if */\nif (\n  typeof window !== 'undefined' &&\n  window.Node &&\n  window.Node.prototype &&\n  !window.Node.prototype.contains\n) {\n  Node.prototype.contains = function(node) {\n    var this$1 = this;\n\n    if (!node) { throw new TypeError('node required'); }\n\n    do {\n      if (this$1 === node) { return true; }\n    } while ((node = node && node.parentNode));\n\n    return false;\n  };\n}\n\n/* istanbul ignore if */\nif (typeof window !== 'undefined' && window.performance && !window.performance.now) {\n  window.performance = window.performance || {};\n\n  var nowOffset = Date.now();\n\n  window.performance.now = function() {\n    return Date.now() - nowOffset;\n  };\n}\n\n/* eslint no-console:\"off\" */\nvar win = typeof window !== 'undefined' ? window : null;\nvar doc = win ? document : null;\nvar isClient = !!doc;\nvar base = typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : win;\nvar hasConsole =\n  typeof console !== 'undefined' && isFunction(console.warn) && isFunction(console.warn.apply);\n\nvar svg = doc\n  ? doc.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1')\n  : false;\n\nvar vendors = ['o', 'ms', 'moz', 'webkit'];\n\n/* istanbul ignore if */\nif (!base.Promise) {\n  var PENDING = {};\n  var FULFILLED = {};\n  var REJECTED = {};\n\n  var Promise$1 = (base.Promise = function(callback) {\n    var fulfilledHandlers = [];\n    var rejectedHandlers = [];\n    var state = PENDING;\n    var result;\n    var dispatchHandlers;\n\n    var makeResolver = function (newState) {\n      return function(value) {\n        if (state !== PENDING) { return; }\n        result = value;\n        state = newState;\n        dispatchHandlers = makeDispatcher(\n          state === FULFILLED ? fulfilledHandlers : rejectedHandlers,\n          result\n        );\n        wait(dispatchHandlers);\n      };\n    };\n\n    var fulfill = makeResolver(FULFILLED);\n    var reject = makeResolver(REJECTED);\n\n    try {\n      callback(fulfill, reject);\n    } catch (err) {\n      reject(err);\n    }\n\n    return {\n      // `then()` returns a Promise - 2.2.7\n      then: function then(onFulfilled, onRejected) {\n        var promise2 = new Promise$1(function (fulfill, reject) {\n          var processResolutionHandler = function (handler, handlers, forward) {\n            if (isFunction(handler)) {\n              handlers.push(function (p1result) {\n                try {\n                  resolve$1(promise2, handler(p1result), fulfill, reject);\n                } catch (err) {\n                  reject(err);\n                }\n              });\n            } else {\n              handlers.push(forward);\n            }\n          };\n\n          processResolutionHandler(onFulfilled, fulfilledHandlers, fulfill);\n          processResolutionHandler(onRejected, rejectedHandlers, reject);\n\n          if (state !== PENDING) {\n            wait(dispatchHandlers);\n          }\n        });\n        return promise2;\n      },\n      catch: function catch$1(onRejected) {\n        return this.then(null, onRejected);\n      },\n      finally: function finally$1(callback) {\n        return this.then(\n          function (v) {\n            callback();\n            return v;\n          },\n          function (e) {\n            callback();\n            throw e;\n          }\n        );\n      }\n    };\n  });\n\n  Promise$1.all = function(promises) {\n    return new Promise$1(function (fulfill, reject) {\n      var result = [];\n      var pending;\n      var i;\n\n      if (!promises.length) {\n        fulfill(result);\n        return;\n      }\n\n      var processPromise = function (promise, i) {\n        if (promise && isFunction(promise.then)) {\n          promise.then(function (value) {\n            result[i] = value;\n            --pending || fulfill(result);\n          }, reject);\n        } else {\n          result[i] = promise;\n          --pending || fulfill(result);\n        }\n      };\n\n      pending = i = promises.length;\n\n      while (i--) {\n        processPromise(promises[i], i);\n      }\n    });\n  };\n\n  Promise$1.race = function(promises) {\n    return new Promise$1(function (fulfill, reject) {\n      var pending = true;\n      function ok(v) {\n        if (!pending) { return; }\n        pending = false;\n        fulfill(v);\n      }\n      function fail(e) {\n        if (!pending) { return; }\n        pending = false;\n        reject(e);\n      }\n      for (var i = 0; i < promises.length; i++) {\n        if (promises[i] && isFunction(promises[i].then)) {\n          promises[i].then(ok, fail);\n        }\n      }\n    });\n  };\n\n  Promise$1.resolve = function(value) {\n    if (value && isFunction(value.then)) { return value; }\n    return new Promise$1(function (fulfill) {\n      fulfill(value);\n    });\n  };\n\n  Promise$1.reject = function(reason) {\n    if (reason && isFunction(reason.then)) { return reason; }\n    return new Promise$1(function (fulfill, reject) {\n      reject(reason);\n    });\n  };\n\n  // TODO use MutationObservers or something to simulate setImmediate\n  var wait = function(callback) {\n    setTimeout(callback, 0);\n  };\n\n  var makeDispatcher = function(handlers, result) {\n    return function() {\n      for (var handler = (void 0); (handler = handlers.shift()); ) {\n        handler(result);\n      }\n    };\n  };\n\n  var resolve$1 = function(promise, x, fulfil, reject) {\n    var then;\n    if (x === promise) {\n      throw new TypeError(\"A promise's fulfillment handler cannot return the same promise\");\n    }\n    if (x instanceof Promise$1) {\n      x.then(fulfil, reject);\n    } else if (x && (isObjectType(x) || isFunction(x))) {\n      try {\n        then = x.then;\n      } catch (e) {\n        reject(e);\n        return;\n      }\n      if (isFunction(then)) {\n        var called;\n\n        var resolvePromise = function(y) {\n          if (called) { return; }\n          called = true;\n          resolve$1(promise, y, fulfil, reject);\n        };\n        var rejectPromise = function(r) {\n          if (called) { return; }\n          called = true;\n          reject(r);\n        };\n\n        try {\n          then.call(x, resolvePromise, rejectPromise);\n        } catch (e) {\n          if (!called) {\n            reject(e);\n            called = true;\n            return;\n          }\n        }\n      } else {\n        fulfil(x);\n      }\n    } else {\n      fulfil(x);\n    }\n  };\n}\n\n/* istanbul ignore if */\nif (\n  typeof window !== 'undefined' &&\n  !(window.requestAnimationFrame && window.cancelAnimationFrame)\n) {\n  var lastTime = 0;\n  window.requestAnimationFrame = function(callback) {\n    var currentTime = Date.now();\n    var timeToNextCall = Math.max(0, 16 - (currentTime - lastTime));\n    var id = window.setTimeout(function () {\n      callback(currentTime + timeToNextCall);\n    }, timeToNextCall);\n    lastTime = currentTime + timeToNextCall;\n    return id;\n  };\n  window.cancelAnimationFrame = function(id) {\n    clearTimeout(id);\n  };\n}\n\nvar defaults = {\n  // render placement:\n  el: void 0,\n  append: false,\n  delegate: true,\n  enhance: false,\n\n  // template:\n  template: null,\n\n  // parse:\n  allowExpressions: true,\n  delimiters: ['{{', '}}'],\n  tripleDelimiters: ['{{{', '}}}'],\n  staticDelimiters: ['[[', ']]'],\n  staticTripleDelimiters: ['[[[', ']]]'],\n  csp: true,\n  interpolate: false,\n  preserveWhitespace: false,\n  preserveStandaloneSections: false,\n  sanitize: false,\n  stripComments: true,\n  contextLines: 0,\n\n  // data & binding:\n  data: create(null),\n  helpers: create(null),\n  computed: create(null),\n  syncComputedChildren: false,\n  resolveInstanceMembers: false,\n  warnAboutAmbiguity: false,\n  adapt: [],\n  isolated: true,\n  twoway: true,\n  lazy: false,\n\n  // transitions:\n  noIntro: false,\n  noOutro: false,\n  transitionsEnabled: true,\n  complete: void 0,\n  nestedTransitions: true,\n\n  // css:\n  css: null,\n  noCSSTransform: false\n};\n\n// These are a subset of the easing equations found at\n// https://raw.github.com/danro/easing-js - license info\n// follows:\n\n// --------------------------------------------------\n// easing.js v0.5.4\n// Generic set of easing functions with AMD support\n// https://github.com/danro/easing-js\n// This code may be freely distributed under the MIT license\n// http://danro.mit-license.org/\n// --------------------------------------------------\n// All functions adapted from Thomas Fuchs & Jeremy Kahn\n// Easing Equations (c) 2003 Robert Penner, BSD license\n// https://raw.github.com/danro/easing-js/master/LICENSE\n// --------------------------------------------------\n\n// In that library, the functions named easeIn, easeOut, and\n// easeInOut below are named easeInCubic, easeOutCubic, and\n// (you guessed it) easeInOutCubic.\n//\n// You can add additional easing functions to this list, and they\n// will be globally available.\n\nvar easing = {\n  linear: function linear(pos) {\n    return pos;\n  },\n  easeIn: function easeIn(pos) {\n    /* istanbul ignore next */\n    return Math.pow(pos, 3);\n  },\n  easeOut: function easeOut(pos) {\n    return Math.pow(pos - 1, 3) + 1;\n  },\n  easeInOut: function easeInOut(pos) {\n    /* istanbul ignore next */\n    if ((pos /= 0.5) < 1) {\n      return 0.5 * Math.pow(pos, 3);\n    }\n    /* istanbul ignore next */\n    return 0.5 * (Math.pow(pos - 2, 3) + 2);\n  }\n};\n\nfunction noop() {}\n\n/* global console */\n/* eslint no-console:\"off\" */\n\nvar alreadyWarned = {};\nvar log;\nvar printWarning;\nvar welcome;\n\nif (hasConsole) {\n  var welcomeIntro = [\n    \"%cRactive.js %c1.4.0-edge %cin debug mode, %cmore...\",\n    'color: rgb(114, 157, 52); font-weight: normal;',\n    'color: rgb(85, 85, 85); font-weight: normal;',\n    'color: rgb(85, 85, 85); font-weight: normal;',\n    'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;'\n  ];\n  var welcomeMessage = \"You're running Ractive 1.4.0-edge in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\\n\\nTo disable debug mode, add this line at the start of your app:\\n  Ractive.DEBUG = false;\\n\\nTo disable debug mode when your app is minified, add this snippet:\\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\\n\\nGet help and support:\\n  http://ractive.js.org\\n  http://stackoverflow.com/questions/tagged/ractivejs\\n  http://groups.google.com/forum/#!forum/ractive-js\\n  http://twitter.com/ractivejs\\n\\nFound a bug? Raise an issue:\\n  https://github.com/ractivejs/ractive/issues\\n\\n\";\n\n  welcome = function () {\n    if (Ractive.WELCOME_MESSAGE === false) {\n      welcome = noop;\n      return;\n    }\n    var message = 'WELCOME_MESSAGE' in Ractive ? Ractive.WELCOME_MESSAGE : welcomeMessage;\n    var hasGroup = !!console.groupCollapsed;\n    if (hasGroup) { console.groupCollapsed.apply(console, welcomeIntro); }\n    console.log(message);\n    if (hasGroup) {\n      console.groupEnd(welcomeIntro);\n    }\n\n    welcome = noop;\n  };\n\n  printWarning = function (message, args) {\n    welcome();\n\n    // extract information about the instance this message pertains to, if applicable\n    if (isObjectType(args[args.length - 1])) {\n      var options = args.pop();\n      var ractive = options ? options.ractive : null;\n\n      if (ractive) {\n        // if this is an instance of a component that we know the name of, add\n        // it to the message\n        var name;\n        if (ractive.component && (name = ractive.component.name)) {\n          message = \"<\" + name + \"> \" + message;\n        }\n\n        var node;\n        if (\n          (node =\n            options.node || (ractive.fragment && ractive.fragment.rendered && ractive.find('*')))\n        ) {\n          args.push(node);\n        }\n      }\n    }\n\n    console.warn.apply(\n      console,\n      ['%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);'].concat(\n        args\n      )\n    );\n  };\n\n  log = function() {\n    console.log.apply(console, arguments);\n  };\n} else {\n  printWarning = log = welcome = noop;\n}\n\nfunction format(message, args) {\n  return message.replace(/%s/g, function () { return args.shift(); });\n}\n\nfunction fatal(message) {\n  var args = [], len = arguments.length - 1;\n  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  message = format(message, args);\n  throw new Error(message);\n}\n\nfunction logIfDebug() {\n  if (Ractive.DEBUG) {\n    log.apply(null, arguments);\n  }\n}\n\nfunction warn(message) {\n  var args = [], len = arguments.length - 1;\n  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  message = format(message, args);\n  printWarning(message, args);\n}\n\nfunction warnOnce(message) {\n  var args = [], len = arguments.length - 1;\n  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  message = format(message, args);\n\n  if (alreadyWarned[message]) {\n    return;\n  }\n\n  alreadyWarned[message] = true;\n  printWarning(message, args);\n}\n\nfunction warnIfDebug() {\n  if (Ractive.DEBUG) {\n    warn.apply(null, arguments);\n  }\n}\n\nfunction warnOnceIfDebug() {\n  if (Ractive.DEBUG) {\n    warnOnce.apply(null, arguments);\n  }\n}\n\n// Error messages that are used (or could be) in multiple places\nvar badArguments = 'Bad arguments';\nvar noRegistryFunctionReturn =\n  'A function was specified for \"%s\" %s, but no %s was returned';\nvar missingPlugin = function (name, type) { return (\"Missing \\\"\" + name + \"\\\" \" + type + \" plugin. You may need to download a plugin via http://ractive.js.org/integrations/#\" + type + \"s\"); };\n\nfunction findInViewHierarchy(registryName, ractive, name) {\n  var instance = findInstance(registryName, ractive, name);\n  return instance ? instance[registryName][name] : null;\n}\n\nfunction findInstance(registryName, ractive, name) {\n  while (ractive) {\n    if (name in ractive[registryName]) {\n      return ractive;\n    }\n\n    if (ractive.isolated) {\n      return null;\n    }\n\n    ractive = ractive.parent;\n  }\n}\n\nfunction interpolate(from, to, ractive, type) {\n  if (from === to) { return null; }\n\n  if (type) {\n    var interpol = findInViewHierarchy('interpolators', ractive, type);\n    if (interpol) { return interpol(from, to) || null; }\n\n    fatal(missingPlugin(type, 'interpolator'));\n  }\n\n  return (\n    interpolators.number(from, to) ||\n    interpolators.array(from, to) ||\n    interpolators.object(from, to) ||\n    null\n  );\n}\n\nvar interpolators = {\n  number: function number(from, to) {\n    if (!isNumeric(from) || !isNumeric(to)) {\n      return null;\n    }\n\n    from = +from;\n    to = +to;\n\n    var delta = to - from;\n\n    if (!delta) {\n      return function() {\n        return from;\n      };\n    }\n\n    return function(t) {\n      return from + t * delta;\n    };\n  },\n\n  array: function array(from, to) {\n    var len, i;\n\n    if (!isArray(from) || !isArray(to)) {\n      return null;\n    }\n\n    var intermediate = [];\n    var interpolators = [];\n\n    i = len = Math.min(from.length, to.length);\n    while (i--) {\n      interpolators[i] = interpolate(from[i], to[i]);\n    }\n\n    // surplus values - don't interpolate, but don't exclude them either\n    for (i = len; i < from.length; i += 1) {\n      intermediate[i] = from[i];\n    }\n\n    for (i = len; i < to.length; i += 1) {\n      intermediate[i] = to[i];\n    }\n\n    return function(t) {\n      var i = len;\n\n      while (i--) {\n        intermediate[i] = interpolators[i](t);\n      }\n\n      return intermediate;\n    };\n  },\n\n  object: function object(from, to) {\n    if (!isObject(from) || !isObject(to)) {\n      return null;\n    }\n\n    var properties = [];\n    var intermediate = {};\n    var interpolators = {};\n\n    var loop = function ( prop ) {\n      if (hasOwn(from, prop)) {\n        if (hasOwn(to, prop)) {\n          properties.push(prop);\n          interpolators[prop] = interpolate(from[prop], to[prop]) || (function () { return to[prop]; });\n        } else {\n          intermediate[prop] = from[prop];\n        }\n      }\n    };\n\n    for (var prop in from) loop( prop );\n\n    for (var prop$1 in to) {\n      if (hasOwn(to, prop$1) && !hasOwn(from, prop$1)) {\n        intermediate[prop$1] = to[prop$1];\n      }\n    }\n\n    var len = properties.length;\n\n    return function(t) {\n      var i = len;\n\n      while (i--) {\n        var prop = properties[i];\n\n        intermediate[prop] = interpolators[prop](t);\n      }\n\n      return intermediate;\n    };\n  }\n};\n\nvar refPattern = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\nvar splitPattern = /([^\\\\](?:\\\\\\\\)*)\\./;\nvar escapeKeyPattern = /\\\\|\\./g;\nvar unescapeKeyPattern = /((?:\\\\)+)\\1|\\\\(\\.)/g;\n\nfunction escapeKey(key) {\n  if (isString(key)) {\n    return key.replace(escapeKeyPattern, '\\\\$&');\n  }\n\n  return key;\n}\n\nfunction normalise(ref) {\n  return ref ? ref.replace(refPattern, '.$1') : '';\n}\n\nfunction splitKeypath(keypath) {\n  var result = [];\n  var match;\n\n  keypath = normalise(keypath);\n\n  while ((match = splitPattern.exec(keypath))) {\n    var index = match.index + match[1].length;\n    result.push(keypath.substr(0, index));\n    keypath = keypath.substr(index + 1);\n  }\n\n  result.push(keypath);\n\n  return result;\n}\n\nfunction unescapeKey(key) {\n  if (isString(key)) {\n    return key.replace(unescapeKeyPattern, '$1$2');\n  }\n\n  return key;\n}\n\nfunction addToArray(array, value) {\n  var index = array.indexOf(value);\n\n  if (index === -1) {\n    array.push(value);\n  }\n}\n\nfunction arrayContains(array, value) {\n  for (var i = 0, c = array.length; i < c; i++) {\n    if (array[i] == value) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction arrayContentsMatch(a, b) {\n  var i;\n\n  if (!isArray(a) || !isArray(b)) {\n    return false;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  i = a.length;\n  while (i--) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction ensureArray(x) {\n  if (isString(x)) {\n    return [x];\n  }\n\n  if (isUndefined(x)) {\n    return [];\n  }\n\n  return x;\n}\n\nfunction lastItem(array) {\n  return array[array.length - 1];\n}\n\nfunction removeFromArray(array, member) {\n  if (!array) {\n    return;\n  }\n\n  var index = array.indexOf(member);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\nfunction combine() {\n  var arrays = [], len = arguments.length;\n  while ( len-- ) arrays[ len ] = arguments[ len ];\n\n  var res = arrays.concat.apply([], arrays);\n  var i = res.length;\n  while (i--) {\n    var idx = res.indexOf(res[i]);\n    if (~idx && idx < i) { res.splice(i, 1); }\n  }\n\n  return res;\n}\n\nfunction toArray(arrayLike) {\n  var array = [];\n  var i = arrayLike.length;\n  while (i--) {\n    array[i] = arrayLike[i];\n  }\n\n  return array;\n}\n\nfunction findMap(array, fn) {\n  var len = array.length;\n  for (var i = 0; i < len; i++) {\n    var result = fn(array[i]);\n    if (result) { return result; }\n  }\n}\n\nfunction buildNewIndices(one, two, comparator) {\n  var oldArray = one;\n  var newArray = two;\n  if (comparator) {\n    oldArray = oldArray.map(comparator);\n    newArray = newArray.map(comparator);\n  }\n\n  var oldLength = oldArray.length;\n\n  var usedIndices = {};\n  var firstUnusedIndex = 0;\n\n  var result = oldArray.map(function (item) {\n    var index;\n    var start = firstUnusedIndex;\n\n    do {\n      index = newArray.indexOf(item, start);\n\n      if (index === -1) {\n        return -1;\n      }\n\n      start = index + 1;\n    } while (usedIndices[index] === true && start < oldLength);\n\n    // keep track of the first unused index, so we don't search\n    // the whole of newArray for each item in oldArray unnecessarily\n    if (index === firstUnusedIndex) {\n      firstUnusedIndex += 1;\n    }\n    // allow next instance of next \"equal\" to be found item\n    usedIndices[index] = true;\n    return index;\n  });\n\n  var len = (result.oldLen = oldArray.length);\n  result.newLen = newArray.length;\n\n  if (len === result.newLen) {\n    var i = 0;\n    for (i; i < len; i++) {\n      if (result[i] !== i) { break; }\n    }\n\n    if (i === len) { result.same = true; }\n  }\n\n  return result;\n}\n\nvar fnBind = Function.prototype.bind;\n\nfunction bind(fn, context) {\n  if (!/this/.test(fn.toString())) { return fn; }\n\n  var bound = fnBind.call(fn, context);\n  for (var prop in fn) { bound[prop] = fn[prop]; }\n\n  return bound;\n}\n\nvar shuffleTasks = { early: [], mark: [] };\nvar registerQueue = { early: [], mark: [] };\nvar noVirtual = { virtual: false };\n\nvar ModelBase = function ModelBase(parent) {\n  this.deps = [];\n\n  this.children = [];\n  this.childByKey = {};\n  this.links = [];\n\n  this.bindings = [];\n\n  if (parent) {\n    this.parent = parent;\n    this.root = parent.root;\n  }\n};\nvar ModelBase__proto__ = ModelBase.prototype;\n\nModelBase__proto__.addShuffleTask = function addShuffleTask (task, stage) {\n    if ( stage === void 0 ) stage = 'early';\n\n  shuffleTasks[stage].push(task);\n};\nModelBase__proto__.addShuffleRegister = function addShuffleRegister (item, stage) {\n    if ( stage === void 0 ) stage = 'early';\n\n  registerQueue[stage].push({ model: this, item: item });\n};\n\nModelBase__proto__.downstreamChanged = function downstreamChanged () {};\n\nModelBase__proto__.findMatches = function findMatches (keys$$1) {\n  var len = keys$$1.length;\n\n  var existingMatches = [this];\n  var matches;\n  var i;\n\n  var loop = function (  ) {\n    var key = keys$$1[i];\n\n    if (key === '*') {\n      matches = [];\n      existingMatches.forEach(function (model) {\n        matches.push.apply(matches, model.getValueChildren(model.get()));\n      });\n    } else {\n      matches = existingMatches.map(function (model) { return model.joinKey(key); });\n    }\n\n    existingMatches = matches;\n  };\n\n    for (i = 0; i < len; i += 1) loop(  );\n\n  return matches;\n};\n\nModelBase__proto__.getKeypath = function getKeypath (ractive) {\n  if (ractive !== this.ractive && this._link) { return this._link.target.getKeypath(ractive); }\n\n  if (!this.keypath) {\n    var parent = this.parent && this.parent.getKeypath(ractive);\n    this.keypath = parent\n      ? ((this.parent.getKeypath(ractive)) + \".\" + (escapeKey(this.key)))\n      : escapeKey(this.key);\n  }\n\n  return this.keypath;\n};\n\nModelBase__proto__.getValueChildren = function getValueChildren (value) {\n    var this$1 = this;\n\n  var children;\n  if (isArray(value)) {\n    children = [];\n    if ('length' in this && this.length !== value.length) {\n      children.push(this.joinKey('length'));\n    }\n    value.forEach(function (m, i) {\n      children.push(this$1.joinKey(i));\n    });\n  } else if (isObject(value) || isFunction(value)) {\n    children = keys(value).map(function (key) { return this$1.joinKey(escapeKey(key)); });\n  } else if (value != null) {\n    children = [];\n  }\n\n  var computed = this.computed;\n  if (computed) {\n    children.push.apply(children, keys(computed).map(function (k) { return this$1.joinKey(k); }));\n  }\n\n  return children;\n};\n\nModelBase__proto__.getVirtual = function getVirtual (shouldCapture) {\n    var this$1 = this;\n\n  var value = this.get(shouldCapture, { virtual: false });\n  if (isObjectLike(value)) {\n    var result = isArray(value) ? [] : create(null);\n\n    var keys$$1 = keys(value);\n    var i = keys$$1.length;\n    while (i--) {\n      var child = this$1.childByKey[keys$$1[i]];\n      if (!child) { result[keys$$1[i]] = value[keys$$1[i]]; }\n      else if (child._link) { result[keys$$1[i]] = child._link.getVirtual(); }\n      else { result[keys$$1[i]] = child.getVirtual(); }\n    }\n\n    i = this.children.length;\n    while (i--) {\n      var child$1 = this$1.children[i];\n      if (!(child$1.key in result) && child$1._link) {\n        result[child$1.key] = child$1._link.getVirtual();\n      }\n    }\n\n    if (this.computed) {\n      keys$$1 = keys(this.computed);\n      i = keys$$1.length;\n      while (i--) {\n        result[keys$$1[i]] = this$1.computed[keys$$1[i]].get();\n      }\n    }\n\n    return result;\n  } else { return value; }\n};\n\nModelBase__proto__.has = function has (key) {\n    var this$1 = this;\n\n  if (this._link) { return this._link.has(key); }\n\n  var value = this.get(false, noVirtual);\n  if (!value) { return false; }\n\n  key = unescapeKey(key);\n  if ((isFunction(value) || isObject(value)) && key in value) { return true; }\n\n  var computed = this.computed;\n  if (computed && key in this.computed) { return true; }\n\n  computed = this.root.ractive && this.root.ractive.computed;\n  if (computed) {\n    keys(computed).forEach(function (k) {\n      if (computed[k].pattern && computed[k].pattern.test(this$1.getKeypath())) { return true; }\n    });\n  }\n\n  return false;\n};\n\nModelBase__proto__.joinAll = function joinAll (keys$$1, opts) {\n  var model = this;\n  for (var i = 0; i < keys$$1.length; i += 1) {\n    if (\n      opts &&\n      opts.lastLink === false &&\n      i + 1 === keys$$1.length &&\n      model.childByKey[keys$$1[i]] &&\n      model.childByKey[keys$$1[i]]._link\n    )\n      { return model.childByKey[keys$$1[i]]; }\n    model = model.joinKey(keys$$1[i], opts);\n  }\n\n  return model;\n};\n\nModelBase__proto__.notifyUpstream = function notifyUpstream (startPath) {\n    var this$1 = this;\n\n  var parent = this.parent;\n  var path = startPath || [this.key];\n  while (parent) {\n    if (parent.patterns) { parent.patterns.forEach(function (o) { return o.notify(path.slice()); }); }\n    path.unshift(parent.key);\n    parent.links.forEach(function (l) { return l.notifiedUpstream(path, this$1.root); });\n    parent.deps.forEach(function (d) { return d.handleChange(path); });\n    parent.downstreamChanged(startPath);\n    parent = parent.parent;\n  }\n};\n\nModelBase__proto__.rebind = function rebind (next, previous, safe) {\n    var this$1 = this;\n\n  if (this._link) {\n    this._link.rebind(next, previous, false);\n  }\n\n  if (next === this) { return; }\n\n  // tell the deps to move to the new target\n  var i = this.deps.length;\n  while (i--) {\n    if (this$1.deps[i].rebind) { this$1.deps[i].rebind(next, previous, safe); }\n  }\n\n  i = this.links.length;\n  while (i--) {\n    var link = this$1.links[i];\n    // only relink the root of the link tree\n    if (link.owner && link.owner._link) { link.relinking(next, safe); }\n  }\n\n  i = this.children.length;\n  while (i--) {\n    var child = this$1.children[i];\n    child.rebind(next ? next.joinKey(child.key) : undefined, child._link || child, safe);\n    if (this$1.dataModel) {\n      this$1.addShuffleTask(function () { return checkDataLink(this$1, this$1.retrieve()); }, 'early');\n    }\n  }\n\n  i = this.bindings.length;\n  while (i--) {\n    this$1.bindings[i].rebind(next, previous, safe);\n  }\n};\n\nModelBase__proto__.reference = function reference () {\n  'refs' in this ? this.refs++ : (this.refs = 1);\n};\n\nModelBase__proto__.register = function register (dep) {\n  this.deps.push(dep);\n};\n\nModelBase__proto__.registerLink = function registerLink (link) {\n  addToArray(this.links, link);\n};\n\nModelBase__proto__.registerPatternObserver = function registerPatternObserver (observer) {\n  (this.patterns || (this.patterns = [])).push(observer);\n  this.register(observer);\n};\n\nModelBase__proto__.registerTwowayBinding = function registerTwowayBinding (binding) {\n  this.bindings.push(binding);\n};\n\nModelBase__proto__.unreference = function unreference () {\n  if ('refs' in this) { this.refs--; }\n};\n\nModelBase__proto__.unregister = function unregister (dep) {\n  removeFromArray(this.deps, dep);\n};\n\nModelBase__proto__.unregisterLink = function unregisterLink (link) {\n  removeFromArray(this.links, link);\n};\n\nModelBase__proto__.unregisterPatternObserver = function unregisterPatternObserver (observer) {\n  removeFromArray(this.patterns, observer);\n  this.unregister(observer);\n};\n\nModelBase__proto__.unregisterTwowayBinding = function unregisterTwowayBinding (binding) {\n  removeFromArray(this.bindings, binding);\n};\n\nModelBase__proto__.updateFromBindings = function updateFromBindings$1 (cascade) {\n    var this$1 = this;\n\n  var i = this.bindings.length;\n  while (i--) {\n    var value = this$1.bindings[i].getValue();\n    if (value !== this$1.value) { this$1.set(value); }\n  }\n\n  // check for one-way bindings if there are no two-ways\n  if (!this.bindings.length) {\n    var oneway = findBoundValue(this.deps);\n    if (oneway && oneway.value !== this.value) { this.set(oneway.value); }\n  }\n\n  if (cascade) {\n    this.children.forEach(updateFromBindings);\n    this.links.forEach(updateFromBindings);\n    if (this._link) { this._link.updateFromBindings(cascade); }\n  }\n};\n\n// TODO: this may be better handled by overriding `get` on models with a parent that isRoot\nfunction maybeBind(model, value, shouldBind) {\n  if (shouldBind && isFunction(value) && model.parent && model.parent.isRoot) {\n    if (!model.boundValue) {\n      model.boundValue = bind(value._r_unbound || value, model.parent.ractive);\n    }\n\n    return model.boundValue;\n  }\n\n  return value;\n}\n\nfunction updateFromBindings(model) {\n  model.updateFromBindings(true);\n}\n\nfunction findBoundValue(list) {\n  var i = list.length;\n  while (i--) {\n    if (list[i].bound) {\n      var owner = list[i].owner;\n      if (owner) {\n        var value = owner.name === 'checked' ? owner.node.checked : owner.node.value;\n        return { value: value };\n      }\n    }\n  }\n}\n\nfunction fireShuffleTasks(stage) {\n  if (!stage) {\n    fireShuffleTasks('early');\n    fireShuffleTasks('mark');\n  } else {\n    var tasks = shuffleTasks[stage];\n    shuffleTasks[stage] = [];\n    var i = tasks.length;\n    while (i--) { tasks[i](); }\n\n    var register = registerQueue[stage];\n    registerQueue[stage] = [];\n    i = register.length;\n    while (i--) { register[i].model.register(register[i].item); }\n  }\n}\n\nfunction shuffle(model, newIndices, link, unsafe) {\n  model.shuffling = true;\n\n  var i = newIndices.length;\n  while (i--) {\n    var idx = newIndices[i];\n    // nothing is actually changing, so move in the index and roll on\n    if (i === idx) {\n      continue;\n    }\n\n    // rebind the children on i to idx\n    if (i in model.childByKey)\n      { model.childByKey[i].rebind(\n        !~idx ? undefined : model.joinKey(idx),\n        model.childByKey[i],\n        !unsafe\n      ); }\n  }\n\n  var upstream = model.source().length !== model.source().value.length;\n\n  model.links.forEach(function (l) { return l.shuffle(newIndices); });\n  if (!link) { fireShuffleTasks('early'); }\n\n  i = model.deps.length;\n  while (i--) {\n    if (model.deps[i].shuffle) { model.deps[i].shuffle(newIndices); }\n  }\n\n  model[link ? 'marked' : 'mark']();\n  if (!link) { fireShuffleTasks('mark'); }\n\n  if (upstream) { model.notifyUpstream(); }\n\n  model.shuffling = false;\n}\n\nfunction checkDataLink(model, value) {\n  if (value !== model.dataModel) {\n    if (value && value.viewmodel && value.viewmodel.isRoot && model.childByKey.data) {\n      model.childByKey.data.link(value.viewmodel, 'data');\n      model.dataModel = value;\n    } else if (model.dataModel) {\n      model.childByKey.data.unlink();\n      model.dataModel = true;\n    }\n  }\n}\n\nvar stack = [];\nvar captureGroup;\n\nfunction startCapturing() {\n  stack.push((captureGroup = []));\n}\n\nfunction stopCapturing() {\n  var dependencies = stack.pop();\n  captureGroup = stack[stack.length - 1];\n  return dependencies;\n}\n\nfunction capture(model) {\n  if (captureGroup) {\n    addToArray(captureGroup, model);\n  }\n}\n\nfunction bind$1(x) {\n  x.bind();\n}\nfunction cancel(x) {\n  x.cancel();\n}\nfunction destroyed(x) {\n  x.destroyed();\n}\nfunction handleChange(x) {\n  x.handleChange();\n}\nfunction mark(x) {\n  x.mark();\n}\nfunction markForce(x) {\n  x.mark(true);\n}\nfunction marked(x) {\n  x.marked();\n}\nfunction markedAll(x) {\n  x.markedAll();\n}\nfunction render(x) {\n  x.render();\n}\nfunction shuffled(x) {\n  x.shuffled();\n}\nfunction teardown(x) {\n  x.teardown();\n}\nfunction unbind(x) {\n  x.unbind();\n}\nfunction unrender(x) {\n  x.unrender();\n}\n\nfunction update(x) {\n  x.update();\n}\nfunction toString$1(x) {\n  return x.toString();\n}\nfunction toEscapedString(x) {\n  return x.toString(true);\n}\n\n// this is the dry method of checking to see if a rebind applies to\n// a particular keypath because in some cases, a dep may be bound\n// directly to a particular keypath e.g. foo.bars.0.baz and need\n// to avoid getting kicked to foo.bars.1.baz if foo.bars is unshifted\nfunction rebindMatch(template, next, previous, fragment) {\n  var keypath = template.r || template;\n\n  // no valid keypath, go with next\n  if (!keypath || !isString(keypath)) { return next; }\n\n  // completely contextual ref, go with next\n  if (\n    keypath === '.' ||\n    keypath[0] === '@' ||\n    (next || previous).isKey ||\n    (next || previous).isKeypath\n  )\n    { return next; }\n\n  var parts = keypath.split('/');\n  var keys = splitKeypath(parts[parts.length - 1]);\n  var last = keys[keys.length - 1];\n\n  // check the keypath against the model keypath to see if it matches\n  var model = next || previous;\n\n  // check to see if this was an alias\n  if (model && keys.length === 1 && last !== model.key && fragment) {\n    keys = findAlias(last, fragment) || keys;\n  }\n\n  var i = keys.length;\n  var match = true;\n  var shuffling = false;\n\n  while (model && i--) {\n    if (model.shuffling) { shuffling = true; }\n    // non-strict comparison to account for indices in keypaths\n    if (keys[i] != model.key) { match = false; }\n    model = model.parent;\n  }\n\n  // next is undefined, but keypath is shuffling and previous matches\n  if (!next && match && shuffling) { return previous; }\n  else if (next && !match && shuffling)\n    // next is defined, but doesn't match the keypath\n    { return previous; }\n  else { return next; }\n}\n\nfunction findAlias(name, fragment) {\n  while (fragment) {\n    var z = fragment.aliases;\n    if (z && z[name]) {\n      var aliases = (fragment.owner.iterations ? fragment.owner : fragment).owner.template.z;\n      for (var i = 0; i < aliases.length; i++) {\n        if (aliases[i].n === name) {\n          var alias = aliases[i].x;\n          if (!alias.r) { return false; }\n          var parts = alias.r.split('/');\n          return splitKeypath(parts[parts.length - 1]);\n        }\n      }\n      return;\n    }\n\n    fragment = fragment.componentParent || fragment.parent;\n  }\n}\n\n// temporary placeholder target for detached implicit links\nvar Missing = {\n  key: '@missing',\n  animate: noop,\n  applyValue: noop,\n  get: noop,\n  getKeypath: function getKeypath() {\n    return this.key;\n  },\n  joinAll: function joinAll() {\n    return this;\n  },\n  joinKey: function joinKey() {\n    return this;\n  },\n  mark: noop,\n  registerLink: noop,\n  shufle: noop,\n  set: noop,\n  unregisterLink: noop\n};\nMissing.parent = Missing;\n\nvar LinkModel = (function (ModelBase) {\n  function LinkModel(parent, owner, target, key) {\n    ModelBase.call(this, parent);\n\n    this.owner = owner;\n    this.target = target;\n    this.key = isUndefined(key) ? owner.key : key;\n    if (owner && owner.isLink) { this.sourcePath = (owner.sourcePath) + \".\" + (this.key); }\n\n    if (target) { target.registerLink(this); }\n\n    if (parent) { this.isReadonly = parent.isReadonly; }\n\n    this.isLink = true;\n  }\n\n  if ( ModelBase ) LinkModel.__proto__ = ModelBase;\n  var LinkModel__proto__ = LinkModel.prototype = Object.create( ModelBase && ModelBase.prototype );\n  LinkModel__proto__.constructor = LinkModel;\n\n  LinkModel__proto__.animate = function animate (from, to, options, interpolator) {\n    return this.target.animate(from, to, options, interpolator);\n  };\n\n  LinkModel__proto__.applyValue = function applyValue (value) {\n    if (this.boundValue) { this.boundValue = null; }\n    this.target.applyValue(value);\n  };\n\n  LinkModel__proto__.attach = function attach (fragment) {\n    var model = resolveReference(fragment, this.key);\n    if (model) {\n      this.relinking(model, false);\n    } else {\n      // if there is no link available, move everything here to real models\n      this.owner.unlink();\n    }\n  };\n\n  LinkModel__proto__.detach = function detach () {\n    this.relinking(Missing, false);\n  };\n\n  LinkModel__proto__.get = function get (shouldCapture, opts) {\n    if ( opts === void 0 ) opts = {};\n\n    if (shouldCapture) {\n      capture(this);\n\n      // may need to tell the target to unwrap\n      opts.unwrap = 'unwrap' in opts ? opts.unwrap : true;\n    }\n\n    var bind = 'shouldBind' in opts ? opts.shouldBind : true;\n    opts.shouldBind = this.mapping && this.target.parent && this.target.parent.isRoot;\n\n    return maybeBind(this, this.target.get(false, opts), bind);\n  };\n\n  LinkModel__proto__.getKeypath = function getKeypath (ractive) {\n    if (ractive && ractive !== this.root.ractive) { return this.target.getKeypath(ractive); }\n\n    return ModelBase.prototype.getKeypath.call(this, ractive);\n  };\n\n  LinkModel__proto__.handleChange = function handleChange$1 () {\n    this.deps.forEach(handleChange);\n    this.links.forEach(handleChange);\n    this.notifyUpstream();\n  };\n\n  LinkModel__proto__.isDetached = function isDetached () {\n    return this.virtual && this.target === Missing;\n  };\n\n  LinkModel__proto__.joinKey = function joinKey (key) {\n    // TODO: handle nested links\n    if (isUndefined(key) || key === '') { return this; }\n\n    if (!hasOwn(this.childByKey, key)) {\n      var child = new LinkModel(this, this, this.target.joinKey(key), key);\n      this.children.push(child);\n      this.childByKey[key] = child;\n    }\n\n    return this.childByKey[key];\n  };\n\n  LinkModel__proto__.mark = function mark (force) {\n    this.target.mark(force);\n  };\n\n  LinkModel__proto__.marked = function marked$1 () {\n    if (this.boundValue) { this.boundValue = null; }\n\n    this.links.forEach(marked);\n\n    this.deps.forEach(handleChange);\n  };\n\n  LinkModel__proto__.markedAll = function markedAll$1 () {\n    this.children.forEach(markedAll);\n    this.marked();\n  };\n\n  LinkModel__proto__.notifiedUpstream = function notifiedUpstream (startPath, root) {\n    var this$1 = this;\n\n    this.links.forEach(function (l) { return l.notifiedUpstream(startPath, this$1.root); });\n    this.deps.forEach(handleChange);\n    if (startPath && this.rootLink) {\n      var parent = this.parent;\n      if (this.root !== root) {\n        var path = startPath.slice(1);\n        path.unshift(this.key);\n        this.notifyUpstream(path);\n      } else if (parent && parent !== this.target) {\n        var path$1 = [parent.key, this.key];\n        parent.links.forEach(function (l) { return l.notifiedUpstream(path$1, parent.root); });\n        parent.deps.forEach(function (d) { return d.handleChange(path$1); });\n        parent.notifyUpstream(path$1);\n      }\n    }\n  };\n\n  LinkModel__proto__.relinked = function relinked () {\n    this.target.registerLink(this);\n    this.children.forEach(function (c) { return c.relinked(); });\n  };\n\n  LinkModel__proto__.relinking = function relinking (target, safe) {\n    var this$1 = this;\n\n    if (this.rootLink && this.sourcePath)\n      { target = rebindMatch(this.sourcePath, target, this.target); }\n    if (!target || this.target === target) { return; }\n\n    this.target && this.target.unregisterLink(this);\n\n    this.target = target;\n    this.children.forEach(function (c) {\n      c.relinking(target.joinKey(c.key), safe);\n    });\n\n    if (!safe) { this.keypath = undefined; }\n\n    if (this.rootLink)\n      { this.addShuffleTask(function () {\n        this$1.relinked();\n        if (!safe) {\n          this$1.markedAll();\n          this$1.notifyUpstream();\n        }\n      }); }\n  };\n\n  LinkModel__proto__.set = function set (value) {\n    if (this.boundValue) { this.boundValue = null; }\n    this.target.set(value);\n  };\n\n  LinkModel__proto__.shuffle = function shuffle$1 (newIndices) {\n    // watch for extra shuffles caused by a shuffle in a downstream link\n    if (this.shuffling) { return; }\n\n    // let the real model handle firing off shuffles\n    if (!this.target.shuffling) {\n      if (this.target.shuffle) {\n        this.target.shuffle(newIndices);\n      } else {\n        // the target is a computation, which can't shuffle\n        this.target.mark();\n      }\n    } else {\n      shuffle(this, newIndices, true);\n    }\n  };\n\n  LinkModel__proto__.source = function source () {\n    if (this.target.source) { return this.target.source(); }\n    else { return this.target; }\n  };\n\n  LinkModel__proto__.teardown = function teardown$3 () {\n    if (this._link) { this._link.teardown(); }\n    this.target.unregisterLink(this);\n    this.children.forEach(teardown);\n  };\n\n  return LinkModel;\n}(ModelBase));\n\nModelBase.prototype.link = function link(model, keypath, options) {\n  var lnk = this._link || new LinkModel(this.parent, this, model, this.key);\n  lnk.implicit = options && options.implicit;\n  lnk.mapping = options && options.mapping;\n  lnk.sourcePath = keypath;\n  lnk.rootLink = true;\n  if (this._link) { this._link.relinking(model, false); }\n  this.rebind(lnk, this, false);\n  fireShuffleTasks();\n\n  this._link = lnk;\n  lnk.markedAll();\n\n  this.notifyUpstream();\n  return lnk;\n};\n\nModelBase.prototype.unlink = function unlink() {\n  if (this._link) {\n    var ln = this._link;\n    this._link = undefined;\n    ln.rebind(this, ln, false);\n    fireShuffleTasks();\n    ln.teardown();\n    this.notifyUpstream();\n  }\n};\n\nfunction fromExpression(body, length) {\n  if ( length === void 0 ) length = 0;\n\n  var args = new Array(length);\n\n  while (length--) {\n    args[length] = \"_\" + length;\n  }\n\n  // Functions created directly with new Function() look like this:\n  //     function anonymous (_0 /**/) { return _0*2 }\n  //\n  // With this workaround, we get a little more compact:\n  //     function (_0){return _0*2}\n  return new Function([], (\"return function (\" + (args.join(',')) + \"){return(\" + body + \");};\"))();\n}\n\nvar functions = create(null);\n\nfunction getFunction(str, i) {\n  if (functions[str]) { return functions[str]; }\n  return (functions[str] = createFunction(str, i));\n}\n\nfunction addFunctions(template) {\n  if (!template) { return; }\n\n  var exp = template.e;\n\n  if (!exp) { return; }\n\n  keys(exp).forEach(function (str) {\n    if (functions[str]) { return; }\n    functions[str] = exp[str];\n  });\n}\n\nvar TEMPLATE_VERSION = 4;\n\nvar leadingWhitespace = /^\\s+/;\n\nvar ParseError = function(message) {\n  this.name = 'ParseError';\n  this.message = message;\n  try {\n    throw new Error(message);\n  } catch (e) {\n    this.stack = e.stack;\n  }\n};\n\nParseError.prototype = Error.prototype;\n\nvar Parser = function(str, options) {\n  var item;\n  var lineStart = 0;\n\n  this.str = str;\n  this.options = options || {};\n  this.pos = 0;\n\n  this.lines = this.str.split('\\n');\n  this.lineEnds = this.lines.map(function (line) {\n    var lineEnd = lineStart + line.length + 1; // +1 for the newline\n\n    lineStart = lineEnd;\n    return lineEnd;\n  }, 0);\n\n  // Custom init logic\n  if (this.init) { this.init(str, options); }\n\n  var items = [];\n\n  while (this.pos < this.str.length && (item = this.read())) {\n    items.push(item);\n  }\n\n  this.leftover = this.remaining();\n  this.result = this.postProcess ? this.postProcess(items, options) : items;\n};\n\nParser.prototype = {\n  read: function read(converters) {\n    var this$1 = this;\n\n    var i, item;\n\n    if (!converters) { converters = this.converters; }\n\n    var pos = this.pos;\n\n    var len = converters.length;\n    for (i = 0; i < len; i += 1) {\n      this$1.pos = pos; // reset for each attempt\n\n      if ((item = converters[i](this$1))) {\n        return item;\n      }\n    }\n\n    return null;\n  },\n\n  getContextMessage: function getContextMessage(pos, message) {\n    var ref = this.getLinePos(pos);\n    var lineNum = ref[0];\n    var columnNum = ref[1];\n    if (this.options.contextLines === -1) {\n      return [lineNum, columnNum, (message + \" at line \" + lineNum + \" character \" + columnNum)];\n    }\n\n    var line = this.lines[lineNum - 1];\n\n    var contextUp = '';\n    var contextDown = '';\n    if (this.options.contextLines) {\n      var start =\n        lineNum - 1 - this.options.contextLines < 0 ? 0 : lineNum - 1 - this.options.contextLines;\n      contextUp = this.lines\n        .slice(start, lineNum - 1 - start)\n        .join('\\n')\n        .replace(/\\t/g, '  ');\n      contextDown = this.lines\n        .slice(lineNum, lineNum + this.options.contextLines)\n        .join('\\n')\n        .replace(/\\t/g, '  ');\n      if (contextUp) {\n        contextUp += '\\n';\n      }\n      if (contextDown) {\n        contextDown = '\\n' + contextDown;\n      }\n    }\n\n    var numTabs = 0;\n    var annotation =\n      contextUp +\n      line.replace(/\\t/g, function (match, char) {\n        if (char < columnNum) {\n          numTabs += 1;\n        }\n\n        return '  ';\n      }) +\n      '\\n' +\n      new Array(columnNum + numTabs).join(' ') +\n      '^----' +\n      contextDown;\n\n    return [\n      lineNum,\n      columnNum,\n      (message + \" at line \" + lineNum + \" character \" + columnNum + \":\\n\" + annotation)\n    ];\n  },\n\n  getLinePos: function getLinePos(char) {\n    var this$1 = this;\n\n    var lineNum = 0;\n    var lineStart = 0;\n\n    while (char >= this.lineEnds[lineNum]) {\n      lineStart = this$1.lineEnds[lineNum];\n      lineNum += 1;\n    }\n\n    var columnNum = char - lineStart;\n    return [lineNum + 1, columnNum + 1, char]; // line/col should be one-based, not zero-based!\n  },\n\n  error: function error(message) {\n    var ref = this.getContextMessage(this.pos, message);\n    var lineNum = ref[0];\n    var columnNum = ref[1];\n    var msg = ref[2];\n\n    var error = new ParseError(msg);\n\n    error.line = lineNum;\n    error.character = columnNum;\n    error.shortMessage = message;\n\n    throw error;\n  },\n\n  matchString: function matchString(string) {\n    if (this.str.substr(this.pos, string.length) === string) {\n      this.pos += string.length;\n      return string;\n    }\n  },\n\n  matchPattern: function matchPattern(pattern) {\n    var match;\n\n    if ((match = pattern.exec(this.remaining()))) {\n      this.pos += match[0].length;\n      return match[1] || match[0];\n    }\n  },\n\n  sp: function sp() {\n    this.matchPattern(leadingWhitespace);\n  },\n\n  remaining: function remaining() {\n    return this.str.substring(this.pos);\n  },\n\n  nextChar: function nextChar() {\n    return this.str.charAt(this.pos);\n  },\n\n  warn: function warn(message) {\n    var msg = this.getContextMessage(this.pos, message)[2];\n\n    warnIfDebug(msg);\n  }\n};\n\nParser.extend = function(proto) {\n  var Parent = this;\n  var Child = function(str, options) {\n    Parser.call(this, str, options);\n  };\n\n  Child.prototype = create(Parent.prototype);\n\n  for (var key in proto) {\n    if (hasOwn(proto, key)) {\n      Child.prototype[key] = proto[key];\n    }\n  }\n\n  Child.extend = Parser.extend;\n  return Child;\n};\n\nvar TEXT = 1;\nvar INTERPOLATOR = 2;\nvar TRIPLE = 3;\nvar SECTION = 4;\nvar INVERTED = 5;\nvar CLOSING = 6;\nvar ELEMENT = 7;\nvar PARTIAL = 8;\nvar COMMENT = 9;\nvar DELIMCHANGE = 10;\nvar ANCHOR = 11;\nvar ATTRIBUTE = 13;\nvar CLOSING_TAG = 14;\nvar COMPONENT = 15;\nvar YIELDER = 16;\nvar INLINE_PARTIAL = 17;\nvar DOCTYPE = 18;\nvar ALIAS = 19;\n\nvar AWAIT = 55;\n\nvar NUMBER_LITERAL = 20;\nvar STRING_LITERAL = 21;\nvar ARRAY_LITERAL = 22;\nvar OBJECT_LITERAL = 23;\nvar BOOLEAN_LITERAL = 24;\nvar REGEXP_LITERAL = 25;\n\nvar GLOBAL = 26;\nvar KEY_VALUE_PAIR = 27;\n\nvar REFERENCE = 30;\nvar REFINEMENT = 31;\nvar MEMBER = 32;\nvar PREFIX_OPERATOR = 33;\nvar BRACKETED = 34;\nvar CONDITIONAL = 35;\nvar INFIX_OPERATOR = 36;\n\nvar INVOCATION = 40;\n\nvar SECTION_IF = 50;\nvar SECTION_UNLESS = 51;\nvar SECTION_EACH = 52;\nvar SECTION_WITH = 53;\nvar SECTION_IF_WITH = 54;\n\nvar ELSE = 60;\nvar ELSEIF = 61;\nvar THEN = 62;\nvar CATCH = 63;\n\nvar EVENT = 70;\nvar DECORATOR = 71;\nvar TRANSITION = 72;\nvar BINDING_FLAG = 73;\nvar DELEGATE_FLAG = 74;\n\nvar delimiterChangePattern = /^[^\\s=]+/;\nvar whitespacePattern = /^\\s+/;\n\nfunction readDelimiterChange(parser) {\n  if (!parser.matchString('=')) {\n    return null;\n  }\n\n  var start = parser.pos;\n\n  // allow whitespace before new opening delimiter\n  parser.sp();\n\n  var opening = parser.matchPattern(delimiterChangePattern);\n  if (!opening) {\n    parser.pos = start;\n    return null;\n  }\n\n  // allow whitespace (in fact, it's necessary...)\n  if (!parser.matchPattern(whitespacePattern)) {\n    return null;\n  }\n\n  var closing = parser.matchPattern(delimiterChangePattern);\n  if (!closing) {\n    parser.pos = start;\n    return null;\n  }\n\n  // allow whitespace before closing '='\n  parser.sp();\n\n  if (!parser.matchString('=')) {\n    parser.pos = start;\n    return null;\n  }\n\n  return [opening, closing];\n}\n\nvar regexpPattern = /^(\\/(?:[^\\n\\r\\u2028\\u2029/\\\\[]|\\\\.|\\[(?:[^\\n\\r\\u2028\\u2029\\]\\\\]|\\\\.)*])+\\/(?:([gimuy])(?![a-z]*\\2))*(?![a-zA-Z_$0-9]))/;\n\nfunction readNumberLiteral(parser) {\n  var result;\n\n  if ((result = parser.matchPattern(regexpPattern))) {\n    return {\n      t: REGEXP_LITERAL,\n      v: result\n    };\n  }\n\n  return null;\n}\n\nvar pattern = /[-/\\\\^$*+?.()|[\\]{}]/g;\n\nfunction escapeRegExp(str) {\n  return str.replace(pattern, '\\\\$&');\n}\n\nvar regExpCache = {};\n\nfunction getLowestIndex(haystack, needles) {\n  return haystack.search(\n    regExpCache[needles.join()] ||\n      (regExpCache[needles.join()] = new RegExp(needles.map(escapeRegExp).join('|')))\n  );\n}\n\n// https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\n//export const booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\nvar booleanAttributes = {\n  allowfullscreen: 1,\n  async: 1,\n  autofocus: 1,\n  autoplay: 1,\n  checked: 1,\n  compact: 1,\n  controls: 1,\n  declare: 1,\n  default: 1,\n  defaultchecked: 1,\n  defaultmuted: 1,\n  defaultselected: 1,\n  defer: 1,\n  disabled: 1,\n  enabled: 1,\n  formnovalidate: 1,\n  hidden: 1,\n  indeterminate: 1,\n  inert: 1,\n  ismap: 1,\n  itemscope: 1,\n  loop: 1,\n  multiple: 1,\n  muted: 1,\n  nohref: 1,\n  noresize: 1,\n  noshade: 1,\n  novalidate: 1,\n  nowrap: 1,\n  open: 1,\n  pauseonexit: 1,\n  readonly: 1,\n  required: 1,\n  reversed: 1,\n  scoped: 1,\n  seamless: 1,\n  selected: 1,\n  sortable: 1,\n  translate: 1,\n  truespeed: 1,\n  typemustmatch: 1,\n  visible: 1\n};\nvar voidElements = {\n  area: 1,\n  base: 1,\n  br: 1,\n  col: 1,\n  command: 1,\n  doctype: 1,\n  embed: 1,\n  hr: 1,\n  img: 1,\n  input: 1,\n  keygen: 1,\n  link: 1,\n  meta: 1,\n  param: 1,\n  source: 1,\n  track: 1,\n  wbr: 1\n};\n\nvar htmlEntities = {\n  quot: 34,\n  amp: 38,\n  apos: 39,\n  lt: 60,\n  gt: 62,\n  nbsp: 160,\n  iexcl: 161,\n  cent: 162,\n  pound: 163,\n  curren: 164,\n  yen: 165,\n  brvbar: 166,\n  sect: 167,\n  uml: 168,\n  copy: 169,\n  ordf: 170,\n  laquo: 171,\n  not: 172,\n  shy: 173,\n  reg: 174,\n  macr: 175,\n  deg: 176,\n  plusmn: 177,\n  sup2: 178,\n  sup3: 179,\n  acute: 180,\n  micro: 181,\n  para: 182,\n  middot: 183,\n  cedil: 184,\n  sup1: 185,\n  ordm: 186,\n  raquo: 187,\n  frac14: 188,\n  frac12: 189,\n  frac34: 190,\n  iquest: 191,\n  Agrave: 192,\n  Aacute: 193,\n  Acirc: 194,\n  Atilde: 195,\n  Auml: 196,\n  Aring: 197,\n  AElig: 198,\n  Ccedil: 199,\n  Egrave: 200,\n  Eacute: 201,\n  Ecirc: 202,\n  Euml: 203,\n  Igrave: 204,\n  Iacute: 205,\n  Icirc: 206,\n  Iuml: 207,\n  ETH: 208,\n  Ntilde: 209,\n  Ograve: 210,\n  Oacute: 211,\n  Ocirc: 212,\n  Otilde: 213,\n  Ouml: 214,\n  times: 215,\n  Oslash: 216,\n  Ugrave: 217,\n  Uacute: 218,\n  Ucirc: 219,\n  Uuml: 220,\n  Yacute: 221,\n  THORN: 222,\n  szlig: 223,\n  agrave: 224,\n  aacute: 225,\n  acirc: 226,\n  atilde: 227,\n  auml: 228,\n  aring: 229,\n  aelig: 230,\n  ccedil: 231,\n  egrave: 232,\n  eacute: 233,\n  ecirc: 234,\n  euml: 235,\n  igrave: 236,\n  iacute: 237,\n  icirc: 238,\n  iuml: 239,\n  eth: 240,\n  ntilde: 241,\n  ograve: 242,\n  oacute: 243,\n  ocirc: 244,\n  otilde: 245,\n  ouml: 246,\n  divide: 247,\n  oslash: 248,\n  ugrave: 249,\n  uacute: 250,\n  ucirc: 251,\n  uuml: 252,\n  yacute: 253,\n  thorn: 254,\n  yuml: 255,\n  OElig: 338,\n  oelig: 339,\n  Scaron: 352,\n  scaron: 353,\n  Yuml: 376,\n  fnof: 402,\n  circ: 710,\n  tilde: 732,\n  Alpha: 913,\n  Beta: 914,\n  Gamma: 915,\n  Delta: 916,\n  Epsilon: 917,\n  Zeta: 918,\n  Eta: 919,\n  Theta: 920,\n  Iota: 921,\n  Kappa: 922,\n  Lambda: 923,\n  Mu: 924,\n  Nu: 925,\n  Xi: 926,\n  Omicron: 927,\n  Pi: 928,\n  Rho: 929,\n  Sigma: 931,\n  Tau: 932,\n  Upsilon: 933,\n  Phi: 934,\n  Chi: 935,\n  Psi: 936,\n  Omega: 937,\n  alpha: 945,\n  beta: 946,\n  gamma: 947,\n  delta: 948,\n  epsilon: 949,\n  zeta: 950,\n  eta: 951,\n  theta: 952,\n  iota: 953,\n  kappa: 954,\n  lambda: 955,\n  mu: 956,\n  nu: 957,\n  xi: 958,\n  omicron: 959,\n  pi: 960,\n  rho: 961,\n  sigmaf: 962,\n  sigma: 963,\n  tau: 964,\n  upsilon: 965,\n  phi: 966,\n  chi: 967,\n  psi: 968,\n  omega: 969,\n  thetasym: 977,\n  upsih: 978,\n  piv: 982,\n  ensp: 8194,\n  emsp: 8195,\n  thinsp: 8201,\n  zwnj: 8204,\n  zwj: 8205,\n  lrm: 8206,\n  rlm: 8207,\n  ndash: 8211,\n  mdash: 8212,\n  lsquo: 8216,\n  rsquo: 8217,\n  sbquo: 8218,\n  ldquo: 8220,\n  rdquo: 8221,\n  bdquo: 8222,\n  dagger: 8224,\n  Dagger: 8225,\n  bull: 8226,\n  hellip: 8230,\n  permil: 8240,\n  prime: 8242,\n  Prime: 8243,\n  lsaquo: 8249,\n  rsaquo: 8250,\n  oline: 8254,\n  frasl: 8260,\n  euro: 8364,\n  image: 8465,\n  weierp: 8472,\n  real: 8476,\n  trade: 8482,\n  alefsym: 8501,\n  larr: 8592,\n  uarr: 8593,\n  rarr: 8594,\n  darr: 8595,\n  harr: 8596,\n  crarr: 8629,\n  lArr: 8656,\n  uArr: 8657,\n  rArr: 8658,\n  dArr: 8659,\n  hArr: 8660,\n  forall: 8704,\n  part: 8706,\n  exist: 8707,\n  empty: 8709,\n  nabla: 8711,\n  isin: 8712,\n  notin: 8713,\n  ni: 8715,\n  prod: 8719,\n  sum: 8721,\n  minus: 8722,\n  lowast: 8727,\n  radic: 8730,\n  prop: 8733,\n  infin: 8734,\n  ang: 8736,\n  and: 8743,\n  or: 8744,\n  cap: 8745,\n  cup: 8746,\n  int: 8747,\n  there4: 8756,\n  sim: 8764,\n  cong: 8773,\n  asymp: 8776,\n  ne: 8800,\n  equiv: 8801,\n  le: 8804,\n  ge: 8805,\n  sub: 8834,\n  sup: 8835,\n  nsub: 8836,\n  sube: 8838,\n  supe: 8839,\n  oplus: 8853,\n  otimes: 8855,\n  perp: 8869,\n  sdot: 8901,\n  lceil: 8968,\n  rceil: 8969,\n  lfloor: 8970,\n  rfloor: 8971,\n  lang: 9001,\n  rang: 9002,\n  loz: 9674,\n  spades: 9824,\n  clubs: 9827,\n  hearts: 9829,\n  diams: 9830\n};\nvar controlCharacters = [\n  8364,\n  129,\n  8218,\n  402,\n  8222,\n  8230,\n  8224,\n  8225,\n  710,\n  8240,\n  352,\n  8249,\n  338,\n  141,\n  381,\n  143,\n  144,\n  8216,\n  8217,\n  8220,\n  8221,\n  8226,\n  8211,\n  8212,\n  732,\n  8482,\n  353,\n  8250,\n  339,\n  157,\n  382,\n  376\n];\nvar entityPattern = new RegExp(\n  '&(#?(?:x[\\\\w\\\\d]+|\\\\d+|' + keys(htmlEntities).join('|') + '));?',\n  'g'\n);\nvar codePointSupport = isFunction(String.fromCodePoint);\nvar codeToChar = codePointSupport ? String.fromCodePoint : String.fromCharCode;\n\nfunction decodeCharacterReferences(html) {\n  return html.replace(entityPattern, function (match, entity) {\n    var code;\n\n    // Handle named entities\n    if (entity[0] !== '#') {\n      code = htmlEntities[entity];\n    } else if (entity[1] === 'x') {\n      code = parseInt(entity.substring(2), 16);\n    } else {\n      code = parseInt(entity.substring(1), 10);\n    }\n\n    if (!code) {\n      return match;\n    }\n\n    return codeToChar(validateCode(code));\n  });\n}\n\nvar lessThan = /</g;\nvar greaterThan = />/g;\nvar amp = /&/g;\nvar invalid = 65533;\n\nfunction escapeHtml(str) {\n  return str\n    .replace(amp, '&amp;')\n    .replace(lessThan, '&lt;')\n    .replace(greaterThan, '&gt;');\n}\n\n// some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n// code points with alternatives in some cases - since we're bypassing that mechanism, we need\n// to replace them ourselves\n//\n// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n/* istanbul ignore next */\nfunction validateCode(code) {\n  if (!code) {\n    return invalid;\n  }\n\n  // line feed becomes generic whitespace\n  if (code === 10) {\n    return 32;\n  }\n\n  // ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\n  if (code < 128) {\n    return code;\n  }\n\n  // code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\n  // to correct the mistake or we'll end up with missing  signs and so on\n  if (code <= 159) {\n    return controlCharacters[code - 128];\n  }\n\n  // basic multilingual plane\n  if (code < 55296) {\n    return code;\n  }\n\n  // UTF-16 surrogate halves\n  if (code <= 57343) {\n    return invalid;\n  }\n\n  // rest of the basic multilingual plane\n  if (code <= 65535) {\n    return code;\n  } else if (!codePointSupport) {\n    return invalid;\n  }\n\n  // supplementary multilingual plane 0x10000 - 0x1ffff\n  if (code >= 65536 && code <= 131071) {\n    return code;\n  }\n\n  // supplementary ideographic plane 0x20000 - 0x2ffff\n  if (code >= 131072 && code <= 196607) {\n    return code;\n  }\n\n  return invalid;\n}\n\nvar expectedExpression = 'Expected a JavaScript expression';\nvar expectedParen = 'Expected closing paren';\n\n// bulletproof number regex from https://gist.github.com/Rich-Harris/7544330\nvar numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\nfunction readNumberLiteral$1(parser) {\n  var result;\n\n  if ((result = parser.matchPattern(numberPattern))) {\n    return {\n      t: NUMBER_LITERAL,\n      v: result\n    };\n  }\n\n  return null;\n}\n\nfunction readBooleanLiteral(parser) {\n  var remaining = parser.remaining();\n\n  if (remaining.substr(0, 4) === 'true') {\n    parser.pos += 4;\n    return {\n      t: BOOLEAN_LITERAL,\n      v: 'true'\n    };\n  }\n\n  if (remaining.substr(0, 5) === 'false') {\n    parser.pos += 5;\n    return {\n      t: BOOLEAN_LITERAL,\n      v: 'false'\n    };\n  }\n\n  return null;\n}\n\n// Match one or more characters until: \", ', \\, or EOL/EOF.\n// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).\nvar stringMiddlePattern = /^(?=.)[^\"'\\\\]+?(?:(?!.)|(?=[\"'\\\\]))/;\n\n// Match one escape sequence, including the backslash.\nvar escapeSequencePattern = /^\\\\(?:[`'\"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\n// Match one ES5 line continuation (backslash + line terminator).\nvar lineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\n// Helper for defining getDoubleQuotedString and getSingleQuotedString.\nfunction makeQuotedStringMatcher(okQuote) {\n  return function(parser) {\n    var literal = '\"';\n    var done = false;\n    var next;\n\n    while (!done) {\n      next =\n        parser.matchPattern(stringMiddlePattern) ||\n        parser.matchPattern(escapeSequencePattern) ||\n        parser.matchString(okQuote);\n      if (next) {\n        if (next === \"\\\"\") {\n          literal += \"\\\\\\\"\";\n        } else if (next === \"\\\\'\") {\n          literal += \"'\";\n        } else {\n          literal += next;\n        }\n      } else {\n        next = parser.matchPattern(lineContinuationPattern);\n        if (next) {\n          // convert \\(newline-like) into a \\u escape, which is allowed in JSON\n          literal += '\\\\u' + ('000' + next.charCodeAt(1).toString(16)).slice(-4);\n        } else {\n          done = true;\n        }\n      }\n    }\n\n    literal += '\"';\n\n    // use JSON.parse to interpret escapes\n    return JSON.parse(literal);\n  };\n}\n\nvar singleMatcher = makeQuotedStringMatcher(\"\\\"\");\nvar doubleMatcher = makeQuotedStringMatcher(\"'\");\n\nfunction readStringLiteral(parser) {\n  var start = parser.pos;\n  var quote = parser.matchString(\"'\") || parser.matchString(\"\\\"\");\n\n  if (quote) {\n    var string = (quote === \"'\" ? singleMatcher : doubleMatcher)(parser);\n\n    if (!parser.matchString(quote)) {\n      parser.pos = start;\n      return null;\n    }\n\n    return {\n      t: STRING_LITERAL,\n      v: string\n    };\n  }\n\n  return null;\n}\n\n// Match one or more characters until: \", ', or \\\nvar stringMiddlePattern$1 = /^[^`\"\\\\\\$]+?(?:(?=[`\"\\\\\\$]))/;\n\nvar escapes = /[\\r\\n\\t\\b\\f]/g;\nfunction getString(literal) {\n  return JSON.parse((\"\\\"\" + (literal.replace(escapes, escapeChar)) + \"\\\"\"));\n}\n\nfunction escapeChar(c) {\n  switch (c) {\n    case '\\n':\n      return '\\\\n';\n    case '\\r':\n      return '\\\\r';\n    case '\\t':\n      return '\\\\t';\n    case '\\b':\n      return '\\\\b';\n    case '\\f':\n      return '\\\\f';\n  }\n}\n\nfunction readTemplateStringLiteral(parser) {\n  if (!parser.matchString('`')) { return null; }\n\n  var literal = '';\n  var done = false;\n  var next;\n  var parts = [];\n\n  while (!done) {\n    next =\n      parser.matchPattern(stringMiddlePattern$1) ||\n      parser.matchPattern(escapeSequencePattern) ||\n      parser.matchString('$') ||\n      parser.matchString('\"');\n    if (next) {\n      if (next === \"\\\"\") {\n        literal += \"\\\\\\\"\";\n      } else if (next === '\\\\`') {\n        literal += '`';\n      } else if (next === '$') {\n        if (parser.matchString('{')) {\n          parts.push({ t: STRING_LITERAL, v: getString(literal) });\n          literal = '';\n\n          parser.sp();\n          var expr = readExpression(parser);\n\n          if (!expr) { parser.error('Expected valid expression'); }\n\n          parts.push({ t: BRACKETED, x: expr });\n\n          parser.sp();\n          if (!parser.matchString('}'))\n            { parser.error(\"Expected closing '}' after interpolated expression\"); }\n        } else {\n          literal += '$';\n        }\n      } else {\n        literal += next;\n      }\n    } else {\n      next = parser.matchPattern(lineContinuationPattern);\n      if (next) {\n        // convert \\(newline-like) into a \\u escape, which is allowed in JSON\n        literal += '\\\\u' + ('000' + next.charCodeAt(1).toString(16)).slice(-4);\n      } else {\n        done = true;\n      }\n    }\n  }\n\n  if (literal.length) { parts.push({ t: STRING_LITERAL, v: getString(literal) }); }\n\n  if (!parser.matchString('`')) { parser.error(\"Expected closing '`'\"); }\n\n  if (!parts.length) {\n    // empty string literal\n    return { t: STRING_LITERAL, v: '' };\n  } else if (parts.length === 1) {\n    return parts[0];\n  } else {\n    var result = parts.pop();\n    var part;\n\n    while ((part = parts.pop())) {\n      result = {\n        t: INFIX_OPERATOR,\n        s: '+',\n        o: [part, result]\n      };\n    }\n\n    return {\n      t: BRACKETED,\n      x: result\n    };\n  }\n}\n\nvar name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;\nvar spreadPattern = /^\\s*\\.{3}/;\nvar legalReference = /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:\\.(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/;\nvar relaxedName = /^[a-zA-Z_$][-\\/a-zA-Z_$0-9]*(?:\\.(?:[a-zA-Z_$][-\\/a-zA-Z_$0-9]*))*/;\n\nvar identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n\n// http://mathiasbynens.be/notes/javascript-properties\n// can be any name, string literal, or number literal\nfunction readKey(parser) {\n  var token;\n\n  if ((token = readStringLiteral(parser))) {\n    return identifier.test(token.v) ? token.v : '\"' + token.v.replace(/\"/g, '\\\\\"') + '\"';\n  }\n\n  if ((token = readNumberLiteral$1(parser))) {\n    return token.v;\n  }\n\n  if ((token = parser.matchPattern(name))) {\n    return token;\n  }\n\n  return null;\n}\n\nfunction readKeyValuePair(parser) {\n  var spread;\n  var start = parser.pos;\n\n  // allow whitespace between '{' and key\n  parser.sp();\n\n  var refKey = parser.nextChar() !== \"'\" && parser.nextChar() !== '\"';\n  if (refKey) { spread = parser.matchPattern(spreadPattern); }\n\n  var key = spread ? readExpression(parser) : readKey(parser);\n  if (key === null) {\n    parser.pos = start;\n    return null;\n  }\n\n  // allow whitespace between key and ':'\n  parser.sp();\n\n  // es2015 shorthand property\n  if (refKey && (parser.nextChar() === ',' || parser.nextChar() === '}')) {\n    if (!spread && !name.test(key)) {\n      parser.error((\"Expected a valid reference, but found '\" + key + \"' instead.\"));\n    }\n\n    var pair = {\n      t: KEY_VALUE_PAIR,\n      k: key,\n      v: {\n        t: REFERENCE,\n        n: key\n      }\n    };\n\n    if (spread) {\n      pair.p = true;\n    }\n\n    return pair;\n  }\n\n  // next character must be ':'\n  if (!parser.matchString(':')) {\n    parser.pos = start;\n    return null;\n  }\n\n  // allow whitespace between ':' and value\n  parser.sp();\n\n  // next expression must be a, well... expression\n  var value = readExpression(parser);\n  if (value === null) {\n    parser.pos = start;\n    return null;\n  }\n\n  return {\n    t: KEY_VALUE_PAIR,\n    k: key,\n    v: value\n  };\n}\n\nfunction readKeyValuePairs(parser) {\n  var start = parser.pos;\n\n  var pair = readKeyValuePair(parser);\n  if (pair === null) {\n    return null;\n  }\n\n  var pairs = [pair];\n\n  if (parser.matchString(',')) {\n    var keyValuePairs = readKeyValuePairs(parser);\n\n    if (!keyValuePairs) {\n      parser.pos = start;\n      return null;\n    }\n\n    return pairs.concat(keyValuePairs);\n  }\n\n  return pairs;\n}\n\nfunction readObjectLiteral(parser) {\n  var start = parser.pos;\n\n  // allow whitespace\n  parser.sp();\n\n  if (!parser.matchString('{')) {\n    parser.pos = start;\n    return null;\n  }\n\n  var keyValuePairs = readKeyValuePairs(parser);\n\n  // allow whitespace between final value and '}'\n  parser.sp();\n\n  if (!parser.matchString('}')) {\n    parser.pos = start;\n    return null;\n  }\n\n  return {\n    t: OBJECT_LITERAL,\n    m: keyValuePairs\n  };\n}\n\nfunction readArrayLiteral(parser) {\n  var start = parser.pos;\n\n  // allow whitespace before '['\n  parser.sp();\n\n  if (!parser.matchString('[')) {\n    parser.pos = start;\n    return null;\n  }\n\n  var expressionList = readExpressionList(parser, true);\n\n  if (!parser.matchString(']')) {\n    parser.pos = start;\n    return null;\n  }\n\n  return {\n    t: ARRAY_LITERAL,\n    m: expressionList\n  };\n}\n\nfunction readLiteral(parser) {\n  return (\n    readNumberLiteral$1(parser) ||\n    readBooleanLiteral(parser) ||\n    readStringLiteral(parser) ||\n    readTemplateStringLiteral(parser) ||\n    readObjectLiteral(parser) ||\n    readArrayLiteral(parser) ||\n    readNumberLiteral(parser)\n  );\n}\n\n// if a reference is a browser global, we don't deference it later, so it needs special treatment\nvar globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null|Object|Number|String|Boolean)\\b/;\n\n// keywords are not valid references, with the exception of `this`\nvar keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\nvar prefixPattern = /^(?:\\@\\.|\\@|~\\/|(?:\\^\\^\\/(?:\\^\\^\\/)*(?:\\.\\.\\/)*)|(?:\\.\\.\\/)+|\\.\\/(?:\\.\\.\\/)*|\\.)/;\nvar specials = /^(key|index|keypath|rootpath|this|global|shared|context|event|node|local|style|helpers|last|macro)/;\n\nfunction readReference(parser) {\n  var prefix, name$$1, global, reference, lastDotIndex;\n\n  var startPos = parser.pos;\n\n  prefix = parser.matchPattern(prefixPattern) || '';\n  name$$1 =\n    (!prefix && parser.relaxedNames && parser.matchPattern(relaxedName)) ||\n    parser.matchPattern(legalReference);\n  var actual = prefix.length + ((name$$1 && name$$1.length) || 0);\n\n  if (prefix === '@.') {\n    prefix = '@';\n    if (name$$1) { name$$1 = 'this.' + name$$1; }\n    else { name$$1 = 'this'; }\n  }\n\n  if (!name$$1 && prefix) {\n    name$$1 = prefix;\n    prefix = '';\n  }\n\n  if (!name$$1) {\n    return null;\n  }\n\n  if (prefix === '@') {\n    if (!specials.test(name$$1)) {\n      parser.error((\"Unrecognized special reference @\" + name$$1));\n    } else if ((!name$$1.indexOf('event') || !name$$1.indexOf('node')) && !parser.inEvent) {\n      parser.error(\"@event and @node are only valid references within an event directive\");\n    } else if (!name$$1.indexOf('context')) {\n      parser.pos = parser.pos - (name$$1.length - 7);\n      return {\n        t: BRACKETED,\n        x: {\n          t: REFERENCE,\n          n: '@context'\n        }\n      };\n    }\n  }\n\n  // bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)\n  if (!prefix && !parser.relaxedNames && keywords.test(name$$1)) {\n    parser.pos = startPos;\n    return null;\n  }\n\n  // if this is a browser global, stop here\n  if (!prefix && globals.test(name$$1)) {\n    global = globals.exec(name$$1)[0];\n    parser.pos = startPos + global.length;\n\n    return {\n      t: GLOBAL,\n      v: global\n    };\n  }\n\n  reference = (prefix || '') + normalise(name$$1);\n\n  if (parser.matchString('(')) {\n    // if this is a method invocation (as opposed to a function) we need\n    // to strip the method name from the reference combo, else the context\n    // will be wrong\n    // but only if the reference was actually a member and not a refinement\n    lastDotIndex = reference.lastIndexOf('.');\n    if (lastDotIndex !== -1 && name$$1[name$$1.length - 1] !== ']') {\n      if (lastDotIndex === 0) {\n        reference = '.';\n        parser.pos = startPos;\n      } else {\n        var refLength = reference.length;\n        reference = reference.substr(0, lastDotIndex);\n        parser.pos = startPos + (actual - (refLength - lastDotIndex));\n      }\n    } else {\n      parser.pos -= 1;\n    }\n  }\n\n  return {\n    t: REFERENCE,\n    n: reference.replace(/^this\\./, './').replace(/^this$/, '.')\n  };\n}\n\nfunction readBracketedExpression(parser) {\n  if (!parser.matchString('(')) { return null; }\n\n  parser.sp();\n\n  var expr = readExpression(parser);\n\n  if (!expr) { parser.error(expectedExpression); }\n\n  parser.sp();\n\n  if (!parser.matchString(')')) { parser.error(expectedParen); }\n\n  return {\n    t: BRACKETED,\n    x: expr\n  };\n}\n\nfunction readPrimary(parser) {\n  return readLiteral(parser) || readReference(parser) || readBracketedExpression(parser);\n}\n\nfunction readRefinement(parser) {\n  // some things call for strict refinement (partial names), meaning no space between reference and refinement\n  if (!parser.strictRefinement) {\n    parser.sp();\n  }\n\n  // \".\" name\n  if (parser.matchString('.')) {\n    parser.sp();\n\n    var name$$1 = parser.matchPattern(name);\n    if (name$$1) {\n      return {\n        t: REFINEMENT,\n        n: name$$1\n      };\n    }\n\n    parser.error('Expected a property name');\n  }\n\n  // \"[\" expression \"]\"\n  if (parser.matchString('[')) {\n    parser.sp();\n\n    var expr = readExpression(parser);\n    if (!expr) { parser.error(expectedExpression); }\n\n    parser.sp();\n\n    if (!parser.matchString(']')) { parser.error(\"Expected ']'\"); }\n\n    return {\n      t: REFINEMENT,\n      x: expr\n    };\n  }\n\n  return null;\n}\n\nfunction readMemberOrInvocation(parser) {\n  var expression = readPrimary(parser);\n\n  if (!expression) { return null; }\n\n  while (expression) {\n    var refinement = readRefinement(parser);\n    if (refinement) {\n      expression = {\n        t: MEMBER,\n        x: expression,\n        r: refinement\n      };\n    } else if (parser.matchString('(')) {\n      parser.sp();\n      var expressionList = readExpressionList(parser, true);\n\n      parser.sp();\n\n      if (!parser.matchString(')')) {\n        parser.error(expectedParen);\n      }\n\n      expression = {\n        t: INVOCATION,\n        x: expression\n      };\n\n      if (expressionList) { expression.o = expressionList; }\n    } else {\n      break;\n    }\n  }\n\n  return expression;\n}\n\nvar readTypeOf;\n\nvar makePrefixSequenceMatcher = function(symbol, fallthrough) {\n  return function(parser) {\n    var expression;\n\n    if ((expression = fallthrough(parser))) {\n      return expression;\n    }\n\n    if (!parser.matchString(symbol)) {\n      return null;\n    }\n\n    parser.sp();\n\n    expression = readExpression(parser);\n    if (!expression) {\n      parser.error(expectedExpression);\n    }\n\n    return {\n      s: symbol,\n      o: expression,\n      t: PREFIX_OPERATOR\n    };\n  };\n};\n\n// create all prefix sequence matchers, return readTypeOf\n(function() {\n  var i, len, matcher, fallthrough;\n\n  var prefixOperators = '! ~ + - typeof'.split(' ');\n\n  fallthrough = readMemberOrInvocation;\n  for (i = 0, len = prefixOperators.length; i < len; i += 1) {\n    matcher = makePrefixSequenceMatcher(prefixOperators[i], fallthrough);\n    fallthrough = matcher;\n  }\n\n  // typeof operator is higher precedence than multiplication, so provides the\n  // fallthrough for the multiplication sequence matcher we're about to create\n  // (we're skipping void and delete)\n  readTypeOf = fallthrough;\n})();\n\nvar readTypeof = readTypeOf;\n\nvar readLogicalOr;\n\nvar makeInfixSequenceMatcher = function(symbol, fallthrough) {\n  return function(parser) {\n    // > and / have to be quoted\n    if (parser.inUnquotedAttribute && (symbol === '>' || symbol === '/'))\n      { return fallthrough(parser); }\n\n    var start, left, right;\n\n    left = fallthrough(parser);\n    if (!left) {\n      return null;\n    }\n\n    // Loop to handle left-recursion in a case like `a * b * c` and produce\n    // left association, i.e. `(a * b) * c`.  The matcher can't call itself\n    // to parse `left` because that would be infinite regress.\n    while (true) {\n      start = parser.pos;\n\n      parser.sp();\n\n      if (!parser.matchString(symbol)) {\n        parser.pos = start;\n        return left;\n      }\n\n      // special case - in operator must not be followed by [a-zA-Z_$0-9]\n      if (symbol === 'in' && /[a-zA-Z_$0-9]/.test(parser.remaining().charAt(0))) {\n        parser.pos = start;\n        return left;\n      }\n\n      parser.sp();\n\n      // right operand must also consist of only higher-precedence operators\n      right = fallthrough(parser);\n      if (!right) {\n        parser.pos = start;\n        return left;\n      }\n\n      left = {\n        t: INFIX_OPERATOR,\n        s: symbol,\n        o: [left, right]\n      };\n\n      // Loop back around.  If we don't see another occurrence of the symbol,\n      // we'll return left.\n    }\n  };\n};\n\n// create all infix sequence matchers, and return readLogicalOr\n(function() {\n  var i, len, matcher, fallthrough;\n\n  // All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n  // Each sequence matcher will initially fall through to its higher precedence\n  // neighbour, and only attempt to match if one of the higher precedence operators\n  // (or, ultimately, a literal, reference, or bracketed expression) already matched\n  var infixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split(\n    ' '\n  );\n\n  // A typeof operator is higher precedence than multiplication\n  fallthrough = readTypeof;\n  for (i = 0, len = infixOperators.length; i < len; i += 1) {\n    matcher = makeInfixSequenceMatcher(infixOperators[i], fallthrough);\n    fallthrough = matcher;\n  }\n\n  // Logical OR is the fallthrough for the conditional matcher\n  readLogicalOr = fallthrough;\n})();\n\nvar readLogicalOr$1 = readLogicalOr;\n\n// The conditional operator is the lowest precedence operator, so we start here\nfunction getConditional(parser) {\n  var expression = readLogicalOr$1(parser);\n  if (!expression) {\n    return null;\n  }\n\n  var start = parser.pos;\n\n  parser.sp();\n\n  if (!parser.matchString('?')) {\n    parser.pos = start;\n    return expression;\n  }\n\n  parser.sp();\n\n  var ifTrue = readExpression(parser);\n  if (!ifTrue) {\n    parser.error(expectedExpression);\n  }\n\n  parser.sp();\n\n  if (!parser.matchString(':')) {\n    parser.error('Expected \":\"');\n  }\n\n  parser.sp();\n\n  var ifFalse = readExpression(parser);\n  if (!ifFalse) {\n    parser.error(expectedExpression);\n  }\n\n  return {\n    t: CONDITIONAL,\n    o: [expression, ifTrue, ifFalse]\n  };\n}\n\nfunction readExpression(parser) {\n  // if eval is false, no expressions\n  if (parser.allowExpressions === false) {\n    var ref = readReference(parser);\n    parser.sp();\n    return ref;\n  }\n\n  // The conditional operator is the lowest precedence operator (except yield,\n  // assignment operators, and commas, none of which are supported), so we\n  // start there. If it doesn't match, it 'falls through' to progressively\n  // higher precedence operators, until it eventually matches (or fails to\n  // match) a 'primary' - a literal or a reference. This way, the abstract syntax\n  // tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n  return getConditional(parser);\n}\n\nfunction readExpressionList(parser, spread) {\n  var isSpread;\n  var expressions = [];\n\n  var pos = parser.pos;\n\n  do {\n    parser.sp();\n\n    if (spread) {\n      isSpread = parser.matchPattern(spreadPattern);\n    }\n\n    var expr = readExpression(parser);\n\n    if (expr === null && expressions.length) {\n      parser.error(expectedExpression);\n    } else if (expr === null) {\n      parser.pos = pos;\n      return null;\n    }\n\n    if (isSpread) {\n      expr.p = true;\n    }\n\n    expressions.push(expr);\n\n    parser.sp();\n  } while (parser.matchString(','));\n\n  return expressions;\n}\n\nfunction readExpressionOrReference(parser, expectedFollowers) {\n  var start = parser.pos;\n  var expression = readExpression(parser);\n\n  if (!expression) {\n    // valid reference but invalid expression e.g. `{{new}}`?\n    var ref = parser.matchPattern(/^(\\w+)/);\n    if (ref) {\n      return {\n        t: REFERENCE,\n        n: ref\n      };\n    }\n\n    return null;\n  }\n\n  for (var i = 0; i < expectedFollowers.length; i += 1) {\n    if (parser.remaining().substr(0, expectedFollowers[i].length) === expectedFollowers[i]) {\n      return expression;\n    }\n  }\n\n  parser.pos = start;\n  return readReference(parser);\n}\n\nfunction flattenExpression(expression) {\n  var refs;\n  var count = 0;\n\n  extractRefs(expression, (refs = []));\n  var stringified = stringify(expression);\n\n  return {\n    r: refs,\n    s: getVars(stringified)\n  };\n\n  function getVars(expr) {\n    var vars = [];\n    for (var i = count - 1; i >= 0; i--) {\n      vars.push((\"x$\" + i));\n    }\n    return vars.length ? (\"(function(){var \" + (vars.join(',')) + \";return(\" + expr + \");})()\") : expr;\n  }\n\n  function stringify(node) {\n    if (isString(node)) {\n      return node;\n    }\n\n    switch (node.t) {\n      case BOOLEAN_LITERAL:\n      case GLOBAL:\n      case NUMBER_LITERAL:\n      case REGEXP_LITERAL:\n        return node.v;\n\n      case STRING_LITERAL:\n        return JSON.stringify(String(node.v));\n\n      case ARRAY_LITERAL:\n        if (node.m && hasSpread(node.m)) {\n          return (\"[].concat(\" + (makeSpread(node.m, '[', ']', stringify)) + \")\");\n        } else {\n          return '[' + (node.m ? node.m.map(stringify).join(',') : '') + ']';\n        }\n\n      case OBJECT_LITERAL:\n        if (node.m && hasSpread(node.m)) {\n          return (\"Object.assign({},\" + (makeSpread(node.m, '{', '}', stringifyPair)) + \")\");\n        } else {\n          return '{' + (node.m ? node.m.map(function (n) { return ((n.k) + \":\" + (stringify(n.v))); }).join(',') : '') + '}';\n        }\n\n      case PREFIX_OPERATOR:\n        return (node.s === 'typeof' ? 'typeof ' : node.s) + stringify(node.o);\n\n      case INFIX_OPERATOR:\n        return (\n          stringify(node.o[0]) +\n          (node.s.substr(0, 2) === 'in' ? ' ' + node.s + ' ' : node.s) +\n          stringify(node.o[1])\n        );\n\n      case INVOCATION:\n        if (node.o && hasSpread(node.o)) {\n          var id = count++;\n          return (\"(x$\" + id + \"=\" + (stringify(node.x)) + \").apply(x$\" + id + \",\" + (stringify({\n            t: ARRAY_LITERAL,\n            m: node.o\n          })) + \")\");\n        } else {\n          return stringify(node.x) + '(' + (node.o ? node.o.map(stringify).join(',') : '') + ')';\n        }\n\n      case BRACKETED:\n        return '(' + stringify(node.x) + ')';\n\n      case MEMBER:\n        return stringify(node.x) + stringify(node.r);\n\n      case REFINEMENT:\n        return node.n ? '.' + node.n : '[' + stringify(node.x) + ']';\n\n      case CONDITIONAL:\n        return stringify(node.o[0]) + '?' + stringify(node.o[1]) + ':' + stringify(node.o[2]);\n\n      case REFERENCE:\n        return '_' + refs.indexOf(node.n);\n\n      default:\n        throw new Error('Expected legal JavaScript');\n    }\n  }\n\n  function stringifyPair(node) {\n    return node.p ? stringify(node.k) : ((node.k) + \":\" + (stringify(node.v)));\n  }\n\n  function makeSpread(list, open, close, fn) {\n    var out = list.reduce(\n      function (a, c) {\n        if (c.p) {\n          a.str += \"\" + (a.open ? close + ',' : a.str.length ? ',' : '') + (fn(c));\n        } else {\n          a.str += \"\" + (!a.str.length ? open : !a.open ? ',' + open : ',') + (fn(c));\n        }\n        a.open = !c.p;\n        return a;\n      },\n      { open: false, str: '' }\n    );\n    if (out.open) { out.str += close; }\n    return out.str;\n  }\n}\n\nfunction hasSpread(list) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i].p) { return true; }\n  }\n\n  return false;\n}\n\n// TODO maybe refactor this?\nfunction extractRefs(node, refs) {\n  if (node.t === REFERENCE && isString(node.n)) {\n    if (!~refs.indexOf(node.n)) {\n      refs.unshift(node.n);\n    }\n  }\n\n  var list = node.o || node.m;\n  if (list) {\n    if (isObject(list)) {\n      extractRefs(list, refs);\n    } else {\n      var i = list.length;\n      while (i--) {\n        extractRefs(list[i], refs);\n      }\n    }\n  }\n\n  if (node.k && node.t === KEY_VALUE_PAIR && !isString(node.k)) {\n    extractRefs(node.k, refs);\n  }\n\n  if (node.x) {\n    extractRefs(node.x, refs);\n  }\n\n  if (node.r) {\n    extractRefs(node.r, refs);\n  }\n\n  if (node.v) {\n    extractRefs(node.v, refs);\n  }\n}\n\nfunction refineExpression(expression, mustache) {\n  var referenceExpression;\n\n  if (expression) {\n    while (expression.t === BRACKETED && expression.x) {\n      expression = expression.x;\n    }\n\n    if (expression.t === REFERENCE) {\n      var n = expression.n;\n      if (!~n.indexOf('@context')) {\n        mustache.r = expression.n;\n      } else {\n        mustache.x = flattenExpression(expression);\n      }\n    } else {\n      if ((referenceExpression = getReferenceExpression(expression))) {\n        mustache.rx = referenceExpression;\n      } else {\n        mustache.x = flattenExpression(expression);\n      }\n    }\n\n    return mustache;\n  }\n}\n\n// TODO refactor this! it's bewildering\nfunction getReferenceExpression(expression) {\n  var members = [];\n  var refinement;\n\n  while (expression.t === MEMBER && expression.r.t === REFINEMENT) {\n    refinement = expression.r;\n\n    if (refinement.x) {\n      if (refinement.x.t === REFERENCE) {\n        members.unshift(refinement.x);\n      } else {\n        members.unshift(flattenExpression(refinement.x));\n      }\n    } else {\n      members.unshift(refinement.n);\n    }\n\n    expression = expression.x;\n  }\n\n  if (expression.t !== REFERENCE) {\n    return null;\n  }\n\n  return {\n    r: expression.n,\n    m: members\n  };\n}\n\nvar attributeNamePattern = /^[^\\s\"'>\\/=(]+/;\nvar onPattern = /^on/;\nvar eventPattern = /^on-([a-zA-Z\\*\\.$_]((?:[a-zA-Z\\*\\.$_0-9\\-]|\\\\-)+))$/;\nvar reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|complete|unrender|detach|insert|destruct|attachchild|detachchild)$/;\nvar decoratorPattern = /^as-([a-z-A-Z][-a-zA-Z_0-9]*)$/;\nvar transitionPattern = /^([a-zA-Z](?:(?!-in-out)[-a-zA-Z_0-9])*)-(in|out|in-out)$/;\nvar boundPattern = /^((bind|class)-(([-a-zA-Z0-9_])+))$/;\nvar directives = {\n  lazy: { t: BINDING_FLAG, v: 'l' },\n  twoway: { t: BINDING_FLAG, v: 't' },\n  'no-delegation': { t: DELEGATE_FLAG }\n};\nvar unquotedAttributeValueTextPattern = /^[^\\s\"'=<>\\/`]+/;\nvar proxyEvent = /^[^\\s\"'=<>@\\[\\]()]*/;\nvar whitespace = /^\\s+/;\n\nvar slashes = /\\\\/g;\nfunction splitEvent(str) {\n  var result = [];\n  var s = 0;\n\n  for (var i = 0; i < str.length; i++) {\n    if (str[i] === '-' && str[i - 1] !== '\\\\') {\n      result.push(str.substring(s, i).replace(slashes, ''));\n      s = i + 1;\n    }\n  }\n\n  result.push(str.substring(s).replace(slashes, ''));\n\n  return result;\n}\n\nfunction readAttribute(parser) {\n  var name, i, nearest, idx;\n\n  parser.sp();\n\n  name = parser.matchPattern(attributeNamePattern);\n  if (!name) {\n    return null;\n  }\n\n  // check for accidental delimiter consumption e.g. <tag bool{{>attrs}} />\n  nearest = name.length;\n  for (i = 0; i < parser.tags.length; i++) {\n    if (~(idx = name.indexOf(parser.tags[i].open))) {\n      if (idx < nearest) { nearest = idx; }\n    }\n  }\n  if (nearest < name.length) {\n    parser.pos -= name.length - nearest;\n    name = name.substr(0, nearest);\n    if (!name) { return null; }\n  }\n\n  return { n: name };\n}\n\nfunction readAttributeValue(parser) {\n  var start = parser.pos;\n\n  // next character must be `=`, `/`, `>` or whitespace\n  if (!/[=\\/>\\s]/.test(parser.nextChar())) {\n    parser.error('Expected `=`, `/`, `>` or whitespace');\n  }\n\n  parser.sp();\n\n  if (!parser.matchString('=')) {\n    parser.pos = start;\n    return null;\n  }\n\n  parser.sp();\n\n  var valueStart = parser.pos;\n  var startDepth = parser.sectionDepth;\n\n  var value =\n    readQuotedAttributeValue(parser, \"'\") ||\n    readQuotedAttributeValue(parser, \"\\\"\") ||\n    readUnquotedAttributeValue(parser);\n\n  if (value === null) {\n    parser.error('Expected valid attribute value');\n  }\n\n  if (parser.sectionDepth !== startDepth) {\n    parser.pos = valueStart;\n    parser.error(\n      'An attribute value must contain as many opening section tags as closing section tags'\n    );\n  }\n\n  if (!value.length) {\n    return '';\n  }\n\n  if (value.length === 1 && isString(value[0])) {\n    return decodeCharacterReferences(value[0]);\n  }\n\n  return value;\n}\n\nfunction readUnquotedAttributeValueToken(parser) {\n  var text, index;\n\n  var start = parser.pos;\n\n  text = parser.matchPattern(unquotedAttributeValueTextPattern);\n\n  if (!text) {\n    return null;\n  }\n\n  var haystack = text;\n  var needles = parser.tags.map(function (t) { return t.open; }); // TODO refactor... we do this in readText.js as well\n\n  if ((index = getLowestIndex(haystack, needles)) !== -1) {\n    text = text.substr(0, index);\n    parser.pos = start + text.length;\n  }\n\n  return text;\n}\n\nfunction readUnquotedAttributeValue(parser) {\n  parser.inAttribute = true;\n\n  var tokens = [];\n\n  var token = readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  while (token) {\n    tokens.push(token);\n    token = readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  }\n\n  if (!tokens.length) {\n    return null;\n  }\n\n  parser.inAttribute = false;\n  return tokens;\n}\n\nfunction readQuotedAttributeValue(parser, quoteMark) {\n  var start = parser.pos;\n\n  if (!parser.matchString(quoteMark)) {\n    return null;\n  }\n\n  parser.inAttribute = quoteMark;\n\n  var tokens = [];\n\n  var token = readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  while (token !== null) {\n    tokens.push(token);\n    token = readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  }\n\n  if (!parser.matchString(quoteMark)) {\n    parser.pos = start;\n    return null;\n  }\n\n  parser.inAttribute = false;\n\n  return tokens;\n}\n\nfunction readQuotedStringToken(parser, quoteMark) {\n  var haystack = parser.remaining();\n\n  var needles = parser.tags.map(function (t) { return t.open; }); // TODO refactor... we do this in readText.js as well\n  needles.push(quoteMark);\n\n  var index = getLowestIndex(haystack, needles);\n\n  if (index === -1) {\n    parser.error('Quoted attribute value must have a closing quote');\n  }\n\n  if (!index) {\n    return null;\n  }\n\n  parser.pos += index;\n  return haystack.substr(0, index);\n}\n\nfunction readAttributeOrDirective(parser) {\n  var match, directive;\n\n  var attribute = readAttribute(parser, false);\n\n  if (!attribute) { return null; }\n\n  // lazy, twoway\n  if ((directive = directives[attribute.n])) {\n    attribute.t = directive.t;\n    if (directive.v) { attribute.v = directive.v; }\n    delete attribute.n; // no name necessary\n    parser.sp();\n    if (parser.nextChar() === '=') { attribute.f = readAttributeValue(parser); }\n  } else if ((match = decoratorPattern.exec(attribute.n))) {\n    // decorators\n    attribute.n = match[1];\n    attribute.t = DECORATOR;\n    readArguments(parser, attribute);\n  } else if ((match = transitionPattern.exec(attribute.n))) {\n    // transitions\n    attribute.n = match[1];\n    attribute.t = TRANSITION;\n    readArguments(parser, attribute);\n    attribute.v = match[2] === 'in-out' ? 't0' : match[2] === 'in' ? 't1' : 't2';\n  } else if ((match = eventPattern.exec(attribute.n))) {\n    // on-click etc\n    attribute.n = splitEvent(match[1]);\n    attribute.t = EVENT;\n\n    if (parser.matchString('(')) {\n      attribute.a = flattenExpression({\n        t: ARRAY_LITERAL,\n        m: readExpressionList(parser)\n      });\n      if (!parser.matchString(')')) { parser.error(\"Expected closing ')'\"); }\n    }\n\n    parser.inEvent = true;\n\n    // check for a proxy event\n    if (!readProxyEvent(parser, attribute)) {\n      // otherwise, it's an expression\n      readArguments(parser, attribute, true);\n    } else if (reservedEventNames.test(attribute.f)) {\n      parser.pos -= attribute.f.length;\n      parser.error(\n        'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, complete, detach, insert, destruct, attachchild, detachchild)'\n      );\n    }\n\n    parser.inEvent = false;\n  } else if ((match = boundPattern.exec(attribute.n))) {\n    // bound directives\n    var bind = match[2] === 'bind';\n    attribute.n = bind ? match[3] : match[1];\n    attribute.t = ATTRIBUTE;\n    readArguments(parser, attribute, false, true);\n\n    if (!attribute.f && bind) {\n      attribute.f = [{ t: INTERPOLATOR, r: match[3] }];\n    }\n  } else {\n    parser.sp();\n    var value = parser.nextChar() === '=' ? readAttributeValue(parser) : null;\n    attribute.f = value != null ? value : attribute.f;\n\n    if (parser.sanitizeEventAttributes && onPattern.test(attribute.n)) {\n      return { exclude: true };\n    } else {\n      attribute.f = attribute.f || (attribute.f === '' ? '' : 0);\n      attribute.t = ATTRIBUTE;\n    }\n  }\n\n  return attribute;\n}\n\nfunction readProxyEvent(parser, attribute) {\n  var start = parser.pos;\n  if (!parser.matchString('=')) { parser.error(\"Missing required directive arguments\"); }\n\n  var quote = parser.matchString(\"'\") || parser.matchString(\"\\\"\");\n  parser.sp();\n  var proxy = parser.matchPattern(proxyEvent);\n\n  if (proxy !== undefined) {\n    if (quote) {\n      parser.sp();\n      if (!parser.matchString(quote)) { parser.pos = start; }\n      else { return (attribute.f = proxy) || true; }\n    } else if (!parser.matchPattern(whitespace)) {\n      parser.pos = start;\n    } else {\n      return (attribute.f = proxy) || true;\n    }\n  } else {\n    parser.pos = start;\n  }\n}\n\nfunction readArguments(parser, attribute, required, single) {\n  if ( required === void 0 ) required = false;\n  if ( single === void 0 ) single = false;\n\n  parser.sp();\n  if (!parser.matchString('=')) {\n    if (required) { parser.error(\"Missing required directive arguments\"); }\n    return;\n  }\n  parser.sp();\n\n  var quote = parser.matchString('\"') || parser.matchString(\"'\");\n  var spread = parser.spreadArgs;\n  parser.spreadArgs = true;\n  parser.inUnquotedAttribute = !quote;\n  var expr = single\n    ? readExpressionOrReference(parser, [quote || ' ', '/', '>'])\n    : { m: readExpressionList(parser), t: ARRAY_LITERAL };\n  parser.inUnquotedAttribute = false;\n  parser.spreadArgs = spread;\n\n  if (quote) {\n    parser.sp();\n    if (parser.matchString(quote) !== quote) { parser.error((\"Expected matching quote '\" + quote + \"'\")); }\n  }\n\n  if (single) {\n    var interpolator = { t: INTERPOLATOR };\n    refineExpression(expr, interpolator);\n    attribute.f = [interpolator];\n  } else {\n    attribute.f = flattenExpression(expr);\n  }\n}\n\nvar delimiterChangeToken = { t: DELIMCHANGE, exclude: true };\n\nfunction readMustache(parser) {\n  var mustache, i;\n\n  // If we're inside a <script> or <style> tag, and we're not\n  // interpolating, bug out\n  if (parser.interpolate[parser.inside] === false) {\n    return null;\n  }\n\n  for (i = 0; i < parser.tags.length; i += 1) {\n    if ((mustache = readMustacheOfType(parser, parser.tags[i]))) {\n      return mustache;\n    }\n  }\n\n  if (parser.inTag && !parser.inAttribute) {\n    mustache = readAttributeOrDirective(parser);\n    if (mustache) {\n      parser.sp();\n      return mustache;\n    }\n  }\n}\n\nfunction readMustacheOfType(parser, tag) {\n  var mustache, reader, i;\n\n  var start = parser.pos;\n\n  if (parser.matchString('\\\\' + tag.open)) {\n    if (start === 0 || parser.str[start - 1] !== '\\\\') {\n      return tag.open;\n    }\n  } else if (!parser.matchString(tag.open)) {\n    return null;\n  }\n\n  // delimiter change?\n  if ((mustache = readDelimiterChange(parser))) {\n    // find closing delimiter or abort...\n    if (!parser.matchString(tag.close)) {\n      return null;\n    }\n\n    // ...then make the switch\n    tag.open = mustache[0];\n    tag.close = mustache[1];\n    parser.sortMustacheTags();\n\n    return delimiterChangeToken;\n  }\n\n  parser.sp();\n\n  // illegal section closer\n  if (parser.matchString('/')) {\n    parser.pos -= 1;\n    var rewind = parser.pos;\n    if (!readNumberLiteral(parser)) {\n      parser.pos = rewind - tag.close.length;\n      if (parser.inAttribute) {\n        parser.pos = start;\n        return null;\n      } else {\n        parser.error(\"Attempted to close a section that wasn't open\");\n      }\n    } else {\n      parser.pos = rewind;\n    }\n  }\n\n  for (i = 0; i < tag.readers.length; i += 1) {\n    reader = tag.readers[i];\n\n    if ((mustache = reader(parser, tag))) {\n      if (tag.isStatic) {\n        mustache.s = 1;\n      }\n\n      if (parser.includeLinePositions) {\n        mustache.q = parser.getLinePos(start);\n      }\n\n      return mustache;\n    }\n  }\n\n  parser.pos = start;\n  return null;\n}\n\nfunction readTriple(parser, tag) {\n  var expression = readExpression(parser);\n\n  if (!expression) {\n    return null;\n  }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n  }\n\n  var triple = { t: TRIPLE };\n  refineExpression(expression, triple); // TODO handle this differently - it's mysterious\n\n  return triple;\n}\n\nfunction readUnescaped(parser, tag) {\n  if (!parser.matchString('&')) {\n    return null;\n  }\n\n  parser.sp();\n\n  var expression = readExpression(parser);\n\n  if (!expression) {\n    return null;\n  }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n  }\n\n  var triple = { t: TRIPLE };\n  refineExpression(expression, triple); // TODO handle this differently - it's mysterious\n\n  return triple;\n}\n\nvar legalAlias = /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/;\nvar asRE = /^as/i;\n\nfunction readAliases(parser) {\n  var aliases = [];\n  var alias;\n  var start = parser.pos;\n\n  parser.sp();\n\n  alias = readAlias(parser);\n\n  if (alias) {\n    alias.x = refineExpression(alias.x, {});\n    aliases.push(alias);\n\n    parser.sp();\n\n    while (parser.matchString(',')) {\n      alias = readAlias(parser);\n\n      if (!alias) {\n        parser.error('Expected another alias.');\n      }\n\n      alias.x = refineExpression(alias.x, {});\n      aliases.push(alias);\n\n      parser.sp();\n    }\n\n    return aliases;\n  }\n\n  parser.pos = start;\n  return null;\n}\n\nfunction readAlias(parser) {\n  var start = parser.pos;\n\n  parser.sp();\n\n  var expr = readExpression(parser, []);\n\n  if (!expr) {\n    parser.pos = start;\n    return null;\n  }\n\n  parser.sp();\n  parser.matchPattern(asRE);\n  parser.sp();\n\n  var alias = parser.matchPattern(legalAlias);\n\n  if (!alias) {\n    parser.pos = start;\n    return null;\n  }\n\n  return { n: alias, x: expr };\n}\n\nfunction readPartial(parser, tag) {\n  var type = parser.matchString('>') || parser.matchString('yield');\n  var partial = { t: type === '>' ? PARTIAL : YIELDER };\n  var aliases;\n\n  if (!type) { return null; }\n\n  parser.sp();\n\n  if (type === '>' || !(aliases = parser.matchString('with'))) {\n    // Partial names can include hyphens, so we can't use readExpression\n    // blindly. Instead, we use the `relaxedNames` flag to indicate that\n    // `foo-bar` should be read as a single name, rather than 'subtract\n    // bar from foo'\n    parser.relaxedNames = parser.strictRefinement = true;\n    var expression = readExpression(parser);\n    parser.relaxedNames = parser.strictRefinement = false;\n\n    if (!expression && type === '>') { return null; }\n\n    if (expression) {\n      refineExpression(expression, partial); // TODO...\n      parser.sp();\n      if (type !== '>') { aliases = parser.matchString('with'); }\n    }\n  }\n\n  parser.sp();\n\n  // check for alias context e.g. `{{>foo bar as bat, bip as bop}}`\n  if (aliases || type === '>') {\n    aliases = readAliases(parser);\n    if (aliases && aliases.length) {\n      partial.z = aliases;\n    } else {\n      // otherwise check for literal context e.g. `{{>foo bar}}` then\n      // turn it into `{{#with bar}}{{>foo}}{{/with}}`\n      var context = readExpression(parser);\n      if (context) {\n        partial.c = {};\n        refineExpression(context, partial.c);\n      }\n\n      // allow aliases after context\n      if (parser.matchString(',')) {\n        aliases = readAliases(parser);\n        if (aliases && aliases.length) {\n          partial.z = aliases;\n        }\n      }\n    }\n\n    if (type !== '>' && (!partial.c && !partial.z)) {\n      // {{yield with}} requires some aliases\n      parser.error(\"Expected a context or one or more aliases\");\n    }\n  }\n\n  parser.sp();\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n  }\n\n  return partial;\n}\n\nfunction readComment(parser, tag) {\n  if (!parser.matchString('!')) {\n    return null;\n  }\n\n  var index = parser.remaining().indexOf(tag.close);\n\n  if (index !== -1) {\n    parser.pos += index + tag.close.length;\n    return { t: COMMENT };\n  }\n}\n\nfunction readInterpolator(parser, tag) {\n  var expression, err;\n\n  var start = parser.pos;\n\n  // TODO would be good for perf if we could do away with the try-catch\n  try {\n    expression = readExpressionOrReference(parser, [tag.close]);\n  } catch (e) {\n    err = e;\n  }\n\n  if (!expression) {\n    if (parser.str.charAt(start) === '!') {\n      // special case - comment\n      parser.pos = start;\n      return null;\n    }\n\n    if (err) {\n      throw err;\n    }\n  }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"' after reference\"));\n\n    if (!expression) {\n      // special case - comment\n      if (parser.nextChar() === '!') {\n        return null;\n      }\n\n      parser.error(\"Expected expression or legal reference\");\n    }\n  }\n\n  var interpolator = { t: INTERPOLATOR };\n  refineExpression(expression, interpolator); // TODO handle this differently - it's mysterious\n\n  return interpolator;\n}\n\nfunction readClosing(parser, tag) {\n  var start = parser.pos;\n\n  if (!parser.matchString(tag.open)) {\n    return null;\n  }\n\n  parser.sp();\n\n  if (!parser.matchString('/')) {\n    parser.pos = start;\n    return null;\n  }\n\n  parser.sp();\n\n  var remaining = parser.remaining();\n  var index = remaining.indexOf(tag.close);\n\n  if (index !== -1) {\n    var closing = {\n      t: CLOSING,\n      r: remaining.substr(0, index).split(' ')[0]\n    };\n\n    parser.pos += index;\n\n    if (!parser.matchString(tag.close)) {\n      parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n    }\n\n    return closing;\n  }\n\n  parser.pos = start;\n  return null;\n}\n\nvar patterns = {\n  else: /^\\s*else\\s*/,\n  elseif: /^\\s*elseif\\s+/,\n  then: /^\\s*then\\s*/,\n  catch: /^\\s*catch\\s*/\n};\n\nvar types = {\n  else: ELSE,\n  elseif: ELSEIF,\n  then: THEN,\n  catch: CATCH\n};\n\nfunction readInlineBlock(parser, tag, type) {\n  var start = parser.pos;\n\n  if (!parser.matchString(tag.open)) {\n    return null;\n  }\n\n  if (!parser.matchPattern(patterns[type])) {\n    parser.pos = start;\n    return null;\n  }\n\n  var res = { t: types[type] };\n\n  if (type === 'elseif') {\n    res.x = readExpression(parser);\n  } else if (type === 'catch' || type === 'then') {\n    var nm = parser.matchPattern(name);\n    if (nm) { res.n = nm; }\n  }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n  }\n\n  return res;\n}\n\nvar handlebarsBlockCodes = {\n  each: SECTION_EACH,\n  if: SECTION_IF,\n  with: SECTION_IF_WITH,\n  unless: SECTION_UNLESS\n};\n\nvar indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;\nvar keyIndexRefPattern = /^\\s*,\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;\nvar handlebarsBlockPattern = new RegExp('^(' + keys(handlebarsBlockCodes).join('|') + ')\\\\b');\n\nfunction readSection(parser, tag) {\n  var expression,\n    section,\n    child,\n    children,\n    hasElse,\n    block,\n    unlessBlock,\n    closed,\n    i,\n    expectedClose,\n    hasThen,\n    hasCatch,\n    inlineThen;\n  var aliasOnly = false;\n\n  var start = parser.pos;\n\n  if (parser.matchString('^')) {\n    // watch out for parent context refs - {{^^/^^/foo}}\n    if (parser.matchString('^/')) {\n      parser.pos = start;\n      return null;\n    }\n    section = { t: SECTION, f: [], n: SECTION_UNLESS };\n  } else if (parser.matchString('#')) {\n    section = { t: SECTION, f: [] };\n\n    if (parser.matchString('partial')) {\n      parser.pos = start - parser.standardDelimiters[0].length;\n      parser.error(\n        'Partial definitions can only be at the top level of the template, or immediately inside components'\n      );\n    }\n\n    if ((block = parser.matchString('await'))) {\n      expectedClose = block;\n      section.t = AWAIT;\n    } else if ((block = parser.matchPattern(handlebarsBlockPattern))) {\n      expectedClose = block;\n      section.n = handlebarsBlockCodes[block];\n    }\n  } else {\n    return null;\n  }\n\n  parser.sp();\n\n  if (block === 'with') {\n    var aliases = readAliases(parser);\n    if (aliases) {\n      aliasOnly = true;\n      section.z = aliases;\n      section.t = ALIAS;\n    }\n  } else if (block === 'each') {\n    var alias = readAlias(parser);\n    if (alias) {\n      section.z = [{ n: alias.n, x: { r: '.' } }];\n      expression = alias.x;\n    }\n  }\n\n  if (!aliasOnly) {\n    if (!expression) { expression = readExpression(parser); }\n\n    if (!expression) {\n      parser.error('Expected expression');\n    }\n\n    // extra each aliases\n    if (block === 'each' && parser.matchString(',')) {\n      var aliases$1 = readAliases(parser);\n      if (aliases$1) {\n        if (section.z) { aliases$1.unshift(section.z[0]); }\n        section.z = aliases$1;\n      }\n    }\n\n    // optional index and key references\n    if ((block === 'each' || !block) && (i = parser.matchPattern(indexRefPattern))) {\n      var extra;\n\n      if ((extra = parser.matchPattern(keyIndexRefPattern))) {\n        section.i = i + ',' + extra;\n      } else {\n        section.i = i;\n      }\n    } else if (block === 'await' && parser.matchString('then')) {\n      parser.sp();\n      hasThen = true;\n      inlineThen = parser.matchPattern(name);\n      if (!inlineThen) { inlineThen = true; }\n    }\n\n    if (!block && expression.n) {\n      expectedClose = expression.n;\n    }\n  }\n\n  parser.sp();\n\n  if (parser.matchString('-')) { section.w = 1; }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n  }\n\n  parser.sectionDepth += 1;\n  children = section.f;\n\n  var pos;\n  do {\n    pos = parser.pos;\n    if ((child = readClosing(parser, tag))) {\n      if (expectedClose && child.r !== expectedClose) {\n        if (!block) {\n          if (child.r)\n            { parser.warn(\n              (\"Expected \" + (tag.open) + \"/\" + expectedClose + (tag.close) + \" but found \" + (tag.open) + \"/\" + (child.r) + (tag.close))\n            ); }\n        } else {\n          parser.pos = pos;\n          parser.error((\"Expected \" + (tag.open) + \"/\" + expectedClose + (tag.close)));\n        }\n      }\n\n      parser.sectionDepth -= 1;\n      closed = true;\n    } else if (\n      !aliasOnly &&\n      ((child = readInlineBlock(parser, tag, 'elseif')) ||\n        (child = readInlineBlock(parser, tag, 'else')) ||\n        (block === 'await' &&\n          ((child = readInlineBlock(parser, tag, 'then')) ||\n            (child = readInlineBlock(parser, tag, 'catch')))))\n    ) {\n      if (section.n === SECTION_UNLESS) {\n        parser.error('{{else}} not allowed in {{#unless}}');\n      }\n\n      if (hasElse) {\n        if (child.t === ELSE) {\n          parser.error('there can only be one {{else}} block, at the end of a section');\n        } else if (child.t === ELSEIF) {\n          parser.error('illegal {{elseif...}} after {{else}}');\n        }\n      }\n\n      if (!unlessBlock && (inlineThen || !hasThen) && !hasCatch) {\n        if (block === 'await') {\n          var s = { f: children };\n          section.f = [s];\n          if (inlineThen) {\n            s.t = THEN;\n            inlineThen !== true && (s.n = inlineThen);\n          } else {\n            s.t = SECTION;\n          }\n        } else {\n          unlessBlock = [];\n        }\n      }\n\n      var mustache = {\n        t: SECTION,\n        f: (children = [])\n      };\n\n      if (child.t === ELSE) {\n        if (block === 'await') {\n          section.f.push(mustache);\n          mustache.t = ELSE;\n        } else {\n          mustache.n = SECTION_UNLESS;\n          unlessBlock.push(mustache);\n        }\n        hasElse = true;\n      } else if (child.t === ELSEIF) {\n        mustache.n = SECTION_IF;\n        refineExpression(child.x, mustache);\n        unlessBlock.push(mustache);\n      } else if (child.t === THEN) {\n        if (hasElse) { parser.error('{{then}} block must appear before any {{else}} block'); }\n        if (hasCatch) { parser.error('{{then}} block must appear before any {{catch}} block'); }\n        if (hasThen) { parser.error('there can only be one {{then}} block per {{#await}}'); }\n        mustache.t = THEN;\n        hasThen = true;\n        child.n && (mustache.n = child.n);\n        section.f.push(mustache);\n      } else if (child.t === CATCH) {\n        if (hasElse) { parser.error('{{catch}} block must appear before any {{else}} block'); }\n        if (hasCatch) { parser.error('there can only be one {{catch}} block per {{#await}}'); }\n        mustache.t = CATCH;\n        hasCatch = true;\n        mustache.n = child.n;\n        section.f.push(mustache);\n      }\n    } else {\n      child = parser.read(READERS);\n\n      if (!child) {\n        break;\n      }\n\n      children.push(child);\n    }\n  } while (!closed);\n\n  if (unlessBlock) {\n    section.l = unlessBlock;\n  }\n\n  if (!aliasOnly) {\n    refineExpression(expression, section);\n  }\n\n  if (block === 'await' && (inlineThen || !hasThen) && !hasCatch && !hasElse) {\n    var s$1 = { f: section.f };\n    section.f = [s$1];\n    if (inlineThen) {\n      s$1.t = THEN;\n      inlineThen !== true && (s$1.n = inlineThen);\n    } else {\n      s$1.t = SECTION;\n    }\n  }\n\n  // TODO if a section is empty it should be discarded. Don't do\n  // that here though - we need to clean everything up first, as\n  // it may contain removeable whitespace. As a temporary measure,\n  // to pass the existing tests, remove empty `f` arrays\n  if (!section.f.length) {\n    delete section.f;\n  }\n\n  return section;\n}\n\nvar OPEN_COMMENT = '\x3c!--';\nvar CLOSE_COMMENT = '--\x3e';\n\nfunction readHtmlComment(parser) {\n  var start = parser.pos;\n\n  if (parser.textOnlyMode || !parser.matchString(OPEN_COMMENT)) {\n    return null;\n  }\n\n  var remaining = parser.remaining();\n  var endIndex = remaining.indexOf(CLOSE_COMMENT);\n\n  if (endIndex === -1) {\n    parser.error(\"Illegal HTML - expected closing comment sequence ('--\x3e')\");\n  }\n\n  var content = remaining.substr(0, endIndex);\n  parser.pos += endIndex + 3;\n\n  var comment = {\n    t: COMMENT,\n    c: content\n  };\n\n  if (parser.includeLinePositions) {\n    comment.q = parser.getLinePos(start);\n  }\n\n  return comment;\n}\n\nvar leadingLinebreak = /^[ \\t\\f\\r\\n]*\\r?\\n/;\nvar trailingLinebreak = /\\r?\\n[ \\t\\f\\r\\n]*$/;\n\nfunction stripStandalones(items, preserveStandaloneSections) {\n  var i, current, backOne, backTwo, lastSectionItem;\n\n  for (i = 1; i < items.length; i += 1) {\n    current = items[i];\n    backOne = items[i - 1];\n    backTwo = items[i - 2];\n\n    // if we're at the end of a [text][comment][text] sequence...\n    if (isString(current) && isComment(backOne) && isString(backTwo)) {\n      // ... and the comment is a standalone (i.e. line breaks either side)...\n      if (trailingLinebreak.test(backTwo) && leadingLinebreak.test(current)) {\n        // ... then we want to remove the whitespace after the first line break\n        items[i - 2] = backTwo.replace(trailingLinebreak, '\\n');\n\n        // and the leading line break of the second text token\n        items[i] = current.replace(leadingLinebreak, '');\n      }\n    }\n\n    if (!preserveStandaloneSections) {\n      // if the current item is a section, and it is preceded by a linebreak, and\n      // its first item is a linebreak...\n      if (isSection(current) && isString(backOne)) {\n        if (\n          trailingLinebreak.test(backOne) &&\n          isString(current.f[0]) &&\n          leadingLinebreak.test(current.f[0])\n        ) {\n          items[i - 1] = backOne.replace(trailingLinebreak, '\\n');\n          current.f[0] = current.f[0].replace(leadingLinebreak, '');\n        }\n      }\n\n      // if the last item was a section, and it is followed by a linebreak, and\n      // its last item is a linebreak...\n      if (isString(current) && isSection(backOne)) {\n        lastSectionItem = lastItem(backOne.f);\n\n        if (\n          isString(lastSectionItem) &&\n          trailingLinebreak.test(lastSectionItem) &&\n          leadingLinebreak.test(current)\n        ) {\n          backOne.f[backOne.f.length - 1] = lastSectionItem.replace(trailingLinebreak, '\\n');\n          items[i] = current.replace(leadingLinebreak, '');\n        }\n      }\n    }\n  }\n\n  return items;\n}\n\nfunction isComment(item) {\n  return item.t === COMMENT || item.t === DELIMCHANGE;\n}\n\nfunction isSection(item) {\n  return (item.t === SECTION || item.t === INVERTED) && item.f;\n}\n\nfunction trimWhitespace(items, leadingPattern, trailingPattern) {\n  var item;\n\n  if (leadingPattern) {\n    item = items[0];\n    if (isString(item)) {\n      item = item.replace(leadingPattern, '');\n\n      if (!item) {\n        items.shift();\n      } else {\n        items[0] = item;\n      }\n    }\n  }\n\n  if (trailingPattern) {\n    item = lastItem(items);\n    if (isString(item)) {\n      item = item.replace(trailingPattern, '');\n\n      if (!item) {\n        items.pop();\n      } else {\n        items[items.length - 1] = item;\n      }\n    }\n  }\n}\n\nvar contiguousWhitespace = /[ \\t\\f\\r\\n]+/g;\nvar leadingWhitespace$1 = /^[ \\t\\f\\r\\n]+/;\nvar trailingWhitespace = /[ \\t\\f\\r\\n]+$/;\nvar leadingNewLine = /^(?:\\r\\n|\\r|\\n)/;\nvar trailingNewLine = /(?:\\r\\n|\\r|\\n)$/;\nvar trailingIndent = /(\\n)?[ \\t]*$/;\nvar leadingLine = /[ \\t]*\\n/;\n\nfunction cleanup(\n  items,\n  stripComments,\n  preserveWhitespace,\n  removeLeadingWhitespace,\n  removeTrailingWhitespace,\n  whiteSpaceElements,\n  preserveStandaloneSections\n) {\n  if (isString(items)) { return; }\n\n  var i,\n    item,\n    previousItem,\n    nextItem,\n    preserveWhitespaceInsideFragment,\n    removeLeadingWhitespaceInsideFragment,\n    removeTrailingWhitespaceInsideFragment;\n\n  // First pass - remove standalones and comments etc\n  stripStandalones(items, preserveStandaloneSections);\n\n  i = items.length;\n  while (i--) {\n    item = items[i];\n\n    // Remove delimiter changes, unsafe elements etc\n    if (item.exclude) {\n      items.splice(i, 1);\n    } else if (stripComments && item.t === COMMENT) {\n      // Remove comments, unless we want to keep them\n      items.splice(i, 1);\n    }\n  }\n\n  // If necessary, remove leading and trailing whitespace\n  trimWhitespace(\n    items,\n    removeLeadingWhitespace ? leadingWhitespace$1 : null,\n    removeTrailingWhitespace ? trailingWhitespace : null\n  );\n\n  i = items.length;\n  while (i--) {\n    item = items[i];\n    removeLeadingWhitespaceInsideFragment = removeTrailingWhitespaceInsideFragment = false;\n\n    if (item.w) {\n      var prev = items[i - 1];\n      var hitLast = true;\n      if (typeof prev === 'string') { items[i - 1] = prev.replace(trailingIndent, '$1'); }\n      if (item.f) {\n        if (typeof item.f[0] === 'string') { item.f[0] = item.f[0].replace(leadingLine, ''); }\n        var last = item.f.length - 1;\n        if (typeof item.f[last] === 'string') {\n          item.f[last] = item.f[last].replace(trailingIndent, function (_m, str) {\n            hitLast = str;\n            return str || '';\n          });\n        }\n      }\n      var next = items[i + 1];\n      if (hitLast && typeof next === 'string') { items[i + 1] = next.replace(leadingLine, ''); }\n    }\n\n    // Recurse\n    if (item.f) {\n      var isPreserveWhitespaceElement =\n        item.t === ELEMENT &&\n        (whiteSpaceElements[item.e.toLowerCase()] || whiteSpaceElements[item.e]);\n      preserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;\n\n      if (!preserveWhitespace && isPreserveWhitespaceElement) {\n        trimWhitespace(item.f, leadingNewLine, trailingNewLine);\n      }\n\n      if (!preserveWhitespaceInsideFragment) {\n        previousItem = items[i - 1];\n        nextItem = items[i + 1];\n\n        // if the previous item was a text item with trailing whitespace,\n        // remove leading whitespace inside the fragment\n        if (!previousItem || (isString(previousItem) && trailingWhitespace.test(previousItem))) {\n          removeLeadingWhitespaceInsideFragment = true;\n        }\n\n        // and vice versa\n        if (!nextItem || (isString(nextItem) && leadingWhitespace$1.test(nextItem))) {\n          removeTrailingWhitespaceInsideFragment = true;\n        }\n      }\n\n      cleanup(\n        item.f,\n        stripComments,\n        preserveWhitespaceInsideFragment,\n        removeLeadingWhitespaceInsideFragment,\n        removeTrailingWhitespaceInsideFragment,\n        whiteSpaceElements\n      );\n    }\n\n    // Split if-else blocks into two (an if, and an unless)\n    if (item.l) {\n      if (item.w) { item.l.forEach(function (l) { return (l.w = 1); }); }\n      cleanup(\n        item.l,\n        stripComments,\n        preserveWhitespace,\n        removeLeadingWhitespaceInsideFragment,\n        removeTrailingWhitespaceInsideFragment,\n        whiteSpaceElements\n      );\n\n      item.l.forEach(function (s) { return (s.l = 1); });\n      item.l.unshift(i + 1, 0);\n      items.splice.apply(items, item.l);\n      delete item.l; // TODO would be nice if there was a way around this\n    }\n\n    // Clean up conditional attributes\n    if (item.m) {\n      cleanup(\n        item.m,\n        stripComments,\n        preserveWhitespace,\n        removeLeadingWhitespaceInsideFragment,\n        removeTrailingWhitespaceInsideFragment,\n        whiteSpaceElements\n      );\n      if (item.m.length < 1) { delete item.m; }\n    }\n\n    delete item.w;\n  }\n\n  // final pass - fuse text nodes together\n  i = items.length;\n  while (i--) {\n    if (isString(items[i])) {\n      if (isString(items[i + 1])) {\n        items[i] = items[i] + items[i + 1];\n        items.splice(i + 1, 1);\n      }\n\n      if (!preserveWhitespace) {\n        items[i] = items[i].replace(contiguousWhitespace, ' ');\n      }\n\n      if (items[i] === '') {\n        items.splice(i, 1);\n      }\n    }\n  }\n}\n\nvar closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n\nfunction readClosingTag(parser) {\n  var tag;\n\n  var start = parser.pos;\n\n  // are we looking at a closing tag?\n  if (!parser.matchString('</')) {\n    return null;\n  }\n\n  if ((tag = parser.matchPattern(closingTagPattern))) {\n    if (parser.inside && tag !== parser.inside) {\n      parser.pos = start;\n      return null;\n    }\n\n    return {\n      t: CLOSING_TAG,\n      e: tag\n    };\n  }\n\n  // We have an illegal closing tag, report it\n  parser.pos -= 2;\n  parser.error('Illegal closing tag');\n}\n\nfunction hyphenateCamel(camelCaseStr) {\n  return camelCaseStr.replace(/([A-Z])/g, function (match, $1) {\n    return '-' + $1.toLowerCase();\n  });\n}\n\nvar tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/;\nvar anchorPattern = /^[a-zA-Z_$][-a-zA-Z0-9_$]*/;\nvar validTagNameFollower = /^[\\s\\n\\/>]/;\nvar semiEnd = /;\\s*$/;\nvar exclude = { exclude: true };\n\n// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\nvar disallowedContents = {\n  li: ['li'],\n  dt: ['dt', 'dd'],\n  dd: ['dt', 'dd'],\n  p: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split(\n    ' '\n  ),\n  rt: ['rt', 'rp'],\n  rp: ['rt', 'rp'],\n  optgroup: ['optgroup'],\n  option: ['option', 'optgroup'],\n  thead: ['tbody', 'tfoot'],\n  tbody: ['tbody', 'tfoot'],\n  tfoot: ['tbody'],\n  tr: ['tr', 'tbody'],\n  td: ['td', 'th', 'tr'],\n  th: ['td', 'th', 'tr']\n};\n\nfunction readElement$1(parser) {\n  var attribute,\n    selfClosing,\n    children,\n    partials,\n    hasPartials,\n    child,\n    closed,\n    pos,\n    remaining,\n    closingTag,\n    anchor;\n\n  var start = parser.pos;\n\n  if (parser.inside || parser.inAttribute || parser.textOnlyMode) {\n    return null;\n  }\n\n  if (!parser.matchString('<')) {\n    return null;\n  }\n\n  // if this is a closing tag, abort straight away\n  if (parser.nextChar() === '/') {\n    return null;\n  }\n\n  var element = {};\n  if (parser.includeLinePositions) {\n    element.q = parser.getLinePos(start);\n  }\n\n  // check for doctype decl\n  if (parser.matchString('!')) {\n    element.t = DOCTYPE;\n    if (!parser.matchPattern(/^doctype/i)) {\n      parser.error('Expected DOCTYPE declaration');\n    }\n\n    element.a = parser.matchPattern(/^(.+?)>/);\n    return element;\n  } else if ((anchor = parser.matchString('#'))) {\n    // check for anchor\n    parser.sp();\n    element.t = ANCHOR;\n    element.n = parser.matchPattern(anchorPattern);\n  } else {\n    // otherwise, it's an element/component\n    element.t = ELEMENT;\n\n    // element name\n    element.e = parser.matchPattern(tagNamePattern);\n    if (!element.e) {\n      return null;\n    }\n  }\n\n  // next character must be whitespace, closing solidus or '>'\n  if (!validTagNameFollower.test(parser.nextChar())) {\n    parser.error('Illegal tag name');\n  }\n\n  parser.sp();\n\n  parser.inTag = true;\n\n  // directives and attributes\n  while ((attribute = readMustache(parser))) {\n    if (attribute !== false) {\n      if (!element.m) { element.m = []; }\n      element.m.push(attribute);\n    }\n\n    parser.sp();\n  }\n\n  parser.inTag = false;\n\n  // allow whitespace before closing solidus\n  parser.sp();\n\n  // self-closing solidus?\n  if (parser.matchString('/')) {\n    selfClosing = true;\n  }\n\n  // closing angle bracket\n  if (!parser.matchString('>')) {\n    return null;\n  }\n\n  var lowerCaseName = (element.e || element.n).toLowerCase();\n  var preserveWhitespace = parser.preserveWhitespace;\n\n  if (!selfClosing && (anchor || !voidElements[element.e.toLowerCase()])) {\n    if (!anchor) {\n      parser.elementStack.push(lowerCaseName);\n\n      // Special case - if we open a script element, further tags should\n      // be ignored unless they're a closing script element\n      if (lowerCaseName in parser.interpolate) {\n        parser.inside = lowerCaseName;\n      }\n    }\n\n    children = [];\n    partials = create(null);\n\n    do {\n      pos = parser.pos;\n      remaining = parser.remaining();\n\n      if (!remaining) {\n        // if this happens to be a script tag and there's no content left, it's because\n        // a closing script tag can't appear in a script\n        if (parser.inside === 'script') {\n          closed = true;\n          break;\n        }\n\n        parser.error(\n          (\"Missing end \" + (parser.elementStack.length > 1 ? 'tags' : 'tag') + \" (\" + (parser.elementStack\n            .reverse()\n            .map(function (x) { return (\"</\" + x + \">\"); })\n            .join('')) + \")\")\n        );\n      }\n\n      // if for example we're in an <li> element, and we see another\n      // <li> tag, close the first so they become siblings\n      if (!anchor && !canContain(lowerCaseName, remaining)) {\n        closed = true;\n      } else if (!anchor && (closingTag = readClosingTag(parser))) {\n        // closing tag\n        closed = true;\n\n        var closingTagName = closingTag.e.toLowerCase();\n\n        // if this *isn't* the closing tag for the current element...\n        if (closingTagName !== lowerCaseName) {\n          // rewind parser\n          parser.pos = pos;\n\n          // if it doesn't close a parent tag, error\n          if (!~parser.elementStack.indexOf(closingTagName)) {\n            var errorMessage = 'Unexpected closing tag';\n\n            // add additional help for void elements, since component names\n            // might clash with them\n            if (voidElements[closingTagName.toLowerCase()]) {\n              errorMessage += \" (<\" + closingTagName + \"> is a void element - it cannot contain children)\";\n            }\n\n            parser.error(errorMessage);\n          }\n        }\n      } else if (anchor && readAnchorClose(parser, element.n)) {\n        closed = true;\n      } else {\n        // implicit close by closing section tag. TODO clean this up\n        var tag = {\n          open: parser.standardDelimiters[0],\n          close: parser.standardDelimiters[1]\n        };\n        if (readClosing(parser, tag) || readInline(parser, tag)) {\n          closed = true;\n          parser.pos = pos;\n        } else if ((child = parser.read(PARTIAL_READERS))) {\n          if (partials[child.n]) {\n            parser.pos = pos;\n            parser.error('Duplicate partial definition');\n          }\n\n          cleanup(\n            child.f,\n            parser.stripComments,\n            preserveWhitespace,\n            !preserveWhitespace,\n            !preserveWhitespace,\n            parser.whiteSpaceElements\n          );\n\n          partials[child.n] = child.f;\n          hasPartials = true;\n        } else {\n          if ((child = parser.read(READERS))) {\n            children.push(child);\n          } else {\n            closed = true;\n          }\n        }\n      }\n    } while (!closed);\n\n    if (children.length) {\n      element.f = children;\n    }\n\n    if (hasPartials) {\n      element.p = partials;\n    }\n\n    parser.elementStack.pop();\n  }\n\n  parser.inside = null;\n\n  if (parser.sanitizeElements && parser.sanitizeElements.indexOf(lowerCaseName) !== -1) {\n    return exclude;\n  }\n\n  if (\n    element.m &&\n    lowerCaseName !== 'input' &&\n    lowerCaseName !== 'select' &&\n    lowerCaseName !== 'textarea' &&\n    lowerCaseName !== 'option'\n  ) {\n    var attrs = element.m;\n    var classes, styles, cls, style;\n    var i = 0;\n    var a;\n    while (i < attrs.length) {\n      a = attrs[i];\n\n      if (a.t !== ATTRIBUTE) {\n        i++;\n        continue;\n      }\n\n      if (a.n.indexOf('class-') === 0 && !a.f) {\n        // static class directives\n        (classes || (classes = [])).push(a.n.slice(6));\n        attrs.splice(i, 1);\n      } else if (a.n.indexOf('style-') === 0 && isString(a.f)) {\n        // static style directives\n        (styles || (styles = [])).push(((hyphenateCamel(a.n.slice(6))) + \": \" + (a.f) + \";\"));\n        attrs.splice(i, 1);\n      } else if (a.n === 'class' && isString(a.f)) {\n        // static class attrs\n        (classes || (classes = [])).push(a.f);\n        attrs.splice(i, 1);\n      } else if (a.n === 'style' && isString(a.f)) {\n        // static style attrs\n        (styles || (styles = [])).push(a.f + (semiEnd.test(a.f) ? '' : ';'));\n        attrs.splice(i, 1);\n      } else if (a.n === 'class') {\n        cls = a;\n        i++;\n      } else if (a.n === 'style') {\n        style = a;\n        i++;\n      } else if (\n        !~a.n.indexOf(':') &&\n        a.n !== 'value' &&\n        a.n !== 'contenteditable' &&\n        isString(a.f)\n      ) {\n        a.g = 1;\n        i++;\n      } else {\n        i++;\n      }\n    }\n\n    if (classes) {\n      if (!cls || !isString(cls.f))\n        { attrs.unshift({ t: ATTRIBUTE, n: 'class', f: classes.join(' '), g: 1 }); }\n      else { cls.f += ' ' + classes.join(' '); }\n    } else if (cls && isString(cls.f)) { cls.g = 1; }\n\n    if (styles) {\n      if (!style || !isString(style.f))\n        { attrs.unshift({ t: ATTRIBUTE, n: 'style', f: styles.join(' '), g: 1 }); }\n      else { style.f += '; ' + styles.join(' '); }\n    } else if (style && isString(style.f)) { style.g = 1; }\n  }\n\n  return element;\n}\n\nfunction canContain(name, remaining) {\n  var match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec(remaining);\n  var disallowed = disallowedContents[name];\n\n  if (!match || !disallowed) {\n    return true;\n  }\n\n  return !~disallowed.indexOf(match[1].toLowerCase());\n}\n\nfunction readAnchorClose(parser, name) {\n  var pos = parser.pos;\n  if (!parser.matchString('</')) {\n    return null;\n  }\n\n  parser.matchString('#');\n  parser.sp();\n\n  if (!parser.matchString(name)) {\n    parser.pos = pos;\n    return null;\n  }\n\n  parser.sp();\n\n  if (!parser.matchString('>')) {\n    parser.pos = pos;\n    return null;\n  }\n\n  return true;\n}\n\nvar inlines = /^\\s*(elseif|else|then|catch)\\s*/;\nfunction readInline(parser, tag) {\n  var pos = parser.pos;\n  if (!parser.matchString(tag.open)) { return; }\n  if (parser.matchPattern(inlines)) {\n    return true;\n  } else {\n    parser.pos = pos;\n  }\n}\n\nfunction readText(parser) {\n  var index, disallowed, barrier;\n\n  var remaining = parser.remaining();\n\n  if (parser.textOnlyMode) {\n    disallowed = parser.tags.map(function (t) { return t.open; });\n    disallowed = disallowed.concat(parser.tags.map(function (t) { return '\\\\' + t.open; }));\n\n    index = getLowestIndex(remaining, disallowed);\n  } else {\n    barrier = parser.inside ? '</' + parser.inside : '<';\n\n    if (parser.inside && !parser.interpolate[parser.inside]) {\n      index = remaining.indexOf(barrier);\n    } else {\n      disallowed = parser.tags.map(function (t) { return t.open; });\n      disallowed = disallowed.concat(parser.tags.map(function (t) { return '\\\\' + t.open; }));\n\n      // http://developers.whatwg.org/syntax.html#syntax-attributes\n      if (parser.inAttribute === true) {\n        // we're inside an unquoted attribute value\n        disallowed.push(\"\\\"\", \"'\", \"=\", \"<\", \">\", '`');\n      } else if (parser.inAttribute) {\n        // quoted attribute value\n        disallowed.push(parser.inAttribute);\n      } else {\n        disallowed.push(barrier);\n      }\n\n      index = getLowestIndex(remaining, disallowed);\n    }\n  }\n\n  if (!index) {\n    return null;\n  }\n\n  if (index === -1) {\n    index = remaining.length;\n  }\n\n  parser.pos += index;\n\n  if ((parser.inside && parser.inside !== 'textarea') || parser.textOnlyMode) {\n    return remaining.substr(0, index);\n  } else {\n    return decodeCharacterReferences(remaining.substr(0, index));\n  }\n}\n\nvar partialDefinitionSectionPattern = /^\\s*#\\s*partial\\s+/;\n\nfunction readPartialDefinitionSection(parser) {\n  var child, closed;\n\n  var start = parser.pos;\n\n  var delimiters = parser.standardDelimiters;\n\n  if (!parser.matchString(delimiters[0])) {\n    return null;\n  }\n\n  if (!parser.matchPattern(partialDefinitionSectionPattern)) {\n    parser.pos = start;\n    return null;\n  }\n\n  var name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\\-\\/]*/);\n\n  if (!name) {\n    parser.error('expected legal partial name');\n  }\n\n  parser.sp();\n  if (!parser.matchString(delimiters[1])) {\n    parser.error((\"Expected closing delimiter '\" + (delimiters[1]) + \"'\"));\n  }\n\n  var content = [];\n\n  var open = delimiters[0];\n  var close = delimiters[1];\n\n  do {\n    if ((child = readClosing(parser, { open: open, close: close }))) {\n      if (child.r !== 'partial') {\n        parser.error((\"Expected \" + open + \"/partial\" + close));\n      }\n\n      closed = true;\n    } else {\n      child = parser.read(READERS);\n\n      if (!child) {\n        parser.error((\"Expected \" + open + \"/partial\" + close));\n      }\n\n      content.push(child);\n    }\n  } while (!closed);\n\n  return {\n    t: INLINE_PARTIAL,\n    n: name,\n    f: content\n  };\n}\n\nfunction readTemplate(parser) {\n  var fragment = [];\n  var partials = create(null);\n  var hasPartials = false;\n\n  var preserveWhitespace = parser.preserveWhitespace;\n\n  while (parser.pos < parser.str.length) {\n    var pos = parser.pos;\n    var item = (void 0), partial = (void 0);\n\n    if ((partial = parser.read(PARTIAL_READERS))) {\n      if (partials[partial.n]) {\n        parser.pos = pos;\n        parser.error('Duplicated partial definition');\n      }\n\n      cleanup(\n        partial.f,\n        parser.stripComments,\n        preserveWhitespace,\n        !preserveWhitespace,\n        !preserveWhitespace,\n        parser.whiteSpaceElements\n      );\n\n      partials[partial.n] = partial.f;\n      hasPartials = true;\n    } else if ((item = parser.read(READERS))) {\n      fragment.push(item);\n    } else {\n      parser.error('Unexpected template content');\n    }\n  }\n\n  var result = {\n    v: TEMPLATE_VERSION,\n    t: fragment\n  };\n\n  if (hasPartials) {\n    result.p = partials;\n  }\n\n  return result;\n}\n\nfunction insertExpressions(obj, expr) {\n  keys(obj).forEach(function (key) {\n    if (isExpression(key, obj)) { return addTo(obj, expr); }\n\n    var ref = obj[key];\n    if (hasChildren(ref)) { insertExpressions(ref, expr); }\n  });\n}\n\nfunction isExpression(key, obj) {\n  return key === 's' && isArray(obj.r);\n}\n\nfunction addTo(obj, expr) {\n  var s = obj.s;\n  var r = obj.r;\n  if (!expr[s]) { expr[s] = fromExpression(s, r.length); }\n}\n\nfunction hasChildren(ref) {\n  return isArray(ref) || isObject(ref);\n}\n\nvar shared = {};\n\n// See https://github.com/ractivejs/template-spec for information\n// about the Ractive template specification\n\nvar STANDARD_READERS = [\n  readPartial,\n  readUnescaped,\n  readSection,\n  readInterpolator,\n  readComment\n];\nvar TRIPLE_READERS = [readTriple];\n\nvar READERS = [readMustache, readHtmlComment, readElement$1, readText];\nvar PARTIAL_READERS = [readPartialDefinitionSection];\n\nvar preserveWhitespaceElements = { pre: 1, script: 1, style: 1, textarea: 1 };\n\nvar defaultInterpolate = { textarea: true, script: true, style: true, template: true };\n\nvar StandardParser = Parser.extend({\n  init: function init(str, options) {\n    var tripleDelimiters = options.tripleDelimiters || shared.defaults.tripleDelimiters;\n    var staticDelimiters = options.staticDelimiters || shared.defaults.staticDelimiters;\n    var staticTripleDelimiters =\n      options.staticTripleDelimiters || shared.defaults.staticTripleDelimiters;\n\n    this.standardDelimiters = options.delimiters || shared.defaults.delimiters;\n\n    this.tags = [\n      {\n        isStatic: false,\n        isTriple: false,\n        open: this.standardDelimiters[0],\n        close: this.standardDelimiters[1],\n        readers: STANDARD_READERS\n      },\n      {\n        isStatic: false,\n        isTriple: true,\n        open: tripleDelimiters[0],\n        close: tripleDelimiters[1],\n        readers: TRIPLE_READERS\n      },\n      {\n        isStatic: true,\n        isTriple: false,\n        open: staticDelimiters[0],\n        close: staticDelimiters[1],\n        readers: STANDARD_READERS\n      },\n      {\n        isStatic: true,\n        isTriple: true,\n        open: staticTripleDelimiters[0],\n        close: staticTripleDelimiters[1],\n        readers: TRIPLE_READERS\n      }\n    ];\n\n    this.contextLines = options.contextLines || shared.defaults.contextLines;\n\n    this.sortMustacheTags();\n\n    this.sectionDepth = 0;\n    this.elementStack = [];\n\n    this.interpolate = assign(\n      {},\n      defaultInterpolate,\n      shared.defaults.interpolate,\n      options.interpolate\n    );\n\n    if (options.sanitize === true) {\n      options.sanitize = {\n        // blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n        elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split(\n          ' '\n        ),\n        eventAttributes: true\n      };\n    }\n\n    this.stripComments = options.stripComments !== false;\n    this.preserveWhitespace = isObjectType(options.preserveWhitespace)\n      ? false\n      : options.preserveWhitespace;\n    this.sanitizeElements = options.sanitize && options.sanitize.elements;\n    this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n    this.includeLinePositions = options.includeLinePositions;\n    this.textOnlyMode = options.textOnlyMode;\n    this.csp = options.csp;\n    this.allowExpressions = options.allowExpressions;\n\n    this.preserveStandaloneSections = this.preserveWhitespace && options.preserveStandaloneSections;\n\n    if (options.expression) { this.converters = [readExpression]; }\n\n    if (options.attributes) { this.inTag = true; }\n\n    // special whitespace handling requested for certain elements\n    this.whiteSpaceElements = assign({}, options.preserveWhitespace, preserveWhitespaceElements);\n  },\n\n  postProcess: function postProcess(result, options) {\n    var parserResult = result[0];\n\n    if (options.expression) {\n      var expr = flattenExpression(parserResult);\n      expr.e = fromExpression(expr.s, expr.r.length);\n      return expr;\n    } else {\n      // special case - empty string\n      if (!result.length) {\n        return { t: [], v: TEMPLATE_VERSION };\n      }\n\n      if (this.sectionDepth > 0) {\n        this.error('A section was left open');\n      }\n\n      cleanup(\n        parserResult.t,\n        this.stripComments,\n        this.preserveWhitespace,\n        !this.preserveWhitespace,\n        !this.preserveWhitespace,\n        this.whiteSpaceElements,\n        this.preserveStandaloneSections\n      );\n\n      if (this.csp !== false) {\n        var expr$1 = {};\n\n        insertExpressions(parserResult.t, expr$1);\n        insertExpressions(parserResult.p || {}, expr$1);\n\n        if (keys(expr$1).length) { parserResult.e = expr$1; }\n      }\n\n      return parserResult;\n    }\n  },\n\n  converters: [readTemplate],\n\n  sortMustacheTags: function sortMustacheTags() {\n    // Sort in order of descending opening delimiter length (longer first),\n    // to protect against opening delimiters being substrings of each other\n    this.tags.sort(function (a, b) {\n      return b.open.length - a.open.length;\n    });\n  }\n});\n\nfunction parse(template, options) {\n  return new StandardParser(template, options || {}).result;\n}\n\nvar parseOptions = [\n  'delimiters',\n  'tripleDelimiters',\n  'staticDelimiters',\n  'staticTripleDelimiters',\n  'csp',\n  'interpolate',\n  'preserveWhitespace',\n  'preserveStandaloneSections',\n  'sanitize',\n  'stripComments',\n  'contextLines',\n  'allowExpressions',\n  'attributes'\n];\n\nvar TEMPLATE_INSTRUCTIONS = \"Either preparse or use a ractive runtime source that includes the parser. \";\n\nvar COMPUTATION_INSTRUCTIONS = \"Either include a version of Ractive that can parse or convert your computation strings to functions.\";\n\nfunction throwNoParse(method, error, instructions) {\n  if (!method) {\n    fatal((\"Missing Ractive.parse - cannot parse \" + error + \". \" + instructions));\n  }\n}\n\nfunction createFunction(body, length) {\n  throwNoParse(fromExpression, 'new expression function', TEMPLATE_INSTRUCTIONS);\n  return fromExpression(body, length);\n}\n\nfunction createFunctionFromString(str, bindTo) {\n  throwNoParse(parse, 'compution string \"${str}\"', COMPUTATION_INSTRUCTIONS);\n  var tpl = parse(str, { expression: true });\n  return function() {\n    return tpl.e.apply(bindTo, tpl.r.map(function (r) { return bindTo.get(r); }));\n  };\n}\n\nvar parser = {\n  fromId: function fromId(id, options) {\n    if (!doc) {\n      if (options && options.noThrow) {\n        return;\n      }\n      throw new Error((\"Cannot retrieve template #\" + id + \" as Ractive is not running in a browser.\"));\n    }\n\n    if (id) { id = id.replace(/^#/, ''); }\n\n    var template;\n\n    if (!(template = doc.getElementById(id))) {\n      if (options && options.noThrow) {\n        return;\n      }\n      throw new Error((\"Could not find template element with id #\" + id));\n    }\n\n    if (template.tagName.toUpperCase() !== 'SCRIPT') {\n      if (options && options.noThrow) {\n        return;\n      }\n      throw new Error((\"Template element with id #\" + id + \", must be a <script> element\"));\n    }\n\n    return 'textContent' in template ? template.textContent : template.innerHTML;\n  },\n\n  isParsed: function isParsed(template) {\n    return !isString(template);\n  },\n\n  getParseOptions: function getParseOptions(ractive) {\n    // Could be Ractive or a Component\n    if (ractive.defaults) {\n      ractive = ractive.defaults;\n    }\n\n    return parseOptions.reduce(function (val, key) {\n      val[key] = ractive[key];\n      return val;\n    }, {});\n  },\n\n  parse: function parse$1(template, options) {\n    throwNoParse(parse, 'template', TEMPLATE_INSTRUCTIONS);\n    var parsed = parse(template, options);\n    addFunctions(parsed);\n    return parsed;\n  },\n\n  parseFor: function parseFor(template, ractive) {\n    return this.parse(template, this.getParseOptions(ractive));\n  }\n};\n\nfunction getComputationSignature(ractive, key, signature) {\n  var getter;\n  var setter;\n\n  // useful for debugging\n  var getterString;\n  var getterUseStack;\n  var setterString;\n\n  if (isFunction(signature)) {\n    getter = bind(signature, ractive);\n    getterString = signature.toString();\n    getterUseStack = true;\n  }\n\n  if (isString(signature)) {\n    getter = createFunctionFromString(signature, ractive);\n    getterString = signature;\n  }\n\n  if (isObjectType(signature)) {\n    if (isString(signature.get)) {\n      getter = createFunctionFromString(signature.get, ractive);\n      getterString = signature.get;\n    } else if (isFunction(signature.get)) {\n      getter = bind(signature.get, ractive);\n      getterString = signature.get.toString();\n      getterUseStack = true;\n    } else {\n      fatal('`%s` computation must have a `get()` method', key);\n    }\n\n    if (isFunction(signature.set)) {\n      setter = bind(signature.set, ractive);\n      setterString = signature.set.toString();\n    }\n  }\n\n  return {\n    getter: getter,\n    setter: setter,\n    getterString: getterString,\n    setterString: setterString,\n    getterUseStack: getterUseStack\n  };\n}\n\nvar id = 0;\n\nvar TransitionManager = function TransitionManager(callback, parent) {\n  this.callback = callback;\n  this.parent = parent;\n\n  this.intros = [];\n  this.outros = [];\n\n  this.children = [];\n  this.totalChildren = this.outroChildren = 0;\n\n  this.detachQueue = [];\n  this.outrosComplete = false;\n\n  this.id = id++;\n\n  if (parent) {\n    parent.addChild(this);\n  }\n};\nvar TransitionManager__proto__ = TransitionManager.prototype;\n\nTransitionManager__proto__.add = function add (transition) {\n  var list = transition.isIntro ? this.intros : this.outros;\n  transition.starting = true;\n  list.push(transition);\n};\n\nTransitionManager__proto__.addChild = function addChild (child) {\n  this.children.push(child);\n\n  this.totalChildren += 1;\n  this.outroChildren += 1;\n};\n\nTransitionManager__proto__.checkStart = function checkStart () {\n  if (this.parent && this.parent.started) { this.start(); }\n};\n\nTransitionManager__proto__.decrementOutros = function decrementOutros () {\n  this.outroChildren -= 1;\n  check(this);\n};\n\nTransitionManager__proto__.decrementTotal = function decrementTotal () {\n  this.totalChildren -= 1;\n  check(this);\n};\n\nTransitionManager__proto__.detachNodes = function detachNodes () {\n    var this$1 = this;\n\n  var len = this.detachQueue.length;\n  for (var i = 0; i < len; i++) { this$1.detachQueue[i].detach(); }\n  len = this.children.length;\n  for (var i$1 = 0; i$1 < len; i$1++) { this$1.children[i$1].detachNodes(); }\n  this.detachQueue = [];\n};\n\nTransitionManager__proto__.ready = function ready () {\n  if (this.detachQueue.length) { detachImmediate(this); }\n};\n\nTransitionManager__proto__.remove = function remove (transition) {\n  var list = transition.isIntro ? this.intros : this.outros;\n  removeFromArray(list, transition);\n  check(this);\n};\n\nTransitionManager__proto__.start = function start () {\n  this.started = true;\n  this.children.forEach(function (c) { return c.start(); });\n  this.intros.concat(this.outros).forEach(function (t) { return t.start(); });\n  check(this);\n};\n\nfunction check(tm) {\n  if (!tm.started || tm.outros.length || tm.outroChildren) { return; }\n\n  // If all outros are complete, and we haven't already done this,\n  // we notify the parent if there is one, otherwise\n  // start detaching nodes\n  if (!tm.outrosComplete) {\n    tm.outrosComplete = true;\n\n    if (tm.parent) { tm.parent.decrementOutros(tm); }\n\n    if (allOutrosComplete(tm)) {\n      tm.detachNodes();\n    }\n  }\n\n  // Once everything is done, we can notify parent transition\n  // manager and call the callback\n  if (!tm.intros.length && !tm.totalChildren) {\n    if (isFunction(tm.callback)) {\n      tm.callback();\n    }\n\n    if (tm.parent && !tm.notifiedTotal) {\n      tm.notifiedTotal = true;\n      tm.parent.decrementTotal();\n    }\n  }\n}\n\nfunction allOutrosComplete(manager) {\n  return !manager || (manager.outrosComplete && allOutrosComplete(manager.parent));\n}\n\n// check through the detach queue to see if a node is up or downstream from a\n// transition and if not, go ahead and detach it\nfunction detachImmediate(manager) {\n  var queue = manager.detachQueue;\n  var outros = collectAllOutros(manager);\n\n  if (!outros.length) {\n    manager.detachNodes();\n  } else {\n    var i = queue.length;\n    var j = 0;\n    var node, trans;\n    var nqueue = (manager.detachQueue = []);\n\n    start: while (i--) {\n      node = queue[i].node;\n      j = outros.length;\n      while (j--) {\n        trans = outros[j].element.node;\n        // check to see if the node is, contains, or is contained by the transitioning node\n        if (trans === node || trans.contains(node) || node.contains(trans)) {\n          nqueue.push(queue[i]);\n          continue start;\n        }\n      }\n\n      // no match, we can drop it\n      queue[i].detach();\n    }\n  }\n}\n\nfunction collectAllOutros(manager, _list) {\n  var list = _list;\n\n  // if there's no list, we're starting at the root to build one\n  if (!list) {\n    list = [];\n    var parent = manager;\n    while (parent.parent) { parent = parent.parent; }\n    return collectAllOutros(parent, list);\n  } else {\n    // grab all outros from child managers\n    var i = manager.children.length;\n    while (i--) {\n      list = collectAllOutros(manager.children[i], list);\n    }\n\n    // grab any from this manager if there are any\n    if (manager.outros.length) { list = list.concat(manager.outros); }\n\n    return list;\n  }\n}\n\nvar batch;\n\nvar runloop = {\n  active: function active() {\n    return !!batch;\n  },\n\n  start: function start() {\n    var fulfilPromise;\n    var promise = new Promise(function (f) { return (fulfilPromise = f); });\n\n    batch = {\n      previousBatch: batch,\n      transitionManager: new TransitionManager(fulfilPromise, batch && batch.transitionManager),\n      fragments: [],\n      tasks: [],\n      immediateObservers: [],\n      deferredObservers: [],\n      promise: promise\n    };\n\n    return promise;\n  },\n\n  end: function end() {\n    flushChanges();\n\n    if (!batch.previousBatch) { batch.transitionManager.start(); }\n    else { batch.transitionManager.checkStart(); }\n\n    batch = batch.previousBatch;\n  },\n\n  addFragment: function addFragment(fragment) {\n    addToArray(batch.fragments, fragment);\n  },\n\n  // TODO: come up with a better way to handle fragments that trigger their own update\n  addFragmentToRoot: function addFragmentToRoot(fragment) {\n    if (!batch) { return; }\n\n    var b = batch;\n    while (b.previousBatch) {\n      b = b.previousBatch;\n    }\n\n    addToArray(b.fragments, fragment);\n  },\n\n  addObserver: function addObserver(observer, defer) {\n    if (!batch) {\n      observer.dispatch();\n    } else {\n      addToArray(defer ? batch.deferredObservers : batch.immediateObservers, observer);\n    }\n  },\n\n  registerTransition: function registerTransition(transition) {\n    transition._manager = batch.transitionManager;\n    batch.transitionManager.add(transition);\n  },\n\n  // synchronise node detachments with transition ends\n  detachWhenReady: function detachWhenReady(thing) {\n    batch.transitionManager.detachQueue.push(thing);\n  },\n\n  scheduleTask: function scheduleTask(task, postRender) {\n    var _batch;\n\n    if (!batch) {\n      task();\n    } else {\n      _batch = batch;\n      while (postRender && _batch.previousBatch) {\n        // this can't happen until the DOM has been fully updated\n        // otherwise in some situations (with components inside elements)\n        // transitions and decorators will initialise prematurely\n        _batch = _batch.previousBatch;\n      }\n\n      _batch.tasks.push(task);\n    }\n  },\n\n  promise: function promise() {\n    if (!batch) { return Promise.resolve(); }\n\n    var target = batch;\n    while (target.previousBatch) {\n      target = target.previousBatch;\n    }\n\n    return target.promise || Promise.resolve();\n  }\n};\n\nfunction dispatch(observer) {\n  observer.dispatch();\n}\n\nfunction flushChanges() {\n  var which = batch.immediateObservers;\n  batch.immediateObservers = [];\n  which.forEach(dispatch);\n\n  // Now that changes have been fully propagated, we can update the DOM\n  // and complete other tasks\n  var i = batch.fragments.length;\n  var fragment;\n\n  which = batch.fragments;\n  batch.fragments = [];\n\n  while (i--) {\n    fragment = which[i];\n    fragment.update();\n  }\n\n  batch.transitionManager.ready();\n\n  which = batch.deferredObservers;\n  batch.deferredObservers = [];\n  which.forEach(dispatch);\n\n  var tasks = batch.tasks;\n  batch.tasks = [];\n\n  for (i = 0; i < tasks.length; i += 1) {\n    tasks[i]();\n  }\n\n  // If updating the view caused some model blowback - e.g. a triple\n  // containing <option> elements caused the binding on the <select>\n  // to update - then we start over\n  if (\n    batch.fragments.length ||\n    batch.immediateObservers.length ||\n    batch.deferredObservers.length ||\n    batch.tasks.length\n  )\n    { return flushChanges(); }\n}\n\n// TODO what happens if a transition is aborted?\n\nvar tickers = [];\nvar running = false;\n\nfunction tick() {\n  runloop.start();\n\n  var now = performance.now();\n\n  var i;\n  var ticker;\n\n  for (i = 0; i < tickers.length; i += 1) {\n    ticker = tickers[i];\n\n    if (!ticker.tick(now)) {\n      // ticker is complete, remove it from the stack, and decrement i so we don't miss one\n      tickers.splice(i--, 1);\n    }\n  }\n\n  runloop.end();\n\n  if (tickers.length) {\n    requestAnimationFrame(tick);\n  } else {\n    running = false;\n  }\n}\n\nvar Ticker = function Ticker(options) {\n  this.duration = options.duration;\n  this.step = options.step;\n  this.complete = options.complete;\n  this.easing = options.easing;\n\n  this.start = performance.now();\n  this.end = this.start + this.duration;\n\n  this.running = true;\n\n  tickers.push(this);\n  if (!running) { requestAnimationFrame(tick); }\n};\nvar Ticker__proto__ = Ticker.prototype;\n\nTicker__proto__.tick = function tick (now) {\n  if (!this.running) { return false; }\n\n  if (now > this.end) {\n    if (this.step) { this.step(1); }\n    if (this.complete) { this.complete(1); }\n\n    return false;\n  }\n\n  var elapsed = now - this.start;\n  var eased = this.easing(elapsed / this.duration);\n\n  if (this.step) { this.step(eased); }\n\n  return true;\n};\n\nTicker__proto__.stop = function stop () {\n  if (this.abort) { this.abort(); }\n  this.running = false;\n};\n\nvar prefixers = {};\n\n// TODO this is legacy. sooner we can replace the old adaptor API the better\n/* istanbul ignore next */\nfunction prefixKeypath(obj, prefix) {\n  var prefixed = {};\n\n  if (!prefix) {\n    return obj;\n  }\n\n  prefix += '.';\n\n  for (var key in obj) {\n    if (hasOwn(obj, key)) {\n      prefixed[prefix + key] = obj[key];\n    }\n  }\n\n  return prefixed;\n}\n\nfunction getPrefixer(rootKeypath) {\n  var rootDot;\n\n  if (!prefixers[rootKeypath]) {\n    rootDot = rootKeypath ? rootKeypath + '.' : '';\n\n    /* istanbul ignore next */\n    prefixers[rootKeypath] = function(relativeKeypath, value) {\n      var obj;\n\n      if (isString(relativeKeypath)) {\n        obj = {};\n        obj[rootDot + relativeKeypath] = value;\n        return obj;\n      }\n\n      if (isObjectType(relativeKeypath)) {\n        // 'relativeKeypath' is in fact a hash, not a keypath\n        return rootDot ? prefixKeypath(relativeKeypath, rootKeypath) : relativeKeypath;\n      }\n    };\n  }\n\n  return prefixers[rootKeypath];\n}\n\nvar shared$1 = {};\n\nvar Model = (function (ModelBase) {\n  function Model(parent, key) {\n    ModelBase.call(this, parent);\n\n    this.ticker = null;\n\n    if (parent) {\n      this.key = unescapeKey(key);\n      this.isReadonly = parent.isReadonly;\n\n      if (parent.value) {\n        this.value = parent.value[this.key];\n        if (isArray(this.value)) { this.length = this.value.length; }\n        this.adapt();\n      }\n    }\n  }\n\n  if ( ModelBase ) Model.__proto__ = ModelBase;\n  var Model__proto__ = Model.prototype = Object.create( ModelBase && ModelBase.prototype );\n  Model__proto__.constructor = Model;\n\n  Model__proto__.adapt = function adapt () {\n    var this$1 = this;\n\n    var adaptors = this.root.adaptors;\n    var len = adaptors.length;\n\n    this.rewrap = false;\n\n    // Exit early if no adaptors\n    if (len === 0) { return; }\n\n    var value = this.wrapper\n      ? 'newWrapperValue' in this\n        ? this.newWrapperValue\n        : this.wrapperValue\n      : this.value;\n\n    // TODO remove this legacy nonsense\n    var ractive = this.root.ractive;\n    var keypath = this.getKeypath();\n\n    // tear previous adaptor down if present\n    if (this.wrapper) {\n      var shouldTeardown =\n        this.wrapperValue === value\n          ? false\n          : !this.wrapper.reset || this.wrapper.reset(value) === false;\n\n      if (shouldTeardown) {\n        this.wrapper.teardown();\n        delete this.wrapper;\n        delete this.wrapperValue;\n        delete this.newWrapperValue;\n\n        // don't branch for undefined values\n        if (this.value !== undefined) {\n          var parentValue = this.parent.value || this.parent.createBranch(this.key);\n          if (parentValue[this.key] !== value) { parentValue[this.key] = value; }\n          this.value = value;\n        }\n      } else {\n        delete this.newWrapperValue;\n        this.value = this.wrapper.get();\n        return;\n      }\n    }\n\n    var i;\n\n    for (i = 0; i < len; i += 1) {\n      var adaptor = adaptors[i];\n      if (adaptor.filter(value, keypath, ractive)) {\n        this$1.wrapper = adaptor.wrap(ractive, value, keypath, getPrefixer(keypath));\n        this$1.wrapperValue = value;\n        this$1.wrapper.__model = this$1; // massive temporary hack to enable array adaptor\n\n        this$1.value = this$1.wrapper.get();\n\n        break;\n      }\n    }\n  };\n\n  Model__proto__.animate = function animate (from, to, options, interpolator) {\n    var this$1 = this;\n\n    if (this.ticker) { this.ticker.stop(); }\n\n    var fulfilPromise;\n    var promise = new Promise(function (fulfil) { return (fulfilPromise = fulfil); });\n\n    this.ticker = new Ticker({\n      duration: options.duration,\n      easing: options.easing,\n      step: function (t) {\n        var value = interpolator(t);\n        this$1.applyValue(value);\n        if (options.step) { options.step(t, value); }\n      },\n      complete: function () {\n        this$1.applyValue(to);\n        if (options.complete) { options.complete(to); }\n\n        this$1.ticker = null;\n        fulfilPromise(to);\n      }\n    });\n\n    promise.stop = this.ticker.stop;\n    return promise;\n  };\n\n  Model__proto__.applyValue = function applyValue (value, notify) {\n    if ( notify === void 0 ) notify = true;\n\n    if (isEqual(value, this.value)) { return; }\n    if (this.boundValue) { this.boundValue = null; }\n\n    if (this.parent.wrapper && this.parent.wrapper.set) {\n      this.parent.wrapper.set(this.key, value);\n      this.parent.value = this.parent.wrapper.get();\n\n      this.value = this.parent.value[this.key];\n      if (this.wrapper) { this.newWrapperValue = this.value; }\n      this.adapt();\n    } else if (this.wrapper) {\n      this.newWrapperValue = value;\n      this.adapt();\n    } else {\n      var parentValue = this.parent.value || this.parent.createBranch(this.key);\n      if (isObjectLike(parentValue)) {\n        parentValue[this.key] = value;\n      } else {\n        warnIfDebug((\"Attempted to set a property of a non-object '\" + (this.getKeypath()) + \"'\"));\n        return;\n      }\n\n      this.value = value;\n      this.adapt();\n    }\n\n    if (this.dataModel || (value && value.viewmodel && value.viewmodel.isRoot)) {\n      checkDataLink(this, value);\n    }\n\n    // keep track of array stuff\n    if (isArray(value)) {\n      this.length = value.length;\n      this.isArray = true;\n    } else {\n      this.isArray = false;\n    }\n\n    // notify dependants\n    this.links.forEach(handleChange);\n    this.children.forEach(mark);\n    this.deps.forEach(handleChange);\n\n    if (notify) { this.notifyUpstream(); }\n\n    if (this.parent.isArray) {\n      if (this.key === 'length') { this.parent.length = value; }\n      else { this.parent.joinKey('length').mark(); }\n    }\n  };\n\n  Model__proto__.compute = function compute (key, computed) {\n    var registry = this.computed || (this.computed = {});\n\n    if (registry[key]) {\n      registry[key].signature = getComputationSignature(this.root.ractive, key, computed);\n      registry[key].mark();\n    } else {\n      registry[key] = new shared$1.Computation(\n        this,\n        getComputationSignature(this.root.ractive, key, computed),\n        key\n      );\n    }\n\n    return registry[key];\n  };\n\n  Model__proto__.createBranch = function createBranch (key) {\n    var branch = isNumeric(key) ? [] : {};\n    this.applyValue(branch, false);\n\n    return branch;\n  };\n\n  Model__proto__.get = function get (shouldCapture, opts) {\n    if (this._link) { return this._link.get(shouldCapture, opts); }\n    if (shouldCapture) { capture(this); }\n    // if capturing, this value needs to be unwrapped because it's for external use\n    if (opts && opts.virtual) { return this.getVirtual(false); }\n    return maybeBind(\n      this,\n      (opts && 'unwrap' in opts ? opts.unwrap !== false : shouldCapture) && this.wrapper\n        ? this.wrapperValue\n        : this.value,\n      !opts || opts.shouldBind !== false\n    );\n  };\n\n  Model__proto__.joinKey = function joinKey (key, opts) {\n    var this$1 = this;\n\n    if (this._link) {\n      if (opts && opts.lastLink !== false && (isUndefined(key) || key === '')) { return this; }\n      return this._link.joinKey(key);\n    }\n\n    if (isUndefined(key) || key === '') { return this; }\n\n    var child;\n    if (hasOwn(this.childByKey, key)) { child = this.childByKey[key]; }\n    else { child = this.computed && this.computed[key]; }\n\n    if (!child) {\n      var computed;\n      if (this.isRoot && this.ractive && (computed = this.ractive.computed[key])) {\n        child = this.compute(key, computed);\n      } else if (!this.isRoot && this.root.ractive) {\n        var registry = this.root.ractive.computed;\n        for (var k in registry) {\n          computed = registry[k];\n          if (computed.pattern && computed.pattern.test(this$1.getKeypath() + '.' + key)) {\n            child = this$1.compute(key, computed);\n          }\n        }\n      }\n    }\n\n    if (!child) {\n      child = new Model(this, key);\n      this.children.push(child);\n      this.childByKey[key] = child;\n\n      if (key === 'data') {\n        var val = this.retrieve();\n        if (val && val.viewmodel && val.viewmodel.isRoot) {\n          child.link(val.viewmodel, 'data');\n          this.dataModel = val;\n        }\n      }\n    }\n\n    if (child._link && (!opts || opts.lastLink !== false)) { return child._link; }\n\n    return child;\n  };\n\n  Model__proto__.mark = function mark$1 (force) {\n    if (this._link) { return this._link.mark(force); }\n\n    var old = this.value;\n    var value = this.retrieve();\n\n    if (this.dataModel || (value && value.viewmodel && value.viewmodel.isRoot)) {\n      checkDataLink(this, value);\n    }\n\n    if (force || !isEqual(value, old)) {\n      this.value = value;\n      if (this.boundValue) { this.boundValue = null; }\n\n      // make sure the wrapper stays in sync\n      if (old !== value || this.rewrap) {\n        if (this.wrapper) { this.newWrapperValue = value; }\n        this.adapt();\n      }\n\n      // keep track of array stuff\n      if (isArray(value)) {\n        this.length = value.length;\n        this.isArray = true;\n      } else {\n        this.isArray = false;\n      }\n\n      this.children.forEach(force ? markForce : mark);\n      this.links.forEach(marked);\n\n      this.deps.forEach(handleChange);\n    }\n  };\n\n  Model__proto__.merge = function merge (array, comparator) {\n    var newIndices = buildNewIndices(\n      this.value === array ? recreateArray(this) : this.value,\n      array,\n      comparator\n    );\n    this.parent.value[this.key] = array;\n    this.shuffle(newIndices, true);\n  };\n\n  Model__proto__.retrieve = function retrieve () {\n    return this.parent.value ? this.parent.value[this.key] : undefined;\n  };\n\n  Model__proto__.set = function set (value) {\n    if (this.ticker) { this.ticker.stop(); }\n    this.applyValue(value);\n  };\n\n  Model__proto__.shuffle = function shuffle$2 (newIndices, unsafe) {\n    shuffle(this, newIndices, false, unsafe);\n  };\n\n  Model__proto__.source = function source () {\n    return this;\n  };\n\n  Model__proto__.teardown = function teardown$4 () {\n    var this$1 = this;\n\n    if (this._link) {\n      this._link.teardown();\n      this._link = null;\n    }\n    this.children.forEach(teardown);\n    if (this.wrapper) { this.wrapper.teardown(); }\n    if (this.computed) { keys(this.computed).forEach(function (k) { return this$1.computed[k].teardown(); }); }\n  };\n\n  return Model;\n}(ModelBase));\n\nfunction recreateArray(model) {\n  var array = [];\n\n  for (var i = 0; i < model.length; i++) {\n    array[i] = (model.childByKey[i] || {}).value;\n  }\n\n  return array;\n}\n\n/* global global */\nvar data = {};\n\nvar SharedModel = (function (Model) {\n  function SharedModel(value, name, ractive) {\n    Model.call(this, null, (\"@\" + name));\n    this.key = \"@\" + name;\n    this.value = value;\n    this.isRoot = true;\n    this.root = this;\n    this.adaptors = [];\n    this.ractive = ractive;\n  }\n\n  if ( Model ) SharedModel.__proto__ = Model;\n  var SharedModel__proto__ = SharedModel.prototype = Object.create( Model && Model.prototype );\n  SharedModel__proto__.constructor = SharedModel;\n\n  SharedModel__proto__.getKeypath = function getKeypath () {\n    return this.key;\n  };\n\n  SharedModel__proto__.retrieve = function retrieve () {\n    return this.value;\n  };\n\n  return SharedModel;\n}(Model));\n\nvar SharedModel$1 = new SharedModel(data, 'shared');\n\nvar GlobalModel = new SharedModel(base, 'global');\n\nfunction findContext(fragment) {\n  var frag = fragment;\n  while (frag && !frag.context && !frag.aliases) { frag = frag.parent; }\n  return frag;\n}\n\nfunction resolveReference(fragment, ref) {\n  var initialFragment = fragment;\n  // current context ref\n  if (ref === '.') { return fragment.findContext(); }\n\n  // ancestor references\n  if (ref[0] === '~') { return fragment.ractive.viewmodel.joinAll(splitKeypath(ref.slice(2))); }\n\n  // scoped references\n  if (ref[0] === '.' || ref[0] === '^') {\n    var frag = fragment;\n    var parts = ref.split('/');\n    var explicitContext = parts[0] === '^^';\n\n    // find nearest context node\n    while (frag && !frag.context) {\n      frag = up(frag);\n    }\n    var context$1 = frag && frag.context;\n\n    // walk up the context chain\n    while (frag && parts[0] === '^^') {\n      parts.shift();\n\n      // the current fragment should always be a context,\n      // and if it happens to be an iteration, jump above the each block\n      if (frag.isIteration) {\n        frag = frag.parent.parent;\n      } else {\n        // otherwise jump above the current fragment\n        frag = up(frag);\n      }\n\n      // walk to the next contexted fragment\n      while (frag && !frag.context) {\n        frag = up(frag);\n      }\n      context$1 = frag && frag.context;\n    }\n\n    if (!context$1 && explicitContext) {\n      throw new Error(\n        (\"Invalid context parent reference ('\" + ref + \"'). There is not context at that level.\")\n      );\n    }\n\n    // walk up the context path\n    while (parts[0] === '.' || parts[0] === '..') {\n      var part = parts.shift();\n\n      if (part === '..') {\n        context$1 = context$1.parent;\n      }\n    }\n\n    ref = parts.join('/');\n\n    // special case - `{{.foo}}` means the same as `{{./foo}}`\n    if (ref[0] === '.') { ref = ref.slice(1); }\n    return context$1.joinAll(splitKeypath(ref));\n  }\n\n  var keys$$1 = splitKeypath(ref);\n  if (!keys$$1.length) { return; }\n  var base = keys$$1.shift();\n\n  // special refs\n  if (base[0] === '@') {\n    // shorthand from outside the template\n    // @this referring to local ractive instance\n    if (base === '@this' || base === '@') {\n      return fragment.ractive.viewmodel.getRactiveModel().joinAll(keys$$1);\n    } else if (base === '@index' || base === '@key') {\n      // @index or @key referring to the nearest repeating index or key\n      if (keys$$1.length) { badReference(base); }\n      var repeater = findIter(fragment);\n      return repeater && repeater[(\"get\" + (base[1] === 'i' ? 'Index' : 'Key'))]();\n    } else if (base === '@last') {\n      var repeater$1 = findIter(fragment);\n      return repeater$1 && repeater$1.parent.getLast();\n    } else if (base === '@global') {\n      // @global referring to window or global\n      return GlobalModel.joinAll(keys$$1);\n    } else if (base === '@shared') {\n      // @global referring to window or global\n      return SharedModel$1.joinAll(keys$$1);\n    } else if (base === '@keypath' || base === '@rootpath') {\n      // @keypath or @rootpath, the current keypath string\n      var root = ref[1] === 'r' ? fragment.ractive.root : null;\n      var f = fragment;\n\n      while (\n        f &&\n        (!f.context || (f.isRoot && f.ractive.component && (root || !f.ractive.isolated)))\n      ) {\n        f = f.isRoot ? f.componentParent : f.parent;\n      }\n\n      return f.getKeypath(root);\n    } else if (base === '@context') {\n      return new SharedModel(fragment.getContext(), 'context').joinAll(keys$$1);\n    } else if (base === '@local') {\n      // @context-local data\n      return fragment.getContext()._data.joinAll(keys$$1);\n    } else if (base === '@style') {\n      // @style shared model\n      return fragment.ractive.constructor._cssModel.joinAll(keys$$1);\n    } else if (base === '@helpers') {\n      // @helpers instance model\n      return fragment.ractive.viewmodel.getHelpers().joinAll(keys$$1);\n    } else if (base === '@macro') {\n      var handle = findMacro(fragment);\n      if (handle) { return new SharedModel(handle, 'macro').joinAll(keys$$1); }\n      else { return; }\n    } else {\n      // nope\n      throw new Error((\"Invalid special reference '\" + base + \"'\"));\n    }\n  }\n\n  // helpers\n  if (base && !keys$$1.length) {\n    var helpers = fragment.ractive.viewmodel.getHelpers();\n    if (helpers.has(base)) { return helpers.joinKey(base); }\n  }\n\n  var context = findContext(fragment);\n\n  // check immediate context for a match\n  if (context) {\n    if (context.context) {\n      context = context.context;\n    } else {\n      // alias block, so get next full context for later\n      context = fragment.findContext();\n    }\n  } else {\n    context = fragment.findContext();\n  }\n\n  // walk up the fragment hierarchy looking for a matching ref, alias, or key in a context\n  var createMapping = false;\n  var shouldWarn = fragment.ractive.warnAboutAmbiguity;\n  var crossed = 0;\n  var model;\n\n  while (fragment) {\n    // repeated fragments\n    if (fragment.isIteration) {\n      if (base === fragment.parent.keyRef) {\n        model = fragment.getKey();\n      } else if (base === fragment.parent.indexRef) {\n        model = fragment.getIndex();\n      }\n\n      if (model && keys$$1.length) { badReference(base); }\n    }\n\n    // alias node or iteration\n    if (!model && fragment.aliases && hasOwn(fragment.aliases, base)) {\n      model = fragment.aliases[base];\n    }\n\n    // check fragment context to see if it has the key we need\n    if (!model && fragment.context && fragment.context.has(base)) {\n      model = fragment.context.joinKey(base);\n\n      // this is an implicit mapping\n      if (createMapping) {\n        if (shouldWarn)\n          { warnIfDebug(\n            (\"'\" + ref + \"' resolved but is ambiguous and will create a mapping to a parent component.\")\n          ); }\n      } else if (shouldWarn && crossed) { warnIfDebug((\"'\" + ref + \"' resolved but is ambiguous.\")); }\n    }\n\n    if (model) {\n      if (createMapping) {\n        model = initialFragment.ractive.viewmodel.createLink(base, model, base, { implicit: true });\n      }\n\n      if (keys$$1.length > 0 && isFunction(model.joinAll)) {\n        model = model.joinAll(keys$$1);\n      }\n\n      return model;\n    }\n\n    // don't consider alias blocks when checking for ambiguity\n    if (fragment.context && !fragment.aliases) { crossed = 1; }\n\n    if (\n      !fragment.ractive.isolated &&\n      !(fragment.owner && fragment.owner.containerFragment) &&\n      (fragment.componentParent || (!fragment.parent && fragment.ractive.component))\n    ) {\n      // ascend through component boundary\n      fragment = fragment.componentParent || fragment.ractive.component.up;\n      createMapping = true;\n    } else {\n      fragment = fragment.parent;\n    }\n  }\n\n  // if enabled, check the instance for a match\n  var instance = initialFragment.ractive;\n  if (instance.resolveInstanceMembers && base !== 'data' && base in instance) {\n    return instance.viewmodel\n      .getRactiveModel()\n      .joinKey(base)\n      .joinAll(keys$$1);\n  }\n\n  if (shouldWarn) {\n    warnIfDebug((\"'\" + ref + \"' is ambiguous and did not resolve.\"));\n  }\n\n  // didn't find anything, so go ahead and create the key on the local model\n  return context.joinKey(base).joinAll(keys$$1);\n}\n\nfunction up(fragment) {\n  return (\n    fragment &&\n    ((!fragment.ractive.isolated &&\n      !(fragment.owner && fragment.owner.containerFragment) &&\n      (fragment.componentParent || (!fragment.parent && fragment.ractive.component))) ||\n      fragment.parent)\n  );\n}\n\nfunction findIter(start) {\n  var fragment = start;\n  var next;\n  while (!fragment.isIteration && (next = up(fragment))) {\n    fragment = next;\n  }\n\n  return fragment.isIteration && fragment;\n}\n\nfunction findMacro(start) {\n  var fragment = start;\n  while (fragment) {\n    if (fragment.owner.handle) { return fragment.owner.handle; }\n    fragment = up(fragment);\n  }\n}\n\nfunction badReference(key) {\n  throw new Error((\"An index or key reference (\" + key + \") cannot have child properties\"));\n}\n\nvar extern = {};\n\nfunction getRactiveContext(ractive) {\n  var assigns = [], len = arguments.length - 1;\n  while ( len-- > 0 ) assigns[ len ] = arguments[ len + 1 ];\n\n  var fragment =\n    ractive.fragment ||\n    ractive._fakeFragment ||\n    (ractive._fakeFragment = new FakeFragment(ractive));\n  return fragment.getContext.apply(fragment, assigns);\n}\n\nfunction getContext() {\n  var assigns = [], len = arguments.length;\n  while ( len-- ) assigns[ len ] = arguments[ len ];\n\n  if (!this.ctx) { this.ctx = new extern.Context(this); }\n  assigns.unshift(create(this.ctx));\n  return assign.apply(null, assigns);\n}\n\nvar FakeFragment = function FakeFragment(ractive) {\n  this.ractive = ractive;\n};\n\nFakeFragment.prototype.findContext = function findContext () {\n  return this.ractive.viewmodel;\n};\nvar proto = FakeFragment.prototype;\nproto.getContext = getContext;\nproto.find = proto.findComponent = proto.findAll = proto.findAllComponents = noop;\n\nfunction findParentWithContext(fragment) {\n  var frag = fragment;\n  while (frag && !frag.context) { frag = frag.parent; }\n  if (!frag) { return fragment && fragment.ractive.fragment; }\n  else { return frag; }\n}\n\nvar keep = false;\n\nfunction set(pairs, options) {\n  var k = keep;\n\n  var deep = options && options.deep;\n  var shuffle = options && options.shuffle;\n  var promise = runloop.start();\n  if (options && 'keep' in options) { keep = options.keep; }\n\n  var i = pairs.length;\n  while (i--) {\n    var model = pairs[i][0];\n    var value = pairs[i][1];\n    var keypath = pairs[i][2];\n\n    if (!model) {\n      runloop.end();\n      throw new Error((\"Failed to set invalid keypath '\" + keypath + \"'\"));\n    }\n\n    if (deep) { deepSet(model, value); }\n    else if (shuffle) {\n      var array = value;\n      var target = model.get();\n      // shuffle target array with itself\n      if (!array) { array = target; }\n\n      // if there's not an array there yet, go ahead and set\n      if (isUndefined(target)) {\n        model.set(array);\n      } else {\n        if (!isArray(target) || !isArray(array)) {\n          runloop.end();\n          throw new Error('You cannot merge an array with a non-array');\n        }\n\n        var comparator = getComparator(shuffle);\n        model.merge(array, comparator);\n      }\n    } else { model.set(value); }\n  }\n\n  runloop.end();\n\n  keep = k;\n\n  if (pairs.length === 1) { return promise.then(function () { return pairs[0][1]; }); }\n  else { return promise; }\n}\n\nvar star = /\\*/;\nfunction gather(ractive, keypath, base, isolated) {\n  if (!base && (keypath[0] === '.' || keypath[1] === '^')) {\n    warnIfDebug(\n      \"Attempted to set a relative keypath from a non-relative context. You can use a context object to set relative keypaths.\"\n    );\n    return [];\n  }\n\n  var keys$$1 = splitKeypath(keypath);\n  var model = base || ractive.viewmodel;\n\n  if (star.test(keypath)) {\n    return model.findMatches(keys$$1);\n  } else {\n    if (model === ractive.viewmodel) {\n      // allow implicit mappings\n      if (\n        ractive.component &&\n        !ractive.isolated &&\n        !model.has(keys$$1[0]) &&\n        keypath[0] !== '@' &&\n        keypath[0] &&\n        !isolated\n      ) {\n        return [resolveReference(ractive.fragment || new FakeFragment(ractive), keypath)];\n      } else {\n        return [model.joinAll(keys$$1)];\n      }\n    } else {\n      return [model.joinAll(keys$$1)];\n    }\n  }\n}\n\nfunction build(ractive, keypath, value, isolated) {\n  var sets = [];\n\n  // set multiple keypaths in one go\n  if (isObject(keypath)) {\n    var loop = function ( k ) {\n      if (hasOwn(keypath, k)) {\n        sets.push.apply(sets, gather(ractive, k, null, isolated).map(function (m) { return [m, keypath[k], k]; }));\n      }\n    };\n\n    for (var k in keypath) loop( k );\n  } else {\n    // set a single keypath\n    sets.push.apply(sets, gather(ractive, keypath, null, isolated).map(function (m) { return [m, value, keypath]; }));\n  }\n\n  return sets;\n}\n\nvar deepOpts = { virtual: false };\nfunction deepSet(model, value) {\n  var dest = model.get(false, deepOpts);\n\n  // if dest doesn't exist, just set it\n  if (dest == null || !isObjectType(value)) { return model.set(value); }\n  if (!isObjectType(dest)) { return model.set(value); }\n\n  for (var k in value) {\n    if (hasOwn(value, k)) {\n      deepSet(model.joinKey(k), value[k]);\n    }\n  }\n}\n\nvar comparators = {};\nfunction getComparator(option) {\n  if (option === true) { return null; } // use existing arrays\n  if (isFunction(option)) { return option; }\n\n  if (isString(option)) {\n    return comparators[option] || (comparators[option] = function (thing) { return thing[option]; });\n  }\n\n  throw new Error('If supplied, options.compare must be a string, function, or true'); // TODO link to docs\n}\n\nvar errorMessage = 'Cannot add to a non-numeric value';\n\nfunction add(ractive, keypath, d, options) {\n  if (!isString(keypath) || !isNumeric(d)) {\n    throw new Error('Bad arguments');\n  }\n\n  var sets = build(ractive, keypath, d, options && options.isolated);\n\n  return set(\n    sets.map(function (pair) {\n      var model = pair[0];\n      var add = pair[1];\n      var value = model.get();\n      if (!isNumeric(add) || !isNumeric(value)) { throw new Error(errorMessage); }\n      return [model, value + add];\n    })\n  );\n}\n\nfunction Ractive$add(keypath, d, options) {\n  var num = isNumber(d) ? d : 1;\n  var opts = isObjectType(d) ? d : options;\n  return add(this, keypath, num, opts);\n}\n\nfunction immediate(value) {\n  var result = Promise.resolve(value);\n  defineProperty(result, 'stop', { value: noop });\n  return result;\n}\n\nvar linear = easing.linear;\n\nfunction getOptions(options, instance) {\n  options = options || {};\n\n  var easing$$1;\n  if (options.easing) {\n    easing$$1 = isFunction(options.easing) ? options.easing : instance.easing[options.easing];\n  }\n\n  return {\n    easing: easing$$1 || linear,\n    duration: 'duration' in options ? options.duration : 400,\n    complete: options.complete || noop,\n    step: options.step || noop,\n    interpolator: options.interpolator\n  };\n}\n\nfunction animate(ractive, model, to, options) {\n  options = getOptions(options, ractive);\n  var from = model.get();\n\n  // don't bother animating values that stay the same\n  if (isEqual(from, to)) {\n    options.complete(options.to);\n    return immediate(to);\n  }\n\n  var interpolator = interpolate(from, to, ractive, options.interpolator);\n\n  // if we can't interpolate the value, set it immediately\n  if (!interpolator) {\n    runloop.start();\n    model.set(to);\n    runloop.end();\n\n    return immediate(to);\n  }\n\n  return model.animate(from, to, options, interpolator);\n}\n\nfunction Ractive$animate(keypath, to, options) {\n  if (isObjectType(keypath)) {\n    var keys$$1 = keys(keypath);\n\n    throw new Error((\"ractive.animate(...) no longer supports objects. Instead of ractive.animate({\\n  \" + (keys$$1.map(function (key) { return (\"'\" + key + \"': \" + (keypath[key])); }).join('\\n  ')) + \"\\n}, {...}), do\\n\\n\" + (keys$$1.map(function (key) { return (\"ractive.animate('\" + key + \"', \" + (keypath[key]) + \", {...});\"); }).join('\\n')) + \"\\n\"));\n  }\n\n  return animate(this, this.viewmodel.joinAll(splitKeypath(keypath)), to, options);\n}\n\nfunction enqueue(ractive, event) {\n  if (ractive.event) {\n    ractive._eventQueue.push(ractive.event);\n  }\n\n  ractive.event = event;\n}\n\nfunction dequeue(ractive) {\n  if (ractive._eventQueue.length) {\n    ractive.event = ractive._eventQueue.pop();\n  } else {\n    ractive.event = null;\n  }\n}\n\nvar initStars = {};\nvar bubbleStars = {};\n\n// cartesian product of name parts and stars\n// adjusted appropriately for special cases\nfunction variants(name, initial) {\n  var map = initial ? initStars : bubbleStars;\n  if (map[name]) { return map[name]; }\n\n  var parts = name.split('.');\n  var result = [];\n  var base = false;\n\n  // initial events the implicit namespace of 'this'\n  if (initial) {\n    parts.unshift('this');\n    base = true;\n  }\n\n  // use max - 1 bits as a bitmap to pick a part or a *\n  // need to skip the full star case if the namespace is synthetic\n  var max = Math.pow(2, parts.length) - (initial ? 1 : 0);\n  for (var i = 0; i < max; i++) {\n    var join = [];\n    for (var j = 0; j < parts.length; j++) {\n      join.push(1 & (i >> j) ? '*' : parts[j]);\n    }\n    result.unshift(join.join('.'));\n  }\n\n  if (base) {\n    // include non-this-namespaced versions\n    if (parts.length > 2) {\n      result.push.apply(result, variants(name, false));\n    } else {\n      result.push('*');\n      result.push(name);\n    }\n  }\n\n  map[name] = result;\n  return result;\n}\n\nfunction fireEvent(ractive, eventName, context, args) {\n  if ( args === void 0 ) args = [];\n\n  if (!eventName) {\n    return;\n  }\n\n  context.name = eventName;\n  args.unshift(context);\n\n  var eventNames = ractive._nsSubs ? variants(eventName, true) : ['*', eventName];\n\n  return fireEventAs(ractive, eventNames, context, args, true);\n}\n\nfunction fireEventAs(ractive, eventNames, context, args, initialFire) {\n  if ( initialFire === void 0 ) initialFire = false;\n\n  var bubble = true;\n\n  if (initialFire || ractive._nsSubs) {\n    enqueue(ractive, context);\n\n    var i = eventNames.length;\n    while (i--) {\n      if (eventNames[i] in ractive._subs) {\n        bubble = notifySubscribers(ractive, ractive._subs[eventNames[i]], context, args) && bubble;\n      }\n    }\n\n    dequeue(ractive);\n  }\n\n  if (ractive.parent && bubble) {\n    if (initialFire && ractive.component) {\n      var fullName = ractive.component.name + '.' + eventNames[eventNames.length - 1];\n      eventNames = variants(fullName, false);\n\n      if (context && !context.component) {\n        context.component = ractive;\n      }\n    }\n\n    bubble = fireEventAs(ractive.parent, eventNames, context, args);\n  }\n\n  return bubble;\n}\n\nfunction notifySubscribers(ractive, subscribers, context, args) {\n  var originalEvent = null;\n  var stopEvent = false;\n\n  // subscribers can be modified inflight, e.g. \"once\" functionality\n  // so we need to copy to make sure everyone gets called\n  subscribers = subscribers.slice();\n\n  for (var i = 0, len = subscribers.length; i < len; i += 1) {\n    if (!subscribers[i].off && subscribers[i].handler.apply(ractive, args) === false) {\n      stopEvent = true;\n    }\n  }\n\n  if (context && stopEvent && (originalEvent = context.event)) {\n    originalEvent.preventDefault && originalEvent.preventDefault();\n    originalEvent.stopPropagation && originalEvent.stopPropagation();\n  }\n\n  return !stopEvent;\n}\n\nvar Hook = function Hook(event) {\n  this.event = event;\n  this.method = 'on' + event;\n};\n\nHook.prototype.fire = function fire (ractive, arg) {\n  var context = getRactiveContext(ractive);\n  var method = this.method;\n\n  if (ractive[method]) {\n    arg ? ractive[method](context, arg) : ractive[method](context);\n  }\n\n  fireEvent(ractive, this.event, context, arg ? [arg, ractive] : [ractive]);\n};\n\nfunction getChildQueue(queue, ractive) {\n  return queue[ractive._guid] || (queue[ractive._guid] = []);\n}\n\nfunction fire(hookQueue, ractive) {\n  var childQueue = getChildQueue(hookQueue.queue, ractive);\n\n  hookQueue.hook.fire(ractive);\n\n  // queue is \"live\" because components can end up being\n  // added while hooks fire on parents that modify data values.\n  while (childQueue.length) {\n    fire(hookQueue, childQueue.shift());\n  }\n\n  delete hookQueue.queue[ractive._guid];\n}\n\nvar HookQueue = function HookQueue(event) {\n  this.hook = new Hook(event);\n  this.inProcess = {};\n  this.queue = {};\n};\nvar HookQueue__proto__ = HookQueue.prototype;\n\nHookQueue__proto__.begin = function begin (ractive) {\n  this.inProcess[ractive._guid] = true;\n};\n\nHookQueue__proto__.end = function end (ractive) {\n  var parent = ractive.parent;\n\n  // If this is *isn't* a child of a component that's in process,\n  // it should call methods or fire at this point\n  if (!parent || !this.inProcess[parent._guid]) {\n    fire(this, ractive);\n  } else {\n    // elsewise, handoff to parent to fire when ready\n    getChildQueue(this.queue, parent).push(ractive);\n  }\n\n  delete this.inProcess[ractive._guid];\n};\n\nvar hooks = {};\n[\n  'construct',\n  'config',\n  'attachchild',\n  'detach',\n  'detachchild',\n  'insert',\n  'complete',\n  'reset',\n  'render',\n  'unrendering',\n  'unrender',\n  'teardown',\n  'destruct',\n  'update'\n].forEach(function (hook) {\n  hooks[hook] = new Hook(hook);\n});\nhooks.init = new HookQueue('init');\n\nfunction findAnchors(fragment, name) {\n  if ( name === void 0 ) name = null;\n\n  var res = [];\n\n  findAnchorsIn(fragment, name, res, fragment.ractive);\n\n  return res;\n}\n\nfunction findAnchorsIn(item, name, result, instance) {\n  if (item.isAnchor) {\n    if (!name || item.name === name) {\n      result.push(item);\n    }\n  } else if (item.items) {\n    item.items.forEach(function (i) { return findAnchorsIn(i, name, result, instance); });\n  } else if (item.iterations) {\n    item.iterations.forEach(function (i) { return findAnchorsIn(i, name, result, instance); });\n  } else if (item.fragment && (!item.component || item.fragment.ractive === instance)) {\n    findAnchorsIn(item.fragment, name, result, instance);\n  } else if (item.instance && item.instance.fragment) {\n    var anchors = [];\n    findAnchorsIn(item.instance.fragment, name, anchors, instance);\n    anchors.forEach(function (a) { return a.ractive === instance && result.push(a); });\n  }\n}\n\nfunction updateAnchors(instance, name) {\n  if ( name === void 0 ) name = null;\n\n  var anchors = findAnchors(instance.fragment, name);\n  var idxs = {};\n  var children = instance._children.byName;\n\n  anchors.forEach(function (a) {\n    var name = a.name;\n    if (!(name in idxs)) { idxs[name] = 0; }\n    var idx = idxs[name];\n    var child = (children[name] || [])[idx];\n\n    if (child && child.lastBound !== a) {\n      if (child.lastBound) { child.lastBound.removeChild(child); }\n      a.addChild(child);\n    }\n\n    idxs[name]++;\n  });\n}\n\nfunction unrenderChild(meta) {\n  if (meta.instance.fragment.rendered) {\n    meta.shouldDestroy = true;\n    meta.instance.unrender();\n  }\n  meta.instance.el = null;\n}\n\nfunction attachChild(child, options) {\n  if ( options === void 0 ) options = {};\n\n  var children = this._children;\n  var idx;\n\n  if (child.parent && child.parent !== this)\n    { throw new Error(\n      (\"Instance \" + (child._guid) + \" is already attached to a different instance \" + (child.parent._guid) + \". Please detach it from the other instance using detachChild first.\")\n    ); }\n  else if (child.parent)\n    { throw new Error((\"Instance \" + (child._guid) + \" is already attached to this instance.\")); }\n\n  var meta = {\n    instance: child,\n    ractive: this,\n    name: options.name || child.constructor.name || 'Ractive',\n    target: options.target || false,\n    bubble: bubble,\n    findNextNode: findNextNode\n  };\n  meta.nameOption = options.name;\n\n  // child is managing itself\n  if (!meta.target) {\n    meta.up = this.fragment;\n    meta.external = true;\n  } else {\n    var list;\n    if (!(list = children.byName[meta.target])) {\n      list = [];\n      this.set((\"@this.children.byName.\" + (meta.target)), list);\n    }\n    idx = options.prepend ? 0 : options.insertAt !== undefined ? options.insertAt : list.length;\n  }\n\n  child.parent = this;\n  child.root = this.root;\n  child.component = meta;\n  children.push(meta);\n\n  var promise = runloop.start();\n\n  var rm = child.viewmodel.getRactiveModel();\n  rm.joinKey('parent', { lastLink: false }).link(this.viewmodel.getRactiveModel());\n  rm.joinKey('root', { lastLink: false }).link(this.root.viewmodel.getRactiveModel());\n\n  hooks.attachchild.fire(child);\n\n  if (meta.target) {\n    unrenderChild(meta);\n    this.splice((\"@this.children.byName.\" + (meta.target)), idx, 0, meta);\n    updateAnchors(this, meta.target);\n  } else {\n    if (!child.isolated) { child.viewmodel.attached(this.fragment); }\n  }\n\n  runloop.end();\n\n  promise.ractive = child;\n  return promise.then(function () { return child; });\n}\n\nfunction bubble() {\n  runloop.addFragment(this.instance.fragment);\n}\n\nfunction findNextNode() {\n  if (this.anchor) { return this.anchor.findNextNode(); }\n}\n\nfunction compute(path, computed) {\n  this.computed[path] = computed;\n  if (isString(computed) || isFunction(computed))\n    { computed = this.computed[path] = { get: computed }; }\n\n  var keys = splitKeypath(path);\n  if (!~path.indexOf('*')) {\n    var last = keys.pop();\n    return this.viewmodel.joinAll(keys).compute(last, computed);\n  } else {\n    computed.pattern = new RegExp(\n      '^' +\n        keys\n          .map(function (k) { return k.replace(/\\*\\*/g, '(.+)').replace(/\\*/g, '((?:\\\\\\\\.|[^\\\\.])+)'); })\n          .join('\\\\.') +\n        '$'\n    );\n  }\n}\n\nfunction Ractive$compute(path, computed) {\n  var promise = runloop.start();\n  var comp = compute.call(this, path, computed);\n\n  if (comp) {\n    var keys = splitKeypath(path);\n    if (keys.length === 1 && !comp.isReadonly) {\n      comp.set(this.viewmodel.value[keys[0]]);\n    }\n\n    var first = keys.reduce(function (a, c) { return a && a.childByKey[c]; }, this.viewmodel);\n    if (first) {\n      first.rebind(comp, first, false);\n      if (first.parent) { delete first.parent.childByKey[first.key]; }\n      fireShuffleTasks();\n    }\n  }\n\n  runloop.end();\n\n  return promise;\n}\n\nfunction Ractive$detach() {\n  if (this.isDetached) {\n    return this.el;\n  }\n\n  if (this.el) {\n    removeFromArray(this.el.__ractive_instances__, this);\n  }\n\n  this.el = this.fragment.detach();\n  this.isDetached = true;\n\n  hooks.detach.fire(this);\n  return this.el;\n}\n\nfunction detachChild(child) {\n  var children = this._children;\n  var meta, index;\n\n  var i = children.length;\n  while (i--) {\n    if (children[i].instance === child) {\n      index = i;\n      meta = children[i];\n      break;\n    }\n  }\n\n  if (!meta || child.parent !== this)\n    { throw new Error((\"Instance \" + (child._guid) + \" is not attached to this instance.\")); }\n\n  var promise = runloop.start();\n\n  if (meta.anchor) { meta.anchor.removeChild(meta); }\n  if (!child.isolated) { child.viewmodel.detached(); }\n\n  children.splice(index, 1);\n  if (meta.target) {\n    this.splice(\n      (\"@this.children.byName.\" + (meta.target)),\n      children.byName[meta.target].indexOf(meta),\n      1\n    );\n    updateAnchors(this, meta.target);\n  }\n  var rm = child.viewmodel.getRactiveModel();\n  rm.joinKey('parent', { lastLink: false }).unlink();\n  rm.joinKey('root', { lastLink: false }).link(rm);\n  child.root = child;\n  child.parent = null;\n  child.component = null;\n\n  hooks.detachchild.fire(child);\n\n  runloop.end();\n\n  promise.ractive = child;\n  return promise.then(function () { return child; });\n}\n\nfunction Ractive$find(selector, options) {\n  var this$1 = this;\n  if ( options === void 0 ) options = {};\n\n  if (!this.rendered)\n    { throw new Error(\n      (\"Cannot call ractive.find('\" + selector + \"') unless instance is rendered to the DOM\")\n    ); }\n\n  var node = this.fragment.find(selector, options);\n  if (node) { return node; }\n\n  if (options.remote) {\n    for (var i = 0; i < this._children.length; i++) {\n      if (!this$1._children[i].instance.fragment.rendered) { continue; }\n      node = this$1._children[i].instance.find(selector, options);\n      if (node) { return node; }\n    }\n  }\n}\n\nfunction Ractive$findAll(selector, options) {\n  if ( options === void 0 ) options = {};\n\n  if (!this.rendered)\n    { throw new Error(\n      (\"Cannot call ractive.findAll('\" + selector + \"', ...) unless instance is rendered to the DOM\")\n    ); }\n\n  if (!isArray(options.result)) { options.result = []; }\n\n  this.fragment.findAll(selector, options);\n\n  if (options.remote) {\n    // seach non-fragment children\n    this._children.forEach(function (c) {\n      if (!c.target && c.instance.fragment && c.instance.fragment.rendered) {\n        c.instance.findAll(selector, options);\n      }\n    });\n  }\n\n  return options.result;\n}\n\nfunction Ractive$findAllComponents(selector, options) {\n  if (!options && isObjectType(selector)) {\n    options = selector;\n    selector = '';\n  }\n\n  options = options || {};\n\n  if (!isArray(options.result)) { options.result = []; }\n\n  this.fragment.findAllComponents(selector, options);\n\n  if (options.remote) {\n    // search non-fragment children\n    this._children.forEach(function (c) {\n      if (!c.target && c.instance.fragment && c.instance.fragment.rendered) {\n        if (!selector || c.name === selector) {\n          options.result.push(c.instance);\n        }\n\n        c.instance.findAllComponents(selector, options);\n      }\n    });\n  }\n\n  return options.result;\n}\n\nfunction Ractive$findComponent(selector, options) {\n  var this$1 = this;\n  if ( options === void 0 ) options = {};\n\n  if (isObjectType(selector)) {\n    options = selector;\n    selector = '';\n  }\n\n  var child = this.fragment.findComponent(selector, options);\n  if (child) { return child; }\n\n  if (options.remote) {\n    if (!selector && this._children.length) { return this._children[0].instance; }\n    for (var i = 0; i < this._children.length; i++) {\n      // skip children that are or should be in an anchor\n      if (this$1._children[i].target) { continue; }\n      if (this$1._children[i].name === selector) { return this$1._children[i].instance; }\n      child = this$1._children[i].instance.findComponent(selector, options);\n      if (child) { return child; }\n    }\n  }\n}\n\nfunction Ractive$findContainer(selector) {\n  if (this.container) {\n    if (this.container.component && this.container.component.name === selector) {\n      return this.container;\n    } else {\n      return this.container.findContainer(selector);\n    }\n  }\n\n  return null;\n}\n\nfunction Ractive$findParent(selector) {\n  if (this.parent) {\n    if (this.parent.component && this.parent.component.name === selector) {\n      return this.parent;\n    } else {\n      return this.parent.findParent(selector);\n    }\n  }\n\n  return null;\n}\n\nfunction findElement(start, orComponent, name) {\n  if ( orComponent === void 0 ) orComponent = true;\n\n  while (\n    start &&\n    (start.type !== ELEMENT || (name && start.name !== name)) &&\n    (!orComponent || (start.type !== COMPONENT && start.type !== ANCHOR))\n  ) {\n    // start is a fragment - look at the owner\n    if (start.owner) { start = start.owner; }\n    else if (start.component || start.yield)\n      // start is a component or yielder - look at the container\n      { start = start.containerFragment || start.component.up; }\n    else if (start.parent)\n      // start is an item - look at the parent\n      { start = start.parent; }\n    else if (start.up)\n      // start is an item without a parent - look at the parent fragment\n      { start = start.up; }\n    else { start = undefined; }\n  }\n\n  return start;\n}\n\n// This function takes an array, the name of a mutator method, and the\n// arguments to call that mutator method with, and returns an array that\n// maps the old indices to their new indices.\n\n// So if you had something like this...\n//\n//     array = [ 'a', 'b', 'c', 'd' ];\n//     array.push( 'e' );\n//\n// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n// have changed. If you then did this...\n//\n//     array.unshift( 'z' );\n//\n// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n// one higher to make room for the 'z'. If you removed an item, the new index\n// would be -1...\n//\n//     array.splice( 2, 2 );\n//\n// ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n//\n// This information is used to enable fast, non-destructive shuffling of list\n// sections when you do e.g. `ractive.splice( 'items', 2, 2 );\n\nfunction getNewIndices(length, methodName, args) {\n  var newIndices = [];\n\n  var spliceArguments = getSpliceEquivalent(length, methodName, args);\n\n  if (!spliceArguments) {\n    return null; // TODO support reverse and sort?\n  }\n\n  var balance = spliceArguments.length - 2 - spliceArguments[1];\n\n  var removeStart = Math.min(length, spliceArguments[0]);\n  var removeEnd = removeStart + spliceArguments[1];\n  newIndices.startIndex = removeStart;\n\n  var i;\n  for (i = 0; i < removeStart; i += 1) {\n    newIndices.push(i);\n  }\n\n  for (; i < removeEnd; i += 1) {\n    newIndices.push(-1);\n  }\n\n  for (; i < length; i += 1) {\n    newIndices.push(i + balance);\n  }\n\n  // there is a net shift for the rest of the array starting with index + balance\n  if (balance !== 0) {\n    newIndices.touchedFrom = spliceArguments[0];\n  } else {\n    newIndices.touchedFrom = length;\n  }\n\n  return newIndices;\n}\n\n// The pop, push, shift an unshift methods can all be represented\n// as an equivalent splice\nfunction getSpliceEquivalent(length, methodName, args) {\n  switch (methodName) {\n    case 'splice':\n      if (args[0] !== undefined && args[0] < 0) {\n        args[0] = length + Math.max(args[0], -length);\n      }\n\n      if (isUndefined(args[0])) { args[0] = 0; }\n\n      while (args.length < 2) {\n        args.push(length - args[0]);\n      }\n\n      if (!isNumber(args[1])) {\n        args[1] = length - args[0];\n      }\n\n      // ensure we only remove elements that exist\n      args[1] = Math.min(args[1], length - args[0]);\n\n      return args;\n\n    case 'sort':\n    case 'reverse':\n      return null;\n\n    case 'pop':\n      if (length) {\n        return [length - 1, 1];\n      }\n      return [0, 0];\n\n    case 'push':\n      return [length, 0].concat(args);\n\n    case 'shift':\n      return [0, length ? 1 : 0];\n\n    case 'unshift':\n      return [0, 0].concat(args);\n  }\n}\n\nvar arrayProto = Array.prototype;\n\nfunction makeArrayMethod(methodName) {\n  function path(keypath) {\n    var args = [], len = arguments.length - 1;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n    return model(this.viewmodel.joinAll(splitKeypath(keypath)), args);\n  }\n\n  function model(mdl, args) {\n    var array = mdl.get();\n\n    if (!isArray(array)) {\n      if (isUndefined(array)) {\n        array = [];\n        var result$1 = arrayProto[methodName].apply(array, args);\n        var promise$1 = runloop.start().then(function () { return result$1; });\n        mdl.set(array);\n        runloop.end();\n        return promise$1;\n      } else {\n        throw new Error(\n          (\"shuffle array method \" + methodName + \" called on non-array at \" + (mdl.getKeypath()))\n        );\n      }\n    }\n\n    var newIndices = getNewIndices(array.length, methodName, args);\n    var result = arrayProto[methodName].apply(array, args);\n\n    var promise = runloop.start().then(function () { return result; });\n    promise.result = result;\n\n    if (newIndices) {\n      if (mdl.shuffle) {\n        mdl.shuffle(newIndices);\n      } else {\n        // it's a computation, which don't have a shuffle, so just invalidate\n        mdl.mark();\n      }\n    } else {\n      mdl.set(result);\n    }\n\n    runloop.end();\n\n    return promise;\n  }\n\n  return { path: path, model: model };\n}\n\nfunction update$1(ractive, model, options) {\n  // if the parent is wrapped, the adaptor will need to be updated before\n  // updating on this keypath\n  if (model.parent && model.parent.wrapper) {\n    model.parent.adapt();\n  }\n\n  var promise = runloop.start();\n\n  model.mark(options && options.force);\n\n  // notify upstream of changes\n  model.notifyUpstream();\n\n  runloop.end();\n\n  hooks.update.fire(ractive, model);\n\n  return promise;\n}\n\nfunction Ractive$update(keypath, options) {\n  var opts, path;\n\n  if (isString(keypath)) {\n    path = splitKeypath(keypath);\n    opts = options;\n  } else {\n    opts = keypath;\n  }\n\n  return update$1(this, path ? this.viewmodel.joinAll(path) : this.viewmodel, opts);\n}\n\nvar modelPush = makeArrayMethod('push').model;\nvar modelPop = makeArrayMethod('pop').model;\nvar modelShift = makeArrayMethod('shift').model;\nvar modelUnshift = makeArrayMethod('unshift').model;\nvar modelSort = makeArrayMethod('sort').model;\nvar modelSplice = makeArrayMethod('splice').model;\nvar modelReverse = makeArrayMethod('reverse').model;\n\nvar localFragment = {};\n\nvar ContextData = (function (Model) {\n  function ContextData(options) {\n    Model.call(this, null, null);\n\n    this.isRoot = true;\n    this.root = this;\n    this.value = {};\n    this.ractive = options.ractive;\n    this.adaptors = [];\n    this.context = options.context;\n  }\n\n  if ( Model ) ContextData.__proto__ = Model;\n  var ContextData__proto__ = ContextData.prototype = Object.create( Model && Model.prototype );\n  ContextData__proto__.constructor = ContextData;\n\n  ContextData__proto__.getKeypath = function getKeypath () {\n    return '@context.data';\n  };\n\n  ContextData__proto__.rebound = function rebound () {};\n\n  return ContextData;\n}(Model));\n\nvar Context = function Context(fragment, element) {\n  this.fragment = fragment;\n  this.element = element || findElement(fragment);\n  this.node = this.element && this.element.node;\n  this.ractive = fragment.ractive;\n  this.root = this;\n};\nvar Context__proto__ = Context.prototype;\n\nvar prototypeAccessors = { decorators: {},_data: {} };\n\nprototypeAccessors.decorators.get = function () {\n  var items = {};\n  if (!this.element) { return items; }\n  this.element.decorators.forEach(function (d) { return (items[d.name] = d.handle); });\n  return items;\n};\n\nprototypeAccessors._data.get = function () {\n  return (\n    this.model ||\n    (this.root.model = new ContextData({\n      ractive: this.ractive,\n      context: this.root\n    }))\n  );\n};\n\n// the usual mutation suspects\nContext__proto__.add = function add (keypath, d, options) {\n  var num = isNumber(d) ? +d : 1;\n  var opts = isObjectType(d) ? d : options;\n  return set(\n    build$1(this, keypath, num).map(function (pair) {\n      var model = pair[0];\n        var val = pair[1];\n      var value = model.get();\n      if (!isNumeric(val) || !isNumeric(value)) { throw new Error('Cannot add non-numeric value'); }\n      return [model, value + val];\n    }),\n    opts\n  );\n};\n\nContext__proto__.animate = function animate$1 (keypath, value, options) {\n  var model = findModel(this, keypath).model;\n  return animate(this.ractive, model, value, options);\n};\n\nContext__proto__.find = function find (selector, opts) {\n  return this.fragment.find(selector, opts);\n};\n\nContext__proto__.findAll = function findAll (selector, opts) {\n  var result = [];\n  opts = opts || {};\n  opts.result = result;\n  this.fragment.findAll(selector, opts);\n  return result;\n};\n\nContext__proto__.findAllComponents = function findAllComponents (selector, opts) {\n  var result = [];\n  opts = opts || {};\n  opts.result = result;\n  this.fragment.findAllComponents(selector, opts);\n  return result;\n};\n\nContext__proto__.findComponent = function findComponent (selector, opts) {\n  return this.fragment.findComponent(selector, opts);\n};\n\n// get relative keypaths and values\nContext__proto__.get = function get (keypath) {\n  if (!keypath) { return this.fragment.findContext().get(true); }\n\n  var ref = findModel(this, keypath);\n    var model = ref.model;\n\n  return model ? model.get(true) : undefined;\n};\n\nContext__proto__.getParent = function getParent (component) {\n  var fragment = this.fragment;\n\n  if (!fragment.parent && component) { fragment = fragment.componentParent; }\n  else {\n    if (fragment.context) { fragment = findParentWithContext(fragment.parent); }\n    else {\n      fragment = findParentWithContext(fragment.parent);\n      if (fragment) {\n        if (!fragment.parent && component) { fragment = fragment.componentParent; }\n        else { fragment = findParentWithContext(fragment.parent); }\n      }\n    }\n  }\n\n  if (!fragment || fragment === this.fragment) { return; }\n  else { return fragment.getContext(); }\n};\n\nContext__proto__.hasListener = function hasListener (name, bubble) {\n  // if the owner is a component, start there because the nearest element\n  // may exist outside of the immediate context (yield)\n  var el = this.fragment.owner.component\n    ? this.fragment.owner\n    : this.element || this.fragment.owner;\n  var base;\n\n  do {\n    base = el.component || el;\n    if (base.template.t === ELEMENT) {\n      if (findEvent(base, name)) { return true; }\n    }\n    el = el.up && el.up.owner;\n    if (el && el.component) { el = el.component; }\n  } while (el && bubble);\n};\n\nContext__proto__.link = function link (source, dest) {\n  var there = findModel(this, source).model;\n  var here = findModel(this, dest).model;\n  var promise = runloop.start();\n  here.link(there, source);\n  runloop.end();\n  return promise;\n};\n\nContext__proto__.listen = function listen (event, handler) {\n  var el = this.element;\n  el.on(event, handler);\n  return {\n    cancel: function cancel() {\n      el.off(event, handler);\n    }\n  };\n};\n\nContext__proto__.observe = function observe (keypath, callback, options) {\n    if ( options === void 0 ) options = {};\n\n  if (isObject(keypath)) { options = callback || {}; }\n  options.fragment = this.fragment;\n  return this.ractive.observe(keypath, callback, options);\n};\n\nContext__proto__.observeOnce = function observeOnce (keypath, callback, options) {\n    if ( options === void 0 ) options = {};\n\n  if (isObject(keypath)) { options = callback || {}; }\n  options.fragment = this.fragment;\n  return this.ractive.observeOnce(keypath, callback, options);\n};\n\nContext__proto__.pop = function pop (keypath) {\n  return modelPop(findModel(this, keypath).model, []);\n};\n\nContext__proto__.push = function push (keypath) {\n    var values = [], len = arguments.length - 1;\n    while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];\n\n  return modelPush(findModel(this, keypath).model, values);\n};\n\nContext__proto__.raise = function raise (name, event) {\n    var args = [], len = arguments.length - 2;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];\n\n  var el = this.element;\n  var ev;\n\n  while (el) {\n    if (el.component) { el = el.component; }\n    ev = findEvent(el, name);\n    if (ev) {\n      return ev.fire(\n        ev.element.getContext(\n          event || {},\n          event && !('original' in event) ? { original: {} } : {}\n        ),\n        args\n      );\n    }\n\n    el = el.up && el.up.owner;\n  }\n};\n\nContext__proto__.readLink = function readLink (keypath, options) {\n  return this.ractive.readLink(this.resolve(keypath), options);\n};\n\nContext__proto__.resolve = function resolve (path, ractive) {\n  var ref = findModel(this, path);\n    var model = ref.model;\n    var instance = ref.instance;\n  return model ? model.getKeypath(ractive || instance) : path;\n};\n\nContext__proto__.reverse = function reverse (keypath) {\n  return modelReverse(findModel(this, keypath).model, []);\n};\n\nContext__proto__.set = function set$2 (keypath, value, options) {\n  return set(build$1(this, keypath, value), options);\n};\n\nContext__proto__.shift = function shift (keypath) {\n  return modelShift(findModel(this, keypath).model, []);\n};\n\nContext__proto__.splice = function splice (keypath, index, drop) {\n    var add = [], len = arguments.length - 3;\n    while ( len-- > 0 ) add[ len ] = arguments[ len + 3 ];\n\n  add.unshift(index, drop);\n  return modelSplice(findModel(this, keypath).model, add);\n};\n\nContext__proto__.sort = function sort (keypath) {\n  return modelSort(findModel(this, keypath).model, []);\n};\n\nContext__proto__.subtract = function subtract (keypath, d, options) {\n  var num = isNumber(d) ? d : 1;\n  var opts = isObjectType(d) ? d : options;\n  return set(\n    build$1(this, keypath, num).map(function (pair) {\n      var model = pair[0];\n        var val = pair[1];\n      var value = model.get();\n      if (!isNumeric(val) || !isNumeric(value)) { throw new Error('Cannot add non-numeric value'); }\n      return [model, value - val];\n    }),\n    opts\n  );\n};\n\nContext__proto__.toggle = function toggle (keypath, options) {\n  var ref = findModel(this, keypath);\n    var model = ref.model;\n  return set([[model, !model.get()]], options);\n};\n\nContext__proto__.unlink = function unlink (dest) {\n  var here = findModel(this, dest).model;\n  var promise = runloop.start();\n  if (here.owner && here.owner._link) { here.owner.unlink(); }\n  runloop.end();\n  return promise;\n};\n\nContext__proto__.unlisten = function unlisten (event, handler) {\n  this.element.off(event, handler);\n};\n\nContext__proto__.unshift = function unshift (keypath) {\n    var add = [], len = arguments.length - 1;\n    while ( len-- > 0 ) add[ len ] = arguments[ len + 1 ];\n\n  return modelUnshift(findModel(this, keypath).model, add);\n};\n\nContext__proto__.update = function update (keypath, options) {\n  return update$1(this.ractive, findModel(this, keypath).model, options);\n};\n\nContext__proto__.updateModel = function updateModel (keypath, cascade) {\n  var ref = findModel(this, keypath);\n    var model = ref.model;\n  var promise = runloop.start();\n  model.updateFromBindings(cascade);\n  runloop.end();\n  return promise;\n};\n\n// two-way binding related helpers\nContext__proto__.isBound = function isBound () {\n  var ref = this.getBindingModel(this);\n    var model = ref.model;\n  return !!model;\n};\n\nContext__proto__.getBindingPath = function getBindingPath (ractive) {\n  var ref = this.getBindingModel(this);\n    var model = ref.model;\n    var instance = ref.instance;\n  if (model) { return model.getKeypath(ractive || instance); }\n};\n\nContext__proto__.getBinding = function getBinding () {\n  var ref = this.getBindingModel(this);\n    var model = ref.model;\n  if (model) { return model.get(true); }\n};\n\nContext__proto__.getBindingModel = function getBindingModel (ctx) {\n  var el = ctx.element;\n  return { model: el.binding && el.binding.model, instance: el.up.ractive };\n};\n\nContext__proto__.setBinding = function setBinding (value) {\n  var ref = this.getBindingModel(this);\n    var model = ref.model;\n  return set([[model, value]]);\n};\n\nObject.defineProperties( Context__proto__, prototypeAccessors );\n\nContext.forRactive = getRactiveContext;\n// circular deps are fun\nextern.Context = Context;\n\n// TODO: at some point perhaps this could support relative * keypaths?\nfunction build$1(ctx, keypath, value) {\n  var sets = [];\n\n  // set multiple keypaths in one go\n  if (isObject(keypath)) {\n    for (var k in keypath) {\n      if (hasOwn(keypath, k)) {\n        sets.push([findModel(ctx, k).model, keypath[k]]);\n      }\n    }\n  } else {\n    // set a single keypath\n    sets.push([findModel(ctx, keypath).model, value]);\n  }\n\n  return sets;\n}\n\nfunction findModel(ctx, path) {\n  var frag = ctx.fragment;\n\n  if (!isString(path)) {\n    return { model: frag.findContext(), instance: path };\n  }\n\n  return { model: resolveReference(frag, path), instance: frag.ractive };\n}\n\nfunction findEvent(el, name) {\n  return el.events && el.events.find && el.events.find(function (e) { return ~e.template.n.indexOf(name); });\n}\n\nfunction Ractive$fire(eventName) {\n  var args = [], len = arguments.length - 1;\n  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  var ctx;\n\n  // watch for reproxy\n  if (args[0] instanceof Context) {\n    var proto = args.shift();\n    ctx = create(proto);\n    assign(ctx, proto);\n  } else if (isObjectType(args[0]) && (args[0] === null || args[0].constructor === Object)) {\n    ctx = Context.forRactive(this, args.shift());\n  } else {\n    ctx = Context.forRactive(this);\n  }\n\n  return fireEvent(this, eventName, ctx, args);\n}\n\nfunction Ractive$get(keypath, opts) {\n  if (!isString(keypath)) { return this.viewmodel.get(true, keypath); }\n\n  var keys = splitKeypath(keypath);\n  var key = keys[0];\n\n  var model;\n\n  if (!this.viewmodel.has(key)) {\n    // if this is an inline component, we may need to create\n    // an implicit mapping\n    if (this.component && !this.isolated) {\n      model = resolveReference(this.fragment || new FakeFragment(this), key);\n    }\n  }\n\n  model = this.viewmodel.joinAll(keys);\n  return model.get(true, opts);\n}\n\nfunction getLocalContext() {\n  if (localFragment.f) { return localFragment.f.getContext(); }\n}\n\nvar query = doc && doc.querySelector;\n\nfunction getContext$1(node) {\n  if (isString(node) && query) {\n    node = query.call(document, node);\n  }\n\n  var instances;\n  if (node) {\n    if (node._ractive) {\n      return node._ractive.proxy.getContext();\n    } else if ((instances = node.__ractive_instances__)) {\n      if (instances.length === 1) { return getRactiveContext(instances[0]); }\n    } else { return getContext$1(node.parentNode); }\n  }\n}\n\nfunction getContext$2(node, options) {\n  if (!node) { return getRactiveContext(this); }\n\n  if (isString(node)) {\n    node = this.find(node, options);\n  }\n\n  return getContext$1(node);\n}\n\nvar html = 'http://www.w3.org/1999/xhtml';\nvar mathml = 'http://www.w3.org/1998/Math/MathML';\nvar svg$1 = 'http://www.w3.org/2000/svg';\nvar xlink = 'http://www.w3.org/1999/xlink';\nvar xml = 'http://www.w3.org/XML/1998/namespace';\nvar xmlns = 'http://www.w3.org/2000/xmlns';\n\nvar namespaces = { html: html, mathml: mathml, svg: svg$1, xlink: xlink, xml: xml, xmlns: xmlns };\n\nvar createElement;\nvar matches;\nvar div;\nvar methodNames;\nvar unprefixed;\nvar prefixed;\nvar i;\nvar j;\nvar makeFunction;\n\nvar customStr = isClient && 'registerElement' in doc;\nfunction wrap(is) {\n  return customStr ? is : { is: is };\n}\n\n// Test for SVG support\nif (!svg) {\n  /* istanbul ignore next */\n  createElement = function (type, ns, is) {\n    if (ns && ns !== html) {\n      throw \"This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See http://ractive.js.org/support/#svgs for more information\";\n    }\n\n    return is ? doc.createElement(type, wrap(is)) : doc.createElement(type);\n  };\n} else {\n  createElement = function (type, ns, is) {\n    if (!ns || ns === html) {\n      return is ? doc.createElement(type, wrap(is)) : doc.createElement(type);\n    }\n\n    return is ? doc.createElementNS(ns, type, wrap(is)) : doc.createElementNS(ns, type);\n  };\n}\n\nfunction createDocumentFragment() {\n  return doc.createDocumentFragment();\n}\n\nfunction getElement(input) {\n  var output;\n\n  if (!input || typeof input === 'boolean') {\n    return;\n  }\n\n  /* istanbul ignore next */\n  if (!win || !doc || !input) {\n    return null;\n  }\n\n  // We already have a DOM node - no work to do. (Duck typing alert!)\n  if (input.nodeType) {\n    return input;\n  }\n\n  // Get node from string\n  if (isString(input)) {\n    // try ID first\n    output = doc.getElementById(input);\n\n    // then as selector, if possible\n    if (!output && doc.querySelector) {\n      try {\n        output = doc.querySelector(input);\n      } catch (e) {\n        /* this space intentionally left blank */\n      }\n    }\n\n    // did it work?\n    if (output && output.nodeType) {\n      return output;\n    }\n  }\n\n  // If we've been given a collection (jQuery, Zepto etc), extract the first item\n  if (input[0] && input[0].nodeType) {\n    return input[0];\n  }\n\n  return null;\n}\n\nif (!isClient) {\n  matches = null;\n} else {\n  div = createElement('div');\n  methodNames = ['matches', 'matchesSelector'];\n\n  makeFunction = function(methodName) {\n    return function(node, selector) {\n      return node[methodName](selector);\n    };\n  };\n\n  i = methodNames.length;\n\n  while (i-- && !matches) {\n    unprefixed = methodNames[i];\n\n    if (div[unprefixed]) {\n      matches = makeFunction(unprefixed);\n    } else {\n      j = vendors.length;\n      while (j--) {\n        prefixed = vendors[i] + unprefixed.substr(0, 1).toUpperCase() + unprefixed.substring(1);\n\n        if (div[prefixed]) {\n          matches = makeFunction(prefixed);\n          break;\n        }\n      }\n    }\n  }\n\n  // IE8... and apparently phantom some?\n  /* istanbul ignore next */\n  if (!matches) {\n    matches = function(node, selector) {\n      var parentNode, i;\n\n      parentNode = node.parentNode;\n\n      if (!parentNode) {\n        // empty dummy <div>\n        div.innerHTML = '';\n\n        parentNode = div;\n        node = node.cloneNode();\n\n        div.appendChild(node);\n      }\n\n      var nodes = parentNode.querySelectorAll(selector);\n\n      i = nodes.length;\n      while (i--) {\n        if (nodes[i] === node) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  }\n}\n\nfunction detachNode(node) {\n  // stupid ie\n  // eslint-disable-next-line valid-typeof\n  if (node && typeof node.parentNode !== 'unknown' && node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n\n  return node;\n}\n\nfunction safeToStringValue(value) {\n  return value == null || (isNumber(value) && isNaN(value)) || !value.toString ? '' : '' + value;\n}\n\nfunction safeAttributeString(string) {\n  return safeToStringValue(string)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\nfunction Ractive$insert(target, anchor) {\n  if (!this.fragment.rendered) {\n    // TODO create, and link to, documentation explaining this\n    throw new Error(\n      'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.'\n    );\n  }\n\n  target = getElement(target);\n  anchor = getElement(anchor) || null;\n\n  if (!target) {\n    throw new Error('You must specify a valid target to insert into');\n  }\n\n  target.insertBefore(this.detach(), anchor);\n  this.el = target;\n\n  (target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(this);\n  this.isDetached = false;\n\n  fireInsertHook(this);\n}\n\nfunction fireInsertHook(ractive) {\n  hooks.insert.fire(ractive);\n\n  ractive.findAllComponents('*').forEach(function (child) {\n    fireInsertHook(child.instance);\n  });\n}\n\nfunction link(there, here, options) {\n  var model;\n  var target = (options && (options.ractive || options.instance)) || this;\n\n  // may need to allow a mapping to resolve implicitly\n  var sourcePath = splitKeypath(there);\n  if (!target.viewmodel.has(sourcePath[0]) && target.component) {\n    model = resolveReference(target.component.up, sourcePath[0]);\n    model = model.joinAll(sourcePath.slice(1));\n  }\n\n  var src = model || target.viewmodel.joinAll(sourcePath);\n  var dest = this.viewmodel.joinAll(splitKeypath(here), { lastLink: false });\n\n  if (isUpstream(src, dest) || isUpstream(dest, src)) {\n    throw new Error('A keypath cannot be linked to itself.');\n  }\n\n  var promise = runloop.start();\n\n  dest.link(src, (options && options.keypath) || there);\n\n  runloop.end();\n\n  return promise;\n}\n\nfunction isUpstream(check, start) {\n  var model = start;\n  while (model) {\n    if (model === check || model.owner === check) { return true; }\n    model = model.target || model.parent;\n  }\n}\n\nvar Observer = function Observer(ractive, model, callback, options) {\n  this.context = options.context || ractive;\n  this.callback = callback;\n  this.ractive = ractive;\n  this.keypath = options.keypath;\n  this.options = options;\n\n  if (model) { this.resolved(model); }\n\n  if (isFunction(options.old)) {\n    this.oldContext = create(ractive);\n    this.oldFn = options.old;\n  }\n\n  if (options.init !== false) {\n    this.dirty = true;\n    this.dispatch();\n  } else {\n    updateOld(this);\n  }\n\n  this.dirty = false;\n};\nvar Observer__proto__ = Observer.prototype;\n\nObserver__proto__.cancel = function cancel () {\n  this.cancelled = true;\n  if (this.model) {\n    this.model.unregister(this);\n  } else {\n    this.resolver.unbind();\n  }\n  removeFromArray(this.ractive._observers, this);\n};\n\nObserver__proto__.dispatch = function dispatch () {\n  if (!this.cancelled) {\n    try {\n      this.callback.call(this.context, this.newValue, this.oldValue, this.keypath);\n    } catch (err) {\n      warnIfDebug(\n        (\"Failed to execute observer callback for '\" + (this.keypath) + \"': \" + (err.message || err))\n      );\n    }\n    updateOld(this, true);\n    this.dirty = false;\n  }\n};\n\nObserver__proto__.handleChange = function handleChange () {\n    var this$1 = this;\n\n  if (!this.dirty) {\n    var newValue = this.model.get();\n    if (isEqual(newValue, this.oldValue)) { return; }\n\n    this.newValue = newValue;\n\n    if (this.options.strict && this.newValue === this.oldValue) { return; }\n\n    runloop.addObserver(this, this.options.defer);\n    this.dirty = true;\n\n    if (this.options.once) { runloop.scheduleTask(function () { return this$1.cancel(); }); }\n  } else {\n    // make sure the newValue stays updated in case this observer gets touched multiple times in one loop\n    this.newValue = this.model.get();\n  }\n};\n\nObserver__proto__.rebind = function rebind (next, previous) {\n    var this$1 = this;\n\n  next = rebindMatch(this.keypath, next, previous);\n  if (next === this.model) { return false; }\n\n  if (this.model) { this.model.unregister(this); }\n  if (next) { next.addShuffleTask(function () { return this$1.resolved(next); }); }\n};\n\nObserver__proto__.resolved = function resolved (model) {\n  this.model = model;\n\n  this.oldValue = undefined;\n  this.newValue = model.get();\n\n  model.register(this);\n};\n\nfunction updateOld(observer, fresh) {\n  var next = fresh\n    ? observer.model\n      ? observer.model.get()\n      : observer.newValue\n    : observer.newValue;\n  try {\n    observer.oldValue = observer.oldFn\n      ? observer.oldFn.call(observer.oldContext, undefined, next, observer.keypath)\n      : next;\n  } catch (err) {\n    warnIfDebug(\n      (\"Failed to execute observer oldValue callback for '\" + (this.keypath) + \"': \" + (err.message || err))\n    );\n    observer.oldValue = next;\n  }\n}\n\nfunction joinKeys() {\n  var keys = [], len = arguments.length;\n  while ( len-- ) keys[ len ] = arguments[ len ];\n\n  return keys.map(escapeKey).join('.');\n}\n\nfunction splitKeypath$1(keypath) {\n  return splitKeypath(keypath).map(unescapeKey);\n}\n\nvar star$1 = /\\*+/g;\n\nvar PatternObserver = function PatternObserver(ractive, baseModel, keys$$1, callback, options) {\n  var this$1 = this;\n\n  this.context = options.context || ractive;\n  this.ractive = ractive;\n  this.baseModel = baseModel;\n  this.keys = keys$$1;\n  this.callback = callback;\n\n  var pattern = keys$$1.join('\\\\.').replace(star$1, '(.+)');\n  var baseKeypath = (this.baseKeypath = baseModel.getKeypath(ractive));\n  this.pattern = new RegExp((\"^\" + (baseKeypath ? baseKeypath + '\\\\.' : '') + pattern + \"$\"));\n  this.recursive = keys$$1.length === 1 && keys$$1[0] === '**';\n  if (this.recursive) { this.keys = ['*']; }\n  if (options.old) {\n    this.oldContext = create(ractive);\n    this.oldFn = options.old;\n  }\n\n  this.oldValues = {};\n  this.newValues = {};\n\n  this.defer = options.defer;\n  this.once = options.once;\n  this.strict = options.strict;\n\n  this.dirty = false;\n  this.changed = [];\n  this.cache = [];\n  this.partial = false;\n  this.links = options.links;\n\n  var models = baseModel.findMatches(this.keys);\n\n  models.forEach(function (model) {\n    this$1.newValues[model.getKeypath(this$1.ractive)] = model.get();\n  });\n\n  if (options.init !== false) {\n    this.dispatch();\n  } else {\n    updateOld$1(this, this.newValues);\n  }\n\n  baseModel.registerPatternObserver(this);\n};\nvar PatternObserver__proto__ = PatternObserver.prototype;\n\nPatternObserver__proto__.cancel = function cancel () {\n  this.baseModel.unregisterPatternObserver(this);\n  removeFromArray(this.ractive._observers, this);\n};\n\nPatternObserver__proto__.dispatch = function dispatch () {\n    var this$1 = this;\n\n  var newValues = this.newValues;\n  this.newValues = {};\n  keys(newValues).forEach(function (keypath) {\n    var newValue = newValues[keypath];\n    var oldValue = this$1.oldValues[keypath];\n\n    if (this$1.strict && newValue === oldValue) { return; }\n    if (isEqual(newValue, oldValue)) { return; }\n\n    var args = [newValue, oldValue, keypath];\n    if (keypath) {\n      var wildcards = this$1.pattern.exec(keypath);\n      if (wildcards) {\n        args = args.concat(wildcards.slice(1));\n      }\n    }\n\n    try {\n      this$1.callback.apply(this$1.context, args);\n    } catch (err) {\n      warnIfDebug(\n        (\"Failed to execute pattern observer callback for '\" + (this$1.keypath) + \"': \" + (err.message || err))\n      );\n    }\n  });\n\n  updateOld$1(this, newValues, this.partial);\n\n  this.dirty = false;\n};\n\nPatternObserver__proto__.notify = function notify (keys$$1) {\n  var path = joinKeys(keys$$1);\n  if (!~this.cache.indexOf(path)) {\n    this.cache.push(path);\n    this.changed.push(keys$$1);\n  }\n};\n\nPatternObserver__proto__.shuffle = function shuffle (newIndices) {\n    var this$1 = this;\n\n  if (!isArray(this.baseModel.value)) { return; }\n\n  var max = this.baseModel.value.length;\n\n  for (var i = 0; i < newIndices.length; i++) {\n    if (newIndices[i] === -1 || newIndices[i] === i) { continue; }\n    this$1.changed.push([i]);\n  }\n\n  for (var i$1 = newIndices.touchedFrom; i$1 < max; i$1++) {\n    this$1.changed.push([i$1]);\n  }\n};\n\nPatternObserver__proto__.handleChange = function handleChange () {\n    var this$1 = this;\n\n  if (!this.dirty || this.changed.length) {\n    if (!this.dirty) { this.newValues = {}; }\n\n    if (!this.changed.length) {\n      this.baseModel.findMatches(this.keys).forEach(function (model) {\n        var keypath = model.getKeypath(this$1.ractive);\n        this$1.newValues[keypath] = model.get();\n      });\n      this.partial = false;\n    } else {\n      var count = 0;\n\n      if (this.recursive) {\n        var changed = this.changed.slice();\n        this.changed.length = 0;\n        this.dirty = true;\n        changed.forEach(function (keys$$1) {\n          var model = this$1.baseModel.joinAll(keys$$1);\n          if (model.isLink && !this$1.links) { return; }\n          count++;\n          this$1.newValues[model.getKeypath(this$1.ractive)] = model.get();\n        });\n        this.dirty = false;\n      } else {\n        var ok = this.baseModel.isRoot\n          ? this.changed.map(function (keys$$1) { return keys$$1.map(escapeKey).join('.'); })\n          : this.changed.map(function (keys$$1) { return this$1.baseKeypath + '.' + keys$$1.map(escapeKey).join('.'); });\n\n        this.baseModel.findMatches(this.keys).forEach(function (model) {\n          var keypath = model.getKeypath(this$1.ractive);\n          var check = function (k) {\n            return (\n              (k.indexOf(keypath) === 0 &&\n                (k.length === keypath.length || k[keypath.length] === '.')) ||\n              (keypath.indexOf(k) === 0 &&\n                (k.length === keypath.length || keypath[k.length] === '.'))\n            );\n          };\n\n          // is this model on a changed keypath?\n          if (ok.filter(check).length) {\n            count++;\n            this$1.newValues[keypath] = model.get();\n          }\n        });\n      }\n\n      // no valid change triggered, so bail to avoid breakage\n      if (!count) { return; }\n\n      this.partial = true;\n    }\n\n    runloop.addObserver(this, this.defer);\n    this.dirty = true;\n    this.changed.length = 0;\n    this.cache = [];\n\n    if (this.once) { this.cancel(); }\n  }\n};\n\nfunction updateOld$1(observer, vals, partial) {\n  var olds = observer.oldValues;\n\n  if (observer.oldFn) {\n    if (!partial) { observer.oldValues = {}; }\n\n    keys(vals).forEach(function (k) {\n      var args = [olds[k], vals[k], k];\n      var parts = observer.pattern.exec(k);\n      if (parts) {\n        args.push.apply(args, parts.slice(1));\n      }\n      observer.oldValues[k] = observer.oldFn.apply(observer.oldContext, args);\n    });\n  } else {\n    if (partial) {\n      keys(vals).forEach(function (k) { return (olds[k] = vals[k]); });\n    } else {\n      observer.oldValues = vals;\n    }\n  }\n}\n\nfunction negativeOne() {\n  return -1;\n}\n\nvar ArrayObserver = function ArrayObserver(ractive, model, callback, options) {\n  this.ractive = ractive;\n  this.model = model;\n  this.keypath = model.getKeypath();\n  this.callback = callback;\n  this.options = options;\n\n  this.pending = null;\n\n  model.register(this);\n\n  if (options.init !== false) {\n    this.sliced = [];\n    this.shuffle([]);\n    this.dispatch();\n  } else {\n    this.sliced = this.slice();\n  }\n};\nvar ArrayObserver__proto__ = ArrayObserver.prototype;\n\nArrayObserver__proto__.cancel = function cancel () {\n  this.model.unregister(this);\n  removeFromArray(this.ractive._observers, this);\n};\n\nArrayObserver__proto__.dispatch = function dispatch () {\n  try {\n    this.callback(this.pending);\n  } catch (err) {\n    warnIfDebug(\n      (\"Failed to execute array observer callback for '\" + (this.keypath) + \"': \" + (err.message || err))\n    );\n  }\n  this.pending = null;\n  if (this.options.once) { this.cancel(); }\n};\n\nArrayObserver__proto__.handleChange = function handleChange (path) {\n  if (this.pending) {\n    // post-shuffle\n    runloop.addObserver(this, this.options.defer);\n  } else if (!path) {\n    // entire array changed\n    this.shuffle(this.sliced.map(negativeOne));\n    this.handleChange();\n  }\n};\n\nArrayObserver__proto__.shuffle = function shuffle (newIndices) {\n    var this$1 = this;\n\n  var newValue = this.slice();\n\n  var inserted = [];\n  var deleted = [];\n  var start;\n\n  var hadIndex = {};\n\n  newIndices.forEach(function (newIndex, oldIndex) {\n    hadIndex[newIndex] = true;\n\n    if (newIndex !== oldIndex && isUndefined(start)) {\n      start = oldIndex;\n    }\n\n    if (newIndex === -1) {\n      deleted.push(this$1.sliced[oldIndex]);\n    }\n  });\n\n  if (isUndefined(start)) { start = newIndices.length; }\n\n  var len = newValue.length;\n  for (var i = 0; i < len; i += 1) {\n    if (!hadIndex[i]) { inserted.push(newValue[i]); }\n  }\n\n  this.pending = { inserted: inserted, deleted: deleted, start: start };\n  this.sliced = newValue;\n};\n\nArrayObserver__proto__.slice = function slice () {\n  var value = this.model.get();\n  return isArray(value) ? value.slice() : [];\n};\n\nfunction observe(keypath, callback, options) {\n  var this$1 = this;\n\n  var observers = [];\n  var map;\n  var opts;\n\n  if (isObject(keypath)) {\n    map = keypath;\n    opts = callback || {};\n  } else {\n    if (isFunction(keypath)) {\n      map = { '': keypath };\n      opts = callback || {};\n    } else {\n      map = {};\n      map[keypath] = callback;\n      opts = options || {};\n    }\n  }\n\n  var silent = false;\n  keys(map).forEach(function (keypath) {\n    var callback = map[keypath];\n    var caller = function() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      if (silent) { return; }\n      return callback.apply(this, args);\n    };\n\n    var keypaths = keypath.split(' ');\n    if (keypaths.length > 1) { keypaths = keypaths.filter(function (k) { return k; }); }\n\n    keypaths.forEach(function (keypath) {\n      opts.keypath = keypath;\n      var observer = createObserver(this$1, keypath, caller, opts);\n      if (observer) { observers.push(observer); }\n    });\n  });\n\n  // add observers to the Ractive instance, so they can be\n  // cancelled on ractive.teardown()\n  this._observers.push.apply(this._observers, observers);\n\n  return {\n    cancel: function () { return observers.forEach(function (o) { return o.cancel(); }); },\n    isSilenced: function () { return silent; },\n    silence: function () { return (silent = true); },\n    resume: function () { return (silent = false); }\n  };\n}\n\nfunction createObserver(ractive, keypath, callback, options) {\n  var keys$$1 = splitKeypath(keypath);\n  var wildcardIndex = keys$$1.indexOf('*');\n  if (!~wildcardIndex) { wildcardIndex = keys$$1.indexOf('**'); }\n\n  options.fragment = options.fragment || ractive.fragment;\n\n  var model;\n  if (!options.fragment) {\n    model = ractive.viewmodel.joinKey(keys$$1[0]);\n  } else {\n    // .*.whatever relative wildcard is a special case because splitkeypath doesn't handle the leading .\n    if (~keys$$1[0].indexOf('.*')) {\n      model = options.fragment.findContext();\n      wildcardIndex = 0;\n      keys$$1[0] = keys$$1[0].slice(1);\n    } else {\n      model =\n        wildcardIndex === 0\n          ? options.fragment.findContext()\n          : resolveReference(options.fragment, keys$$1[0]);\n    }\n  }\n\n  // the model may not exist key\n  if (!model) { model = ractive.viewmodel.joinKey(keys$$1[0]); }\n\n  if (!~wildcardIndex) {\n    model = model.joinAll(keys$$1.slice(1));\n    if (options.array) {\n      return new ArrayObserver(ractive, model, callback, options);\n    } else {\n      return new Observer(ractive, model, callback, options);\n    }\n  } else {\n    var double = keys$$1.indexOf('**');\n    if (~double) {\n      if (double + 1 !== keys$$1.length || ~keys$$1.indexOf('*')) {\n        warnOnceIfDebug(\n          \"Recursive observers may only specify a single '**' at the end of the path.\"\n        );\n        return;\n      }\n    }\n\n    model = model.joinAll(keys$$1.slice(1, wildcardIndex));\n\n    return new PatternObserver(ractive, model, keys$$1.slice(wildcardIndex), callback, options);\n  }\n}\n\nvar onceOptions = { init: false, once: true };\n\nfunction observeOnce(keypath, callback, options) {\n  if (isObject(keypath) || isFunction(keypath)) {\n    options = assign(callback || {}, onceOptions);\n    return this.observe(keypath, options);\n  }\n\n  options = assign(options || {}, onceOptions);\n  return this.observe(keypath, callback, options);\n}\n\nvar trim = function (str) { return str.trim(); };\n\nvar notEmptyString = function (str) { return str !== ''; };\n\nfunction Ractive$off(eventName, callback) {\n  var this$1 = this;\n\n  // if no event is specified, remove _all_ event listeners\n  if (!eventName) {\n    this._subs = {};\n  } else {\n    // Handle multiple space-separated event names\n    var eventNames = eventName\n      .split(' ')\n      .map(trim)\n      .filter(notEmptyString);\n\n    eventNames.forEach(function (event) {\n      var subs = this$1._subs[event];\n      // if given a specific callback to remove, remove only it\n      if (subs && callback) {\n        var entry = subs.find(function (s) { return s.callback === callback; });\n        if (entry) {\n          removeFromArray(subs, entry);\n          entry.off = true;\n\n          if (event.indexOf('.')) { this$1._nsSubs--; }\n        }\n      } else if (subs) {\n        // otherwise, remove all listeners for this event\n        if (event.indexOf('.')) { this$1._nsSubs -= subs.length; }\n        subs.length = 0;\n      }\n    });\n  }\n\n  return this;\n}\n\nfunction Ractive$on(eventName, callback) {\n  var this$1 = this;\n\n  // eventName may already be a map\n  var map = isObjectType(eventName) ? eventName : {};\n  // or it may be a string along with a callback\n  if (isString(eventName)) { map[eventName] = callback; }\n\n  var silent = false;\n  var events = [];\n\n  var loop = function ( k ) {\n    var callback$1 = map[k];\n    var caller = function() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      if (!silent) { return callback$1.apply(this, args); }\n    };\n    var entry = {\n      callback: callback$1,\n      handler: caller\n    };\n\n    if (hasOwn(map, k)) {\n      var names = k\n        .split(' ')\n        .map(trim)\n        .filter(notEmptyString);\n      names.forEach(function (n) {\n        (this$1._subs[n] || (this$1._subs[n] = [])).push(entry);\n        if (n.indexOf('.')) { this$1._nsSubs++; }\n        events.push([n, entry]);\n      });\n    }\n  };\n\n  for (var k in map) loop( k );\n\n  return {\n    cancel: function () { return events.forEach(function (e) { return this$1.off(e[0], e[1].callback); }); },\n    isSilenced: function () { return silent; },\n    silence: function () { return (silent = true); },\n    resume: function () { return (silent = false); }\n  };\n}\n\nfunction Ractive$once(eventName, handler) {\n  var listener = this.on(eventName, function() {\n    handler.apply(this, arguments);\n    listener.cancel();\n  });\n\n  // so we can still do listener.cancel() manually\n  return listener;\n}\n\nvar pop = makeArrayMethod('pop').path;\n\nvar push = makeArrayMethod('push').path;\n\nfunction readLink(keypath, options) {\n  if ( options === void 0 ) options = {};\n\n  var path = splitKeypath(keypath);\n\n  if (this.viewmodel.has(path[0])) {\n    var model = this.viewmodel.joinAll(path);\n\n    if (!model.isLink) { return; }\n\n    while ((model = model.target) && options.canonical !== false) {\n      if (!model.isLink) { break; }\n    }\n\n    if (model) { return { ractive: model.root.ractive, keypath: model.getKeypath() }; }\n  }\n}\n\nvar PREFIX = '/* Ractive.js component styles */';\n\n// Holds current definitions of styles.\nvar styleDefinitions = [];\n\n// Flag to tell if we need to update the CSS\nvar isDirty = false;\n\n// These only make sense on the browser. See additional setup below.\nvar styleElement = null;\nvar useCssText = null;\n\n// flag to use multiple style tags\nvar _splitTag = false;\nfunction splitTag(v) {\n  return v === undefined ? _splitTag : (_splitTag = v);\n}\n\nfunction addCSS(styleDefinition) {\n  styleDefinitions.push(styleDefinition);\n  isDirty = true;\n}\n\nfunction applyCSS(force) {\n  var styleElement = style();\n\n  // Apply only seems to make sense when we're in the DOM. Server-side renders\n  // can call toCSS to get the updated CSS.\n  if (!styleElement || (!force && !isDirty)) { return; }\n\n  if (_splitTag) {\n    styleDefinitions.forEach(function (s) {\n      var el = getStyle(s.id);\n      if (el) {\n        var css = getCSS(s.id);\n        if (useCssText) {\n          el.styleSheet.cssText !== css && (el.styleSheet.cssText = css);\n        } else {\n          el.innerHTML !== css && (el.innerHTML = css);\n        }\n      }\n    });\n  } else {\n    if (useCssText) {\n      styleElement.styleSheet.cssText = getCSS(null);\n    } else {\n      styleElement.innerHTML = getCSS(null);\n    }\n  }\n\n  isDirty = false;\n}\n\nfunction getCSS(cssIds) {\n  if (cssIds && !isArray(cssIds)) { cssIds = [cssIds]; }\n  var filteredStyleDefinitions = cssIds\n    ? styleDefinitions.filter(function (style) { return ~cssIds.indexOf(style.id); })\n    : styleDefinitions;\n\n  filteredStyleDefinitions.forEach(function (d) { return (d.applied = true); });\n\n  return filteredStyleDefinitions.reduce(\n    function (styles, style) { return (\"\" + (styles ? (styles + \"\\n\\n/* {\" + (style.id) + \"} */\\n\" + (style.styles)) : '')); },\n    PREFIX\n  );\n}\n\nfunction getStyle(id) {\n  return doc && (doc.querySelector((\"[data-ractive-css=\\\"\" + id + \"\\\"]\")) || makeStyle(id));\n}\n\nfunction makeStyle(id) {\n  if (doc) {\n    var el = doc.createElement('style');\n    el.type = 'text/css';\n    el.setAttribute('data-ractive-css', id || '');\n\n    doc.getElementsByTagName('head')[0].appendChild(el);\n\n    if (useCssText === null) { useCssText = !!el.styleSheet; }\n\n    return el;\n  }\n}\n\nfunction style() {\n  if (!styleElement) { styleElement = makeStyle(); }\n\n  return styleElement;\n}\n\nvar adaptConfigurator = {\n  extend: function (Parent, proto, options) {\n    proto.adapt = combine(proto.adapt, ensureArray(options.adapt));\n  },\n\n  init: function init() {}\n};\n\nvar remove = /\\/\\*(?:[\\s\\S]*?)\\*\\//g;\nvar escape = /url\\(\\s*(['\"])(?:\\\\[\\s\\S]|(?!\\1).)*\\1\\s*\\)|url\\((?:\\\\[\\s\\S]|[^)])*\\)|(['\"])(?:\\\\[\\s\\S]|(?!\\2).)*\\2/gi;\nvar value = /\\0(\\d+)/g;\n\n// Removes comments and strings from the given CSS to make it easier to parse.\n// Callback receives the cleaned CSS and a function which can be used to put\n// the removed strings back in place after parsing is done.\nfunction cleanCss(css, callback, additionalReplaceRules) {\n  if ( additionalReplaceRules === void 0 ) additionalReplaceRules = [];\n\n  var values = [];\n  var reconstruct = function (css) { return css.replace(value, function (match, n) { return values[n]; }); };\n  css = css.replace(escape, function (match) { return (\"\\u0000\" + (values.push(match) - 1)); }).replace(remove, '');\n\n  additionalReplaceRules.forEach(function (pattern) {\n    css = css.replace(pattern, function (match) { return (\"\\u0000\" + (values.push(match) - 1)); });\n  });\n\n  return callback(css, reconstruct);\n}\n\nvar selectorsPattern = /(?:^|\\}|\\{|\\x01)\\s*([^\\{\\}\\0\\x01]+)\\s*(?=\\{)/g;\nvar importPattern = /@import\\s*\\([^)]*\\)\\s*;?/gi;\nvar importEndPattern = /\\x01/g;\nvar keyframesDeclarationPattern = /@keyframes\\s+[^\\{\\}]+\\s*\\{(?:[^{}]+|\\{[^{}]+})*}/gi;\nvar selectorUnitPattern = /((?:(?:\\[[^\\]]+\\])|(?:[^\\s\\+\\>~:]))+)((?:::?[^\\s\\+\\>\\~\\(:]+(?:\\([^\\)]+\\))?)*\\s*[\\s\\+\\>\\~]?)\\s*/g;\nvar excludePattern = /^(?:@|\\d+%)/;\nvar dataRvcGuidPattern = /\\[data-ractive-css~=\"\\{[a-z0-9-]+\\}\"]/g;\n\nfunction trim$1(str) {\n  return str.trim();\n}\n\nfunction extractString(unit) {\n  return unit.str;\n}\n\nfunction transformSelector(selector, parent) {\n  var selectorUnits = [];\n  var match;\n\n  while ((match = selectorUnitPattern.exec(selector))) {\n    selectorUnits.push({\n      str: match[0],\n      base: match[1],\n      modifiers: match[2]\n    });\n  }\n\n  // For each simple selector within the selector, we need to create a version\n  // that a) combines with the id, and b) is inside the id\n  var base = selectorUnits.map(extractString);\n\n  var transformed = [];\n  var i = selectorUnits.length;\n\n  while (i--) {\n    var appended = base.slice();\n\n    // Pseudo-selectors should go after the attribute selector\n    var unit = selectorUnits[i];\n    appended[i] = unit.base + parent + unit.modifiers || '';\n\n    var prepended = base.slice();\n    prepended[i] = parent + ' ' + prepended[i];\n\n    transformed.push(appended.join(' '), prepended.join(' '));\n  }\n\n  return transformed.join(', ');\n}\n\nfunction transformCss(css, id) {\n  var dataAttr = \"[data-ractive-css~=\\\"{\" + id + \"}\\\"]\";\n\n  var transformed;\n\n  if (dataRvcGuidPattern.test(css)) {\n    transformed = css.replace(dataRvcGuidPattern, dataAttr);\n  } else {\n    transformed = cleanCss(\n      css,\n      function (css, reconstruct) {\n        css = css\n          .replace(importPattern, '$&\\x01')\n          .replace(selectorsPattern, function (match, $1) {\n            // don't transform at-rules and keyframe declarations\n            if (excludePattern.test($1)) { return match; }\n\n            var selectors = $1.split(',').map(trim$1);\n            var transformed =\n              selectors.map(function (selector) { return transformSelector(selector, dataAttr); }).join(', ') + ' ';\n\n            return match.replace($1, transformed);\n          })\n          .replace(importEndPattern, '');\n\n        return reconstruct(css);\n      },\n      [keyframesDeclarationPattern]\n    );\n  }\n\n  return transformed;\n}\n\nfunction s4() {\n  return Math.floor((1 + Math.random()) * 0x10000)\n    .toString(16)\n    .substring(1);\n}\n\nfunction uuid() {\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}\n\nfunction setCSSData(keypath, value, options) {\n  var opts = isObjectType(keypath) ? value : options;\n  var model = this._cssModel;\n\n  model.locked = true;\n  var promise = set(build({ viewmodel: model }, keypath, value, true), opts);\n  model.locked = false;\n\n  var cascade = runloop.start();\n  this.extensions.forEach(function (e) {\n    var model = e._cssModel;\n    model.mark();\n    model.downstreamChanged('', 1);\n  });\n  runloop.end();\n\n  applyChanges(this, !opts || opts.apply !== false);\n\n  return promise.then(function () { return cascade; });\n}\n\nfunction applyChanges(component, apply) {\n  var local = recomputeCSS(component);\n  var child = component.extensions\n    .map(function (e) { return applyChanges(e, false); })\n    .reduce(function (a, c) { return c || a; }, false);\n\n  if (apply && (local || child)) {\n    var def = component._cssDef;\n    if (!def || (def && def.applied)) { applyCSS(true); }\n  }\n\n  return local || child;\n}\n\nfunction recomputeCSS(component) {\n  var css = component.css;\n\n  if (!isFunction(css)) { return; }\n\n  var def = component._cssDef;\n  var result = evalCSS(component, css);\n  var styles = def.transform ? transformCss(result, def.id) : result;\n\n  if (def.styles === styles) { return; }\n\n  def.styles = styles;\n\n  return true;\n}\n\nvar CSSModel = (function (SharedModel) {\n  function CSSModel(component) {\n    SharedModel.call(this, component.cssData, '@style');\n    this.component = component;\n  }\n\n  if ( SharedModel ) CSSModel.__proto__ = SharedModel;\n  var CSSModel__proto__ = CSSModel.prototype = Object.create( SharedModel && SharedModel.prototype );\n  CSSModel__proto__.constructor = CSSModel;\n\n  CSSModel__proto__.downstreamChanged = function downstreamChanged (path, depth) {\n    if (this.locked) { return; }\n\n    var component = this.component;\n\n    component.extensions.forEach(function (e) {\n      var model = e._cssModel;\n      model.mark();\n      model.downstreamChanged(path, depth || 1);\n    });\n\n    if (!depth) {\n      applyChanges(component, true);\n    }\n  };\n\n  return CSSModel;\n}(SharedModel));\n\nvar hasCurly = /\\{/;\nvar cssConfigurator = {\n  name: 'css',\n\n  // Called when creating a new component definition\n  extend: function (Parent, proto, options, Child) {\n    Child._cssIds = gatherIds(Parent);\n\n    defineProperty(Child, 'cssData', {\n      configurable: true,\n      value: assign(create(Parent.cssData), options.cssData || {})\n    });\n\n    defineProperty(Child, '_cssModel', {\n      configurable: true,\n      value: new CSSModel(Child)\n    });\n\n    if (options.css) { initCSS(options, Child, proto); }\n  },\n\n  // Called when creating a new component instance\n  init: function (Parent, target, options) {\n    if (!options.css) { return; }\n\n    warnIfDebug(\"\\nThe css option is currently not supported on a per-instance basis and will be discarded. Instead, we recommend instantiating from a component definition with a css option.\\n\\nconst Component = Ractive.extend({\\n\\t...\\n\\tcss: '/* your css */',\\n\\t...\\n});\\n\\nconst componentInstance = new Component({ ... })\\n\\t\\t\");\n  }\n};\n\nfunction gatherIds(start) {\n  var cmp = start;\n  var ids = [];\n\n  while (cmp) {\n    if (cmp.prototype.cssId) { ids.push(cmp.prototype.cssId); }\n    cmp = cmp.Parent;\n  }\n\n  return ids;\n}\n\nfunction evalCSS(component, css) {\n  if (isString(css)) { return css; }\n\n  var cssData = component.cssData;\n  var model = component._cssModel;\n  var data = function data(path) {\n    return model.joinAll(splitKeypath(path)).get();\n  };\n  data.__proto__ = cssData;\n\n  var result = css.call(component, data);\n  return isString(result) ? result : '';\n}\n\nfunction initCSS(options, target, proto) {\n  var css =\n    options.css === true\n      ? ''\n      : isString(options.css) && !hasCurly.test(options.css)\n      ? getElement(options.css) || options.css\n      : options.css;\n  var cssProp = css;\n\n  var id = options.cssId || uuid();\n\n  if (isObjectType(css)) {\n    css = 'textContent' in css ? css.textContent : css.innerHTML;\n    cssProp = css;\n  } else if (isFunction(css)) {\n    cssProp = css;\n    css = evalCSS(target, css);\n  }\n\n  var def = {\n    transform: 'noCSSTransform' in options ? !options.noCSSTransform : !options.noCssTransform\n  };\n\n  defineProperty(target, '_cssDef', { configurable: true, value: def });\n\n  defineProperty(target, 'css', {\n    get: function get() {\n      return cssProp;\n    },\n    set: function set(next) {\n      cssProp = next;\n      var css = evalCSS(target, cssProp);\n      var styles = def.styles;\n      def.styles = def.transform ? transformCss(css, id) : css;\n      if (def.applied && styles !== def.styles) { applyCSS(true); }\n    }\n  });\n\n  def.styles = def.transform ? transformCss(css, id) : css;\n  def.id = proto.cssId = id;\n  target._cssIds.push(id);\n\n  addCSS(target._cssDef);\n}\n\nfunction validate(data) {\n  // Warn if userOptions.data is a non-POJO\n  if (data && data.constructor !== Object) {\n    if (isFunction(data)) {\n      // TODO do we need to support this in the new Ractive() case?\n    } else if (!isObjectType(data)) {\n      fatal((\"data option must be an object or a function, `\" + data + \"` is not valid\"));\n    } else {\n      warnIfDebug(\n        'If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged'\n      );\n    }\n  }\n}\n\nvar dataConfigurator = {\n  name: 'data',\n\n  extend: function (Parent, proto, options) {\n    var key;\n    var value;\n\n    // check for non-primitives, which could cause mutation-related bugs\n    if (options.data && isObject(options.data)) {\n      for (key in options.data) {\n        value = options.data[key];\n\n        if (value && isObjectType(value)) {\n          if (isObject(value) || isArray(value)) {\n            warnIfDebug(\"Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\\n\\n  // this...\\n  data: function () {\\n    return {\\n      myObject: {}\\n    };\\n  })\\n\\n  // instead of this:\\n  data: {\\n    myObject: {}\\n  }\");\n          }\n        }\n      }\n    }\n\n    proto.data = combine$1(proto.data, options.data);\n  },\n\n  init: function (Parent, ractive, options) {\n    var result = combine$1(Parent.prototype.data, options.data);\n\n    if (isFunction(result)) { result = result.call(ractive); }\n\n    // bind functions to the ractive instance at the top level,\n    // unless it's a non-POJO (in which case alarm bells should ring)\n    if (result && result.constructor === Object) {\n      for (var prop in result) {\n        if (isFunction(result[prop])) {\n          var value = result[prop];\n          result[prop] = bind(value, ractive);\n          result[prop]._r_unbound = value;\n        }\n      }\n    }\n\n    return result || {};\n  },\n\n  reset: function reset(ractive) {\n    var result = this.init(ractive.constructor, ractive, ractive.viewmodel);\n    ractive.viewmodel.root.set(result);\n    return true;\n  }\n};\n\nfunction emptyData() {\n  return {};\n}\n\nfunction combine$1(parentValue, childValue) {\n  validate(childValue);\n\n  var parentIsFn = isFunction(parentValue);\n\n  // Very important, otherwise child instance can become\n  // the default data object on Ractive or a component.\n  // then ractive.set() ends up setting on the prototype!\n  if (!childValue && !parentIsFn) {\n    // this needs to be a function so that it can still inherit parent defaults\n    childValue = emptyData;\n  }\n\n  var childIsFn = isFunction(childValue);\n\n  // Fast path, where we just need to copy properties from\n  // parent to child\n  if (!parentIsFn && !childIsFn) {\n    return fromProperties(childValue, parentValue);\n  }\n\n  return function() {\n    var child = childIsFn ? callDataFunction(childValue, this) : childValue;\n    var parent = parentIsFn ? callDataFunction(parentValue, this) : parentValue;\n\n    return fromProperties(child, parent);\n  };\n}\n\nfunction callDataFunction(fn, context) {\n  var data = fn.call(context);\n\n  if (!data) { return; }\n\n  if (!isObjectType(data)) {\n    fatal('Data function must return an object');\n  }\n\n  if (data.constructor !== Object) {\n    warnOnceIfDebug(\n      'Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged'\n    );\n  }\n\n  return data;\n}\n\nfunction fromProperties(primary, secondary) {\n  if (primary && secondary) {\n    for (var key in secondary) {\n      if (!(key in primary)) {\n        primary[key] = secondary[key];\n      }\n    }\n\n    return primary;\n  }\n\n  return primary || secondary;\n}\n\nvar templateConfigurator = {\n  name: 'template',\n\n  extend: function extend(Parent, proto, options) {\n    // only assign if exists\n    if ('template' in options) {\n      var template = options.template;\n\n      if (isFunction(template)) {\n        proto.template = template;\n      } else {\n        proto.template = parseTemplate(template, proto);\n      }\n    }\n  },\n\n  init: function init(Parent, ractive, options) {\n    // TODO because of prototypal inheritance, we might just be able to use\n    // ractive.template, and not bother passing through the Parent object.\n    // At present that breaks the test mocks' expectations\n    var template = 'template' in options ? options.template : Parent.prototype.template;\n    template = template || { v: TEMPLATE_VERSION, t: [] };\n\n    if (isFunction(template)) {\n      var fn = template;\n      template = getDynamicTemplate(ractive, fn);\n\n      ractive._config.template = {\n        fn: fn,\n        result: template\n      };\n    }\n\n    template = parseTemplate(template, ractive);\n\n    // TODO the naming of this is confusing - ractive.template refers to [...],\n    // but Component.prototype.template refers to {v:1,t:[],p:[]}...\n    // it's unnecessary, because the developer never needs to access\n    // ractive.template\n    ractive.template = template.t;\n\n    if (template.p) {\n      extendPartials(ractive.partials, template.p);\n    }\n  },\n\n  reset: function reset(ractive) {\n    var result = resetValue(ractive);\n\n    if (result) {\n      var parsed = parseTemplate(result, ractive);\n\n      ractive.template = parsed.t;\n      extendPartials(ractive.partials, parsed.p, true);\n\n      return true;\n    }\n  }\n};\n\nfunction resetValue(ractive) {\n  var initial = ractive._config.template;\n\n  // If this isn't a dynamic template, there's nothing to do\n  if (!initial || !initial.fn) {\n    return;\n  }\n\n  var result = getDynamicTemplate(ractive, initial.fn);\n\n  // TODO deep equality check to prevent unnecessary re-rendering\n  // in the case of already-parsed templates\n  if (result !== initial.result) {\n    initial.result = result;\n    return result;\n  }\n}\n\nfunction getDynamicTemplate(ractive, fn) {\n  return fn.call(ractive, {\n    fromId: parser.fromId,\n    isParsed: parser.isParsed,\n    parse: function parse(template, options) {\n      if ( options === void 0 ) options = parser.getParseOptions(ractive);\n\n      return parser.parse(template, options);\n    }\n  });\n}\n\nfunction parseTemplate(template, ractive) {\n  if (isString(template)) {\n    // parse will validate and add expression functions\n    template = parseAsString(template, ractive);\n  } else {\n    // need to validate and add exp for already parsed template\n    validate$1(template);\n    addFunctions(template);\n  }\n\n  return template;\n}\n\nfunction parseAsString(template, ractive) {\n  // ID of an element containing the template?\n  if (template[0] === '#') {\n    template = parser.fromId(template);\n  }\n\n  return parser.parseFor(template, ractive);\n}\n\nfunction validate$1(template) {\n  // Check that the template even exists\n  if (template == undefined) {\n    throw new Error((\"The template cannot be \" + template + \".\"));\n  } else if (!isNumber(template.v)) {\n    // Check the parsed template has a version at all\n    throw new Error(\n      \"The template parser was passed a non-string template, but the template doesn't have a version.  Make sure you're passing in the template you think you are.\"\n    );\n  } else if (template.v !== TEMPLATE_VERSION) {\n    // Check we're using the correct version\n    throw new Error(\n      (\"Mismatched template version (expected \" + TEMPLATE_VERSION + \", got \" + (template.v) + \") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app\")\n    );\n  }\n}\n\nfunction extendPartials(existingPartials, newPartials, overwrite) {\n  if (!newPartials) { return; }\n\n  // TODO there's an ambiguity here - we need to overwrite in the `reset()`\n  // case, but not initially...\n\n  for (var key in newPartials) {\n    if (overwrite || !hasOwn(existingPartials, key)) {\n      existingPartials[key] = newPartials[key];\n    }\n  }\n}\n\nvar registryNames = [\n  'adaptors',\n  'components',\n  'computed',\n  'decorators',\n  'easing',\n  'events',\n  'helpers',\n  'interpolators',\n  'partials',\n  'transitions'\n];\n\nvar registriesOnDefaults = ['computed', 'helpers'];\n\nvar Registry = function Registry(name, useDefaults) {\n  this.name = name;\n  this.useDefaults = useDefaults;\n};\nvar Registry__proto__ = Registry.prototype;\n\nRegistry__proto__.extend = function extend (Parent, proto, options) {\n  var parent = this.useDefaults ? Parent.defaults : Parent;\n  var target = this.useDefaults ? proto : proto.constructor;\n  this.configure(parent, target, options);\n};\n\nRegistry__proto__.init = function init () {\n  // noop\n};\n\nRegistry__proto__.configure = function configure (Parent, target, options) {\n  var name = this.name;\n  var option = options[name];\n\n  var registry = create(Parent[name]);\n\n  assign(registry, option);\n\n  target[name] = registry;\n\n  if (name === 'partials' && target[name]) {\n    keys(target[name]).forEach(function (key) {\n      addFunctions(target[name][key]);\n    });\n  }\n};\n\nRegistry__proto__.reset = function reset (ractive) {\n  var registry = ractive[this.name];\n  var changed = false;\n\n  keys(registry).forEach(function (key) {\n    var item = registry[key];\n\n    if (item._fn) {\n      if (item._fn.isOwner) {\n        registry[key] = item._fn;\n      } else {\n        delete registry[key];\n      }\n      changed = true;\n    }\n  });\n\n  return changed;\n};\n\nvar registries = registryNames.map(function (name) {\n  var putInDefaults = registriesOnDefaults.indexOf(name) > -1;\n  return new Registry(name, putInDefaults);\n});\n\nfunction wrap$1(parent, name, method) {\n  if (!/_super/.test(method)) { return method; }\n\n  function wrapper() {\n    var superMethod = getSuperMethod(wrapper._parent, name);\n    var hasSuper = '_super' in this;\n    var oldSuper = this._super;\n\n    this._super = superMethod;\n\n    var result = method.apply(this, arguments);\n\n    if (hasSuper) {\n      this._super = oldSuper;\n    } else {\n      delete this._super;\n    }\n\n    return result;\n  }\n\n  wrapper._parent = parent;\n  wrapper._method = method;\n\n  return wrapper;\n}\n\nfunction getSuperMethod(parent, name) {\n  if (name in parent) {\n    var value = parent[name];\n\n    return isFunction(value) ? value : function () { return value; };\n  }\n\n  return noop;\n}\n\nfunction getMessage(deprecated, correct, isError) {\n  return (\n    \"options.\" + deprecated + \" has been deprecated in favour of options.\" + correct + \".\" +\n    (isError ? (\" You cannot specify both options, please use options.\" + correct + \".\") : '')\n  );\n}\n\nfunction deprecateOption(options, deprecatedOption, correct) {\n  if (deprecatedOption in options) {\n    if (!(correct in options)) {\n      warnIfDebug(getMessage(deprecatedOption, correct));\n      options[correct] = options[deprecatedOption];\n    } else {\n      throw new Error(getMessage(deprecatedOption, correct, true));\n    }\n  }\n}\n\nfunction deprecate(options) {\n  deprecateOption(options, 'beforeInit', 'onconstruct');\n  deprecateOption(options, 'init', 'onrender');\n  deprecateOption(options, 'complete', 'oncomplete');\n  deprecateOption(options, 'eventDefinitions', 'events');\n\n  // Using extend with Component instead of options,\n  // like Human.extend( Spider ) means adaptors as a registry\n  // gets copied to options. So we have to check if actually an array\n  if (isArray(options.adaptors)) {\n    deprecateOption(options, 'adaptors', 'adapt');\n  }\n}\n\nvar config = {\n  extend: function (Parent, proto, options, Child) { return configure('extend', Parent, proto, options, Child); },\n  init: function (Parent, ractive, options) { return configure('init', Parent, ractive, options); },\n  reset: function (ractive) { return order.filter(function (c) { return c.reset && c.reset(ractive); }).map(function (c) { return c.name; }); }\n};\n\nvar custom = {\n  adapt: adaptConfigurator,\n  computed: config,\n  css: cssConfigurator,\n  data: dataConfigurator,\n  helpers: config,\n  template: templateConfigurator\n};\n\nvar defaultKeys = keys(defaults);\n\nvar isStandardKey = makeObj(defaultKeys.filter(function (key) { return !custom[key]; }));\n\n// blacklisted keys that we don't double extend\nvar isBlacklisted = makeObj(\n  defaultKeys.concat(registries.map(function (r) { return r.name; }), ['on', 'observe', 'attributes', 'cssData', 'use'])\n);\n\nvar order = [].concat(\n  defaultKeys.filter(function (key) { return !registries[key] && !custom[key]; }),\n  registries,\n  //custom.data,\n  custom.template,\n  custom.css\n);\n\nfunction configure(method, Parent, target, options, Child) {\n  deprecate(options);\n\n  for (var key in options) {\n    if (hasOwn(isStandardKey, key)) {\n      var value = options[key];\n\n      // warn the developer if they passed a function and ignore its value\n\n      // NOTE: we allow some functions on \"el\" because we duck type element lists\n      // and some libraries or ef'ed-up virtual browsers (phantomJS) return a\n      // function object as the result of querySelector methods\n      if (key !== 'el' && isFunction(value)) {\n        warnIfDebug(\n          (key + \" is a Ractive option that does not expect a function and will be ignored\"),\n          method === 'init' ? target : null\n        );\n      } else {\n        target[key] = value;\n      }\n    }\n  }\n\n  // disallow combination of `append` and `enhance`\n  if (target.append && target.enhance) {\n    throw new Error('Cannot use append and enhance at the same time');\n  }\n\n  registries.forEach(function (registry) {\n    registry[method](Parent, target, options, Child);\n  });\n\n  adaptConfigurator[method](Parent, target, options, Child);\n  templateConfigurator[method](Parent, target, options, Child);\n  cssConfigurator[method](Parent, target, options, Child);\n\n  extendOtherMethods(Parent.prototype, target, options);\n}\n\nvar _super = /\\b_super\\b/;\nfunction extendOtherMethods(parent, target, options) {\n  for (var key in options) {\n    if (!isBlacklisted[key] && hasOwn(options, key)) {\n      var member = options[key];\n\n      // if this is a method that overwrites a method, wrap it:\n      if (isFunction(member)) {\n        if (\n          (key in proto$9 ||\n            (key.slice(0, 2) === 'on' && key.slice(2) in hooks && key in target)) &&\n          !_super.test(member.toString())\n        ) {\n          warnIfDebug(\n            (\"Overriding Ractive prototype function '\" + key + \"' without calling the '\" + _super + \"' method can be very dangerous.\")\n          );\n        }\n        member = wrap$1(parent, key, member);\n      }\n\n      target[key] = member;\n    }\n  }\n}\n\nfunction makeObj(array) {\n  var obj = {};\n  array.forEach(function (x) { return (obj[x] = true); });\n  return obj;\n}\n\nvar Item = function Item(options) {\n  this.up = options.up;\n  this.ractive = options.up.ractive;\n\n  this.template = options.template;\n  this.index = options.index;\n  this.type = options.template.t;\n\n  this.dirty = false;\n};\nvar Item__proto__ = Item.prototype;\n\nItem__proto__.bubble = function bubble () {\n  if (!this.dirty) {\n    this.dirty = true;\n    this.up.bubble();\n  }\n};\n\nItem__proto__.destroyed = function destroyed () {\n  if (this.fragment) { this.fragment.destroyed(); }\n};\n\nItem__proto__.find = function find () {\n  return null;\n};\n\nItem__proto__.findComponent = function findComponent () {\n  return null;\n};\n\nItem__proto__.findNextNode = function findNextNode () {\n  return this.up.findNextNode(this);\n};\n\nItem__proto__.rebound = function rebound (update) {\n  if (this.fragment) { this.fragment.rebound(update); }\n};\n\nItem__proto__.shuffled = function shuffled () {\n  if (this.fragment) { this.fragment.shuffled(); }\n};\n\nItem__proto__.valueOf = function valueOf () {\n  return this.toString();\n};\n\nItem.prototype.findAll = noop;\nItem.prototype.findAllComponents = noop;\n\nvar ContainerItem = (function (Item) {\n  function ContainerItem(options) {\n    Item.call(this, options);\n  }\n\n  if ( Item ) ContainerItem.__proto__ = Item;\n  var ContainerItem__proto__ = ContainerItem.prototype = Object.create( Item && Item.prototype );\n  ContainerItem__proto__.constructor = ContainerItem;\n\n  ContainerItem__proto__.detach = function detach () {\n    return this.fragment ? this.fragment.detach() : createDocumentFragment();\n  };\n\n  ContainerItem__proto__.find = function find (selector) {\n    if (this.fragment) {\n      return this.fragment.find(selector);\n    }\n  };\n\n  ContainerItem__proto__.findAll = function findAll (selector, options) {\n    if (this.fragment) {\n      this.fragment.findAll(selector, options);\n    }\n  };\n\n  ContainerItem__proto__.findComponent = function findComponent (name) {\n    if (this.fragment) {\n      return this.fragment.findComponent(name);\n    }\n  };\n\n  ContainerItem__proto__.findAllComponents = function findAllComponents (name, options) {\n    if (this.fragment) {\n      this.fragment.findAllComponents(name, options);\n    }\n  };\n\n  ContainerItem__proto__.firstNode = function firstNode (skipParent) {\n    return this.fragment && this.fragment.firstNode(skipParent);\n  };\n\n  ContainerItem__proto__.toString = function toString (escape) {\n    return this.fragment ? this.fragment.toString(escape) : '';\n  };\n\n  return ContainerItem;\n}(Item));\n\nvar space = /\\s+/;\n\nfunction readStyle(css) {\n  if (!isString(css)) { return {}; }\n\n  return cleanCss(css, function (css, reconstruct) {\n    return css\n      .split(';')\n      .filter(function (rule) { return !!rule.trim(); })\n      .map(reconstruct)\n      .reduce(function (rules, rule) {\n        var i = rule.indexOf(':');\n        var name = rule.substr(0, i).trim();\n        rules[name] = rule.substr(i + 1).trim();\n        return rules;\n      }, {});\n  });\n}\n\nfunction readClass(str) {\n  var list = str.split(space);\n\n  // remove any empty entries\n  var i = list.length;\n  while (i--) {\n    if (!list[i]) { list.splice(i, 1); }\n  }\n\n  return list;\n}\n\nvar textTypes = [\n  undefined,\n  'text',\n  'search',\n  'url',\n  'email',\n  'hidden',\n  'password',\n  'search',\n  'reset',\n  'submit'\n];\n\nfunction getUpdateDelegate(attribute) {\n  var element = attribute.element;\n  var name = attribute.name;\n\n  if (name === 'value') {\n    if (attribute.interpolator) { attribute.interpolator.bound = true; }\n\n    // special case - selects\n    if (element.name === 'select' && name === 'value') {\n      return element.getAttribute('multiple') ? updateMultipleSelectValue : updateSelectValue;\n    }\n\n    if (element.name === 'textarea') { return updateStringValue; }\n\n    // special case - contenteditable\n    if (element.getAttribute('contenteditable') != null) { return updateContentEditableValue; }\n\n    // special case - <input>\n    if (element.name === 'input') {\n      var type = element.getAttribute('type');\n\n      // type='file' value='{{fileList}}'>\n      if (type === 'file') { return noop; } // read-only\n\n      // type='radio' name='{{twoway}}'\n      if (type === 'radio' && element.binding && element.binding.attribute.name === 'name')\n        { return updateRadioValue; }\n\n      if (~textTypes.indexOf(type)) { return updateStringValue; }\n    }\n\n    return updateValue;\n  }\n\n  var node = element.node;\n\n  // special case - <input type='radio' name='{{twoway}}' value='foo'>\n  if (attribute.isTwoway && name === 'name') {\n    if (node.type === 'radio') { return updateRadioName; }\n    if (node.type === 'checkbox') { return updateCheckboxName; }\n  }\n\n  if (name === 'style') { return updateStyleAttribute; }\n\n  if (name.indexOf('style-') === 0) { return updateInlineStyle; }\n\n  // special case - class names. IE fucks things up, again\n  if (name === 'class' && (!node.namespaceURI || node.namespaceURI === html))\n    { return updateClassName; }\n\n  if (name.indexOf('class-') === 0) { return updateInlineClass; }\n\n  if (attribute.isBoolean) {\n    var type$1 = element.getAttribute('type');\n    if (attribute.interpolator && name === 'checked' && (type$1 === 'checkbox' || type$1 === 'radio'))\n      { attribute.interpolator.bound = true; }\n    return updateBoolean;\n  }\n\n  if (attribute.namespace && attribute.namespace !== attribute.node.namespaceURI)\n    { return updateNamespacedAttribute; }\n\n  return updateAttribute;\n}\n\nfunction updateMultipleSelectValue(reset) {\n  var value = this.getValue();\n\n  if (!isArray(value)) { value = [value]; }\n\n  var options = this.node.options;\n  var i = options.length;\n\n  if (reset) {\n    while (i--) { options[i].selected = false; }\n  } else {\n    while (i--) {\n      var option = options[i];\n      var optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n\n      option.selected = arrayContains(value, optionValue);\n    }\n  }\n}\n\nfunction updateSelectValue(reset) {\n  var value = this.getValue();\n\n  if (!this.locked) {\n    // TODO is locked still a thing?\n    this.node._ractive.value = value;\n\n    var options = this.node.options;\n    var i = options.length;\n    var wasSelected = false;\n\n    if (reset) {\n      while (i--) { options[i].selected = false; }\n    } else {\n      while (i--) {\n        var option = options[i];\n        var optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n        if (option.disabled && option.selected) { wasSelected = true; }\n\n        if (optionValue == value) {\n          // double equals as we may be comparing numbers with strings\n          option.selected = true;\n          return;\n        }\n      }\n    }\n\n    if (!wasSelected) { this.node.selectedIndex = -1; }\n  }\n}\n\nfunction updateContentEditableValue(reset) {\n  var value = this.getValue();\n\n  if (!this.locked) {\n    if (reset) { this.node.innerHTML = ''; }\n    else { this.node.innerHTML = isUndefined(value) ? '' : value; }\n  }\n}\n\nfunction updateRadioValue(reset) {\n  var node = this.node;\n  var wasChecked = node.checked;\n\n  var value = this.getValue();\n\n  if (reset) { return (node.checked = false); }\n\n  //node.value = this.element.getAttribute( 'value' );\n  node.value = this.node._ractive.value = value;\n  node.checked = this.element.compare(value, this.element.getAttribute('name'));\n\n  // This is a special case - if the input was checked, and the value\n  // changed so that it's no longer checked, the twoway binding is\n  // most likely out of date. To fix it we have to jump through some\n  // hoops... this is a little kludgy but it works\n  if (wasChecked && !node.checked && this.element.binding && this.element.binding.rendered) {\n    this.element.binding.group.model.set(this.element.binding.group.getValue());\n  }\n}\n\nfunction updateValue(reset) {\n  if (!this.locked) {\n    if (reset) {\n      this.node.removeAttribute('value');\n      this.node.value = this.node._ractive.value = null;\n    } else {\n      var value = this.getValue();\n\n      this.node.value = this.node._ractive.value = value;\n      this.node.setAttribute('value', safeToStringValue(value));\n    }\n  }\n}\n\nfunction updateStringValue(reset) {\n  if (!this.locked) {\n    if (reset) {\n      this.node._ractive.value = '';\n      this.node.removeAttribute('value');\n    } else {\n      var value = this.getValue();\n\n      this.node._ractive.value = value;\n\n      var safeValue = safeToStringValue(value);\n\n      // fixes #3281  Safari moves caret position when setting an input value to the same value\n      if (this.node.value !== safeValue) {\n        this.node.value = safeValue;\n      }\n\n      this.node.setAttribute('value', safeValue);\n    }\n  }\n}\n\nfunction updateRadioName(reset) {\n  if (reset) { this.node.checked = false; }\n  else { this.node.checked = this.element.compare(this.getValue(), this.element.binding.getValue()); }\n}\n\nfunction updateCheckboxName(reset) {\n  var ref = this;\n  var element = ref.element;\n  var node = ref.node;\n  var binding = element.binding;\n\n  var value = this.getValue();\n  var valueAttribute = element.getAttribute('value');\n\n  if (!isArray(value)) {\n    binding.isChecked = node.checked = element.compare(value, valueAttribute);\n  } else {\n    var i = value.length;\n    while (i--) {\n      if (element.compare(valueAttribute, value[i])) {\n        binding.isChecked = node.checked = true;\n        return;\n      }\n    }\n    binding.isChecked = node.checked = false;\n  }\n}\n\nfunction updateStyleAttribute(reset) {\n  var props = reset ? {} : readStyle(this.getValue() || '');\n  var style = this.node.style;\n  var keys$$1 = keys(props);\n  var prev = this.previous || [];\n\n  var i = 0;\n  while (i < keys$$1.length) {\n    if (keys$$1[i] in style) {\n      var safe = props[keys$$1[i]].replace('!important', '');\n      style.setProperty(keys$$1[i], safe, safe.length !== props[keys$$1[i]].length ? 'important' : '');\n    }\n    i++;\n  }\n\n  // remove now-missing attrs\n  i = prev.length;\n  while (i--) {\n    if (!~keys$$1.indexOf(prev[i]) && prev[i] in style) { style.setProperty(prev[i], '', ''); }\n  }\n\n  this.previous = keys$$1;\n}\n\nfunction updateInlineStyle(reset) {\n  if (!this.style) {\n    this.style = hyphenateCamel(this.name.substr(6));\n  }\n\n  if (reset && this.node.style.getPropertyValue(this.style) !== this.last) { return; }\n\n  var value = reset ? '' : safeToStringValue(this.getValue());\n  var safe = value.replace('!important', '');\n  this.node.style.setProperty(this.style, safe, safe.length !== value.length ? 'important' : '');\n  this.last = this.node.style.getPropertyValue(this.style);\n}\n\nfunction updateClassName(reset) {\n  var value = reset ? [] : readClass(safeToStringValue(this.getValue()));\n\n  // watch out for weirdo svg elements\n  var cls = this.node.className;\n  cls = cls.baseVal !== undefined ? cls.baseVal : cls;\n\n  var attr = readClass(cls);\n  var prev = this.previous || [];\n\n  var className = value.concat(attr.filter(function (c) { return !~prev.indexOf(c); })).join(' ');\n\n  if (className !== cls) {\n    if (!isString(this.node.className)) {\n      this.node.className.baseVal = className;\n    } else {\n      this.node.className = className;\n    }\n  }\n\n  this.previous = value;\n}\n\nfunction updateInlineClass(reset) {\n  var name = this.name.substr(6);\n\n  // watch out for weirdo svg elements\n  var cls = this.node.className;\n  cls = cls.baseVal !== undefined ? cls.baseVal : cls;\n\n  var attr = readClass(cls);\n  var value = reset ? false : this.getValue();\n\n  if (!this.inlineClass) { this.inlineClass = name; }\n\n  if (value && !~attr.indexOf(name)) { attr.push(name); }\n  else if (!value && ~attr.indexOf(name)) { attr.splice(attr.indexOf(name), 1); }\n\n  if (!isString(this.node.className)) {\n    this.node.className.baseVal = attr.join(' ');\n  } else {\n    this.node.className = attr.join(' ');\n  }\n}\n\nfunction updateBoolean(reset) {\n  // with two-way binding, only update if the change wasn't initiated by the user\n  // otherwise the cursor will often be sent to the wrong place\n  if (!this.locked) {\n    if (reset) {\n      if (this.useProperty) { this.node[this.propertyName] = false; }\n      this.node.removeAttribute(this.propertyName);\n    } else {\n      if (this.useProperty) {\n        this.node[this.propertyName] = this.getValue();\n      } else {\n        var val = this.getValue();\n        if (val) {\n          this.node.setAttribute(this.propertyName, isString(val) ? val : '');\n        } else {\n          this.node.removeAttribute(this.propertyName);\n        }\n      }\n    }\n  }\n}\n\nfunction updateAttribute(reset) {\n  if (reset) {\n    if (this.node.getAttribute(this.name) === this.value) {\n      this.node.removeAttribute(this.name);\n    }\n  } else {\n    this.value = safeToStringValue(this.getString());\n    this.node.setAttribute(this.name, this.value);\n  }\n}\n\nfunction updateNamespacedAttribute(reset) {\n  if (reset) {\n    if (\n      this.value ===\n      this.node.getAttributeNS(this.namespace, this.name.slice(this.name.indexOf(':') + 1))\n    ) {\n      this.node.removeAttributeNS(this.namespace, this.name.slice(this.name.indexOf(':') + 1));\n    }\n  } else {\n    this.value = safeToStringValue(this.getString());\n    this.node.setAttributeNS(\n      this.namespace,\n      this.name.slice(this.name.indexOf(':') + 1),\n      this.value\n    );\n  }\n}\n\nvar propertyNames = {\n  'accept-charset': 'acceptCharset',\n  accesskey: 'accessKey',\n  bgcolor: 'bgColor',\n  class: 'className',\n  codebase: 'codeBase',\n  colspan: 'colSpan',\n  contenteditable: 'contentEditable',\n  datetime: 'dateTime',\n  dirname: 'dirName',\n  for: 'htmlFor',\n  'http-equiv': 'httpEquiv',\n  ismap: 'isMap',\n  maxlength: 'maxLength',\n  novalidate: 'noValidate',\n  pubdate: 'pubDate',\n  readonly: 'readOnly',\n  rowspan: 'rowSpan',\n  tabindex: 'tabIndex',\n  usemap: 'useMap'\n};\n\nvar div$1 = doc ? createElement('div') : null;\n\nvar attributes = false;\nfunction inAttributes() {\n  return attributes;\n}\n\nvar ConditionalAttribute = (function (Item) {\n  function ConditionalAttribute(options) {\n    Item.call(this, options);\n\n    this.attributes = [];\n\n    this.owner = options.owner;\n\n    this.fragment = new Fragment({\n      ractive: this.ractive,\n      owner: this,\n      template: this.template\n    });\n\n    // this fragment can't participate in node-y things\n    this.fragment.findNextNode = noop;\n\n    this.dirty = false;\n  }\n\n  if ( Item ) ConditionalAttribute.__proto__ = Item;\n  var ConditionalAttribute__proto__ = ConditionalAttribute.prototype = Object.create( Item && Item.prototype );\n  ConditionalAttribute__proto__.constructor = ConditionalAttribute;\n\n  ConditionalAttribute__proto__.bind = function bind () {\n    this.fragment.bind();\n  };\n\n  ConditionalAttribute__proto__.bubble = function bubble () {\n    if (!this.dirty) {\n      this.dirty = true;\n      this.owner.bubble();\n    }\n  };\n\n  ConditionalAttribute__proto__.destroyed = function destroyed () {\n    this.unrender();\n  };\n\n  ConditionalAttribute__proto__.render = function render () {\n    this.node = this.owner.node;\n    if (this.node) {\n      this.isSvg = this.node.namespaceURI === svg$1;\n    }\n\n    attributes = true;\n    if (!this.rendered) { this.fragment.render(); }\n\n    this.rendered = true;\n    this.dirty = true; // TODO this seems hacky, but necessary for tests to pass in browser AND node.js\n    this.update();\n    attributes = false;\n  };\n\n  ConditionalAttribute__proto__.toString = function toString () {\n    return this.fragment.toString();\n  };\n\n  ConditionalAttribute__proto__.unbind = function unbind (view) {\n    this.fragment.unbind(view);\n  };\n\n  ConditionalAttribute__proto__.unrender = function unrender () {\n    this.rendered = false;\n    this.fragment.unrender();\n  };\n\n  ConditionalAttribute__proto__.update = function update () {\n    var this$1 = this;\n\n    var str;\n    var attrs;\n\n    if (this.dirty) {\n      this.dirty = false;\n\n      var current = attributes;\n      attributes = true;\n      this.fragment.update();\n\n      if (this.rendered && this.node) {\n        str = this.fragment.toString();\n\n        attrs = parseAttributes(str, this.isSvg);\n\n        // any attributes that previously existed but no longer do\n        // must be removed\n        this.attributes\n          .filter(function (a) { return notIn(attrs, a); })\n          .forEach(function (a) {\n            this$1.node.removeAttribute(a.name);\n          });\n\n        attrs.forEach(function (a) {\n          this$1.node.setAttribute(a.name, a.value);\n        });\n\n        this.attributes = attrs;\n      }\n\n      attributes = current || false;\n    }\n  };\n\n  return ConditionalAttribute;\n}(Item));\n\nvar onlyWhitespace = /^\\s*$/;\nfunction parseAttributes(str, isSvg) {\n  if (onlyWhitespace.test(str)) { return []; }\n  var tagName = isSvg ? 'svg' : 'div';\n  return str\n    ? (div$1.innerHTML = \"<\" + tagName + \" \" + str + \"></\" + tagName + \">\") && toArray(div$1.childNodes[0].attributes)\n    : [];\n}\n\nfunction notIn(haystack, needle) {\n  var i = haystack.length;\n\n  while (i--) {\n    if (haystack[i].name === needle.name) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction lookupNamespace(node, prefix) {\n  var qualified = \"xmlns:\" + prefix;\n\n  while (node) {\n    if (node.hasAttribute && node.hasAttribute(qualified)) { return node.getAttribute(qualified); }\n    node = node.parentNode;\n  }\n\n  return namespaces[prefix];\n}\n\nvar attribute = false;\nfunction inAttribute() {\n  return attribute;\n}\n\nvar Attribute = (function (Item) {\n  function Attribute(options) {\n    Item.call(this, options);\n\n    this.name = options.template.n;\n    this.namespace = null;\n\n    this.owner = options.owner || options.up.owner || options.element || findElement(options.up);\n    this.element =\n      options.element || (this.owner.attributeByName ? this.owner : findElement(options.up));\n    this.up = options.up; // shared\n    this.ractive = this.up.ractive;\n\n    this.rendered = false;\n    this.updateDelegate = null;\n    this.fragment = null;\n\n    this.element.attributeByName[this.name] = this;\n\n    if (!isArray(options.template.f)) {\n      this.value = options.template.f;\n      if (this.value === 0) {\n        this.value = '';\n      } else if (isUndefined(this.value)) {\n        this.value = true;\n      }\n      return;\n    } else {\n      this.fragment = new Fragment({\n        owner: this,\n        template: options.template.f\n      });\n    }\n\n    this.interpolator =\n      this.fragment &&\n      this.fragment.items.length === 1 &&\n      this.fragment.items[0].type === INTERPOLATOR &&\n      this.fragment.items[0];\n\n    if (this.interpolator) { this.interpolator.owner = this; }\n  }\n\n  if ( Item ) Attribute.__proto__ = Item;\n  var Attribute__proto__ = Attribute.prototype = Object.create( Item && Item.prototype );\n  Attribute__proto__.constructor = Attribute;\n\n  Attribute__proto__.bind = function bind () {\n    if (this.fragment) {\n      this.fragment.bind();\n    }\n  };\n\n  Attribute__proto__.bubble = function bubble () {\n    if (!this.dirty) {\n      this.up.bubble();\n      this.element.bubble();\n      this.dirty = true;\n    }\n  };\n\n  Attribute__proto__.firstNode = function firstNode () {};\n\n  Attribute__proto__.getString = function getString () {\n    attribute = true;\n    var value = this.fragment\n      ? this.fragment.toString()\n      : this.value != null\n      ? '' + this.value\n      : '';\n    attribute = false;\n    return value;\n  };\n\n  // TODO could getValue ever be called for a static attribute,\n  // or can we assume that this.fragment exists?\n  Attribute__proto__.getValue = function getValue () {\n    attribute = true;\n    var value = this.fragment\n      ? this.fragment.valueOf()\n      : booleanAttributes[this.name.toLowerCase()]\n      ? true\n      : this.value;\n    attribute = false;\n    return value;\n  };\n\n  Attribute__proto__.render = function render () {\n    var node = this.element.node;\n    this.node = node;\n\n    // should we use direct property access, or setAttribute?\n    if (!node.namespaceURI || node.namespaceURI === namespaces.html) {\n      this.propertyName = propertyNames[this.name] || this.name;\n\n      if (node[this.propertyName] !== undefined) {\n        this.useProperty = true;\n      }\n\n      // is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n      // node.selected = true rather than node.setAttribute( 'selected', '' )\n      if (booleanAttributes[this.name.toLowerCase()] || this.isTwoway) {\n        this.isBoolean = true;\n      }\n\n      if (this.propertyName === 'value') {\n        node._ractive.value = this.value;\n      }\n    }\n\n    if (node.namespaceURI) {\n      var index = this.name.indexOf(':');\n      if (index !== -1) {\n        this.namespace = lookupNamespace(node, this.name.slice(0, index));\n      } else {\n        this.namespace = node.namespaceURI;\n      }\n    }\n\n    this.rendered = true;\n    this.updateDelegate = getUpdateDelegate(this);\n    this.updateDelegate();\n  };\n\n  Attribute__proto__.toString = function toString () {\n    if (inAttributes()) { return ''; }\n    attribute = true;\n\n    var value = this.getValue();\n\n    // Special case - select and textarea values (should not be stringified)\n    if (\n      this.name === 'value' &&\n      (this.element.getAttribute('contenteditable') !== undefined ||\n        (this.element.name === 'select' || this.element.name === 'textarea'))\n    ) {\n      return;\n    }\n\n    // Special case  bound radio `name` attributes\n    if (\n      this.name === 'name' &&\n      this.element.name === 'input' &&\n      this.interpolator &&\n      this.element.getAttribute('type') === 'radio'\n    ) {\n      return (\"name=\\\"{{\" + (this.interpolator.model.getKeypath()) + \"}}\\\"\");\n    }\n\n    // Special case - style and class attributes and directives\n    if (\n      this.owner === this.element &&\n      (this.name === 'style' || this.name === 'class' || this.style || this.inlineClass)\n    ) {\n      return;\n    }\n\n    if (\n      !this.rendered &&\n      this.owner === this.element &&\n      (!this.name.indexOf('style-') || !this.name.indexOf('class-'))\n    ) {\n      if (!this.name.indexOf('style-')) {\n        this.style = hyphenateCamel(this.name.substr(6));\n      } else {\n        this.inlineClass = this.name.substr(6);\n      }\n\n      return;\n    }\n\n    if (booleanAttributes[this.name.toLowerCase()])\n      { return value\n        ? isString(value)\n          ? ((this.name) + \"=\\\"\" + (safeAttributeString(value)) + \"\\\"\")\n          : this.name\n        : ''; }\n    if (value == null) { return ''; }\n\n    var str = safeAttributeString(this.getString());\n    attribute = false;\n\n    return str ? ((this.name) + \"=\\\"\" + str + \"\\\"\") : this.name;\n  };\n\n  Attribute__proto__.unbind = function unbind (view) {\n    if (this.fragment) { this.fragment.unbind(view); }\n  };\n\n  Attribute__proto__.unrender = function unrender () {\n    this.updateDelegate(true);\n\n    this.rendered = false;\n  };\n\n  Attribute__proto__.update = function update () {\n    if (this.dirty) {\n      var binding;\n      this.dirty = false;\n      if (this.fragment) { this.fragment.update(); }\n      if (this.rendered) { this.updateDelegate(); }\n      if (this.isTwoway && !this.locked) {\n        this.interpolator.twowayBinding.lastVal(true, this.interpolator.model.get());\n      } else if (this.name === 'value' && (binding = this.element.binding)) {\n        // special case: name bound element with dynamic value\n        var attr = binding.attribute;\n        if (attr && !attr.dirty && attr.rendered) {\n          this.element.binding.attribute.updateDelegate();\n        }\n      }\n    }\n  };\n\n  return Attribute;\n}(Item));\n\nvar BindingFlag = (function (Item) {\n  function BindingFlag(options) {\n    Item.call(this, options);\n\n    this.owner = options.owner || options.up.owner || findElement(options.up);\n    this.element = this.owner.attributeByName ? this.owner : findElement(options.up);\n    this.flag = options.template.v === 'l' ? 'lazy' : 'twoway';\n    this.bubbler = this.owner === this.element ? this.element : this.up;\n\n    if (this.element.type === ELEMENT) {\n      if (isArray(options.template.f)) {\n        this.fragment = new Fragment({\n          owner: this,\n          template: options.template.f\n        });\n      }\n\n      this.interpolator =\n        this.fragment &&\n        this.fragment.items.length === 1 &&\n        this.fragment.items[0].type === INTERPOLATOR &&\n        this.fragment.items[0];\n    }\n  }\n\n  if ( Item ) BindingFlag.__proto__ = Item;\n  var BindingFlag__proto__ = BindingFlag.prototype = Object.create( Item && Item.prototype );\n  BindingFlag__proto__.constructor = BindingFlag;\n\n  BindingFlag__proto__.bind = function bind () {\n    if (this.fragment) { this.fragment.bind(); }\n    set$1(this, this.getValue(), true);\n  };\n\n  BindingFlag__proto__.bubble = function bubble () {\n    if (!this.dirty) {\n      this.bubbler.bubble();\n      this.dirty = true;\n    }\n  };\n\n  BindingFlag__proto__.getValue = function getValue () {\n    if (this.fragment) { return this.fragment.valueOf(); }\n    else if ('value' in this) { return this.value; }\n    else if ('f' in this.template) { return this.template.f; }\n    else { return true; }\n  };\n\n  BindingFlag__proto__.render = function render () {\n    set$1(this, this.getValue(), true);\n  };\n\n  BindingFlag__proto__.toString = function toString () {\n    return '';\n  };\n\n  BindingFlag__proto__.unbind = function unbind (view) {\n    if (this.fragment) { this.fragment.unbind(view); }\n\n    delete this.element[this.flag];\n  };\n\n  BindingFlag__proto__.unrender = function unrender () {\n    if (this.element.rendered) { this.element.recreateTwowayBinding(); }\n  };\n\n  BindingFlag__proto__.update = function update () {\n    if (this.dirty) {\n      this.dirty = false;\n      if (this.fragment) { this.fragment.update(); }\n      set$1(this, this.getValue(), true);\n    }\n  };\n\n  return BindingFlag;\n}(Item));\n\nfunction set$1(flag, value, update) {\n  if (value === 0) {\n    flag.value = true;\n  } else if (value === 'true') {\n    flag.value = true;\n  } else if (value === 'false' || value === '0') {\n    flag.value = false;\n  } else {\n    flag.value = value;\n  }\n\n  var current = flag.element[flag.flag];\n  flag.element[flag.flag] = flag.value;\n  if (update && !flag.element.attributes.binding && current !== flag.value) {\n    flag.element.recreateTwowayBinding();\n  }\n\n  return flag.value;\n}\n\nfunction Comment(options) {\n  Item.call(this, options);\n}\n\nvar proto$1 = create(Item.prototype);\n\nassign(proto$1, {\n  bind: noop,\n  unbind: noop,\n  update: noop,\n\n  detach: function detach() {\n    return detachNode(this.node);\n  },\n\n  firstNode: function firstNode() {\n    return this.node;\n  },\n\n  render: function render(target) {\n    this.rendered = true;\n\n    this.node = doc.createComment(this.template.c);\n    target.appendChild(this.node);\n  },\n\n  toString: function toString() {\n    return (\"\x3c!-- \" + (this.template.c) + \" --\x3e\");\n  },\n\n  unrender: function unrender(shouldDestroy) {\n    if (this.rendered && shouldDestroy) { this.detach(); }\n    this.rendered = false;\n  }\n});\n\nComment.prototype = proto$1;\n\n// Teardown. This goes through the root fragment and all its children, removing observers\n// and generally cleaning up after itself\n\nfunction Ractive$teardown() {\n  var this$1 = this;\n\n  if (this.torndown) {\n    warnIfDebug('ractive.teardown() was called on a Ractive instance that was already torn down');\n    return Promise.resolve();\n  }\n\n  this.shouldDestroy = true;\n  return teardown$1(this, function () { return (this$1.fragment.rendered ? this$1.unrender() : Promise.resolve()); });\n}\n\nfunction teardown$1(instance, getPromise) {\n  instance.torndown = true;\n  instance.fragment.unbind();\n  instance._observers.slice().forEach(cancel);\n\n  if (instance.el && instance.el.__ractive_instances__) {\n    removeFromArray(instance.el.__ractive_instances__, instance);\n  }\n\n  var promise = getPromise();\n\n  hooks.teardown.fire(instance);\n\n  promise.then(function () {\n    hooks.destruct.fire(instance);\n    instance.viewmodel.teardown();\n  });\n\n  return promise;\n}\n\nvar RactiveModel = (function (SharedModel) {\n  function RactiveModel(ractive) {\n    SharedModel.call(this, ractive, '@this');\n    this.ractive = ractive;\n  }\n\n  if ( SharedModel ) RactiveModel.__proto__ = SharedModel;\n  var RactiveModel__proto__ = RactiveModel.prototype = Object.create( SharedModel && SharedModel.prototype );\n  RactiveModel__proto__.constructor = RactiveModel;\n\n  RactiveModel__proto__.joinKey = function joinKey (key) {\n    var model = SharedModel.prototype.joinKey.call(this, key);\n\n    if ((key === 'root' || key === 'parent') && !model.isLink) { return initLink(model, key); }\n    else if (key === 'data') { return this.ractive.viewmodel; }\n    else if (key === 'cssData') { return this.ractive.constructor._cssModel; }\n\n    return model;\n  };\n\n  return RactiveModel;\n}(SharedModel));\n\nfunction initLink(model, key) {\n  model.applyValue = function(value) {\n    this.parent.value[key] = value;\n    if (value && value.viewmodel) {\n      this.link(value.viewmodel.getRactiveModel(), key);\n      this._link.markedAll();\n    } else {\n      this.link(create(Missing), key);\n      this._link.markedAll();\n    }\n  };\n\n  if (key === 'root') {\n    var mark = model.mark;\n    model.mark = function(force) {\n      if (this._marking) { return; }\n      this._marking = true;\n      mark.apply(this, force);\n      this._marking = false;\n    };\n  }\n\n  model.applyValue(model.parent.ractive[key], key);\n  model._link.set = function (v) { return model.applyValue(v); };\n  model._link.applyValue = function (v) { return model.applyValue(v); };\n\n  return model._link;\n}\n\nvar specialModels = {\n  '@this': function _this(root) {\n    return root.getRactiveModel();\n  },\n  '@global': function _global() {\n    return GlobalModel;\n  },\n  '@shared': function _shared() {\n    return SharedModel$1;\n  },\n  '@style': function _style(root) {\n    return root.getRactiveModel().joinKey('cssData');\n  },\n  '@helpers': function _helpers(root) {\n    return root.getHelpers();\n  }\n};\nspecialModels['@'] = specialModels['@this'];\n\nvar RootModel = (function (Model) {\n  function RootModel(options) {\n    Model.call(this, null, null);\n\n    this.isRoot = true;\n    this.root = this;\n    this.ractive = options.ractive; // TODO sever this link\n\n    this.value = options.data;\n    this.adaptors = options.adapt;\n    this.adapt();\n  }\n\n  if ( Model ) RootModel.__proto__ = Model;\n  var RootModel__proto__ = RootModel.prototype = Object.create( Model && Model.prototype );\n  RootModel__proto__.constructor = RootModel;\n\n  RootModel__proto__.attached = function attached (fragment) {\n    attachImplicits(this, fragment);\n  };\n\n  RootModel__proto__.createLink = function createLink (keypath, target, targetPath, options) {\n    var keys = splitKeypath(keypath);\n\n    var model = this;\n    while (keys.length) {\n      var key = keys.shift();\n      model = model.childByKey[key] || model.joinKey(key);\n    }\n\n    return model.link(target, targetPath, options);\n  };\n\n  RootModel__proto__.detached = function detached () {\n    detachImplicits(this);\n  };\n\n  RootModel__proto__.get = function get (shouldCapture, options) {\n    if (shouldCapture) { capture(this); }\n\n    if (!options || options.virtual !== false) {\n      return this.getVirtual();\n    } else {\n      return this.value;\n    }\n  };\n\n  RootModel__proto__.getHelpers = function getHelpers () {\n    if (!this.helpers) { this.helpers = new SharedModel(this.ractive.helpers, 'helpers', this.ractive); }\n    return this.helpers;\n  };\n\n  RootModel__proto__.getKeypath = function getKeypath () {\n    return '';\n  };\n\n  RootModel__proto__.getRactiveModel = function getRactiveModel () {\n    return this.ractiveModel || (this.ractiveModel = new RactiveModel(this.ractive));\n  };\n\n  RootModel__proto__.getValueChildren = function getValueChildren () {\n    var children = Model.prototype.getValueChildren.call(this, this.value);\n\n    this.children.forEach(function (child) {\n      if (child._link) {\n        var idx = children.indexOf(child);\n        if (~idx) { children.splice(idx, 1, child._link); }\n        else { children.push(child._link); }\n      }\n    });\n\n    return children;\n  };\n\n  RootModel__proto__.has = function has (key) {\n    if (key[0] === '~' && key[1] === '/') { key = key.slice(2); }\n    if (specialModels[key] || key === '') { return true; }\n\n    if (Model.prototype.has.call(this, key)) {\n      return true;\n    } else {\n      var unescapedKey = unescapeKey(key);\n\n      // mappings/links and computations\n      if (this.childByKey[unescapedKey] && this.childByKey[unescapedKey]._link) { return true; }\n    }\n  };\n\n  RootModel__proto__.joinKey = function joinKey (key, opts) {\n    if (key[0] === '~' && key[1] === '/') { key = key.slice(2); }\n\n    if (key[0] === '@') {\n      var fn = specialModels[key];\n      if (fn) { return fn(this); }\n    } else {\n      return Model.prototype.joinKey.call(this, key, opts);\n    }\n  };\n\n  RootModel__proto__.set = function set (value) {\n    // TODO wrapping root node is a baaaad idea. We should prevent this\n    var wrapper = this.wrapper;\n    if (wrapper) {\n      var shouldTeardown = !wrapper.reset || wrapper.reset(value) === false;\n\n      if (shouldTeardown) {\n        wrapper.teardown();\n        this.wrapper = null;\n        this.value = value;\n        this.adapt();\n      }\n    } else {\n      this.value = value;\n      this.adapt();\n    }\n\n    this.deps.forEach(handleChange);\n    this.children.forEach(mark);\n  };\n\n  RootModel__proto__.retrieve = function retrieve () {\n    return this.wrapper ? this.wrapper.get() : this.value;\n  };\n\n  RootModel__proto__.teardown = function teardown () {\n    Model.prototype.teardown.call(this);\n    this.ractiveModel && this.ractiveModel.teardown();\n  };\n\n  return RootModel;\n}(Model));\nRootModel.prototype.update = noop;\n\nfunction attachImplicits(model, fragment) {\n  if (model._link && model._link.implicit && model._link.isDetached()) {\n    model.attach(fragment);\n  }\n\n  // look for virtual children to relink and cascade\n  for (var k in model.childByKey) {\n    if (model.value) {\n      if (k in model.value) {\n        attachImplicits(model.childByKey[k], fragment);\n      } else if (!model.childByKey[k]._link || model.childByKey[k]._link.isDetached()) {\n        var mdl = resolveReference(fragment, k);\n        if (mdl) {\n          model.childByKey[k].link(mdl, k, { implicit: true });\n        }\n      }\n    }\n  }\n}\n\nfunction detachImplicits(model) {\n  if (model._link && model._link.implicit) {\n    model.unlink();\n  }\n\n  for (var k in model.childByKey) {\n    detachImplicits(model.childByKey[k]);\n  }\n}\n\nfunction subscribe(instance, options, type) {\n  var subs = (instance.constructor[(\"_\" + type)] || []).concat(toPairs(options[type] || []));\n  var single = type === 'on' ? 'once' : (type + \"Once\");\n\n  subs.forEach(function (ref) {\n    var target = ref[0];\n    var config = ref[1];\n\n    if (isFunction(config)) {\n      instance[type](target, config);\n    } else if (isObjectType(config) && isFunction(config.handler)) {\n      instance[config.once ? single : type](target, config.handler, create(config));\n    }\n  });\n}\n\nvar registryNames$1 = [\n  'adaptors',\n  'components',\n  'decorators',\n  'easing',\n  'events',\n  'interpolators',\n  'partials',\n  'transitions'\n];\n\nvar protoRegistries = ['computed', 'helpers'];\n\nvar uid = 0;\n\nfunction construct(ractive, options) {\n  if (Ractive.DEBUG) { welcome(); }\n\n  initialiseProperties(ractive);\n  handleAttributes(ractive);\n\n  // set up event subscribers\n  subscribe(ractive, options, 'on');\n\n  // if there's not a delegation setting, inherit from parent if it's not default\n  if (\n    !hasOwn(options, 'delegate') &&\n    ractive.parent &&\n    ractive.parent.delegate !== ractive.delegate\n  ) {\n    ractive.delegate = false;\n  }\n\n  // plugins that need to run at construct\n  if (isArray(options.use)) {\n    ractive.use.apply(ractive, options.use.filter(function (p) { return p.construct; }));\n  }\n\n  hooks.construct.fire(ractive, options);\n  if (options.onconstruct) { options.onconstruct.call(ractive, getRactiveContext(ractive), options); }\n\n  // Add registries\n  var i = registryNames$1.length;\n  while (i--) {\n    var name = registryNames$1[i];\n    ractive[name] = assign(create(ractive.constructor[name] || null), options[name]);\n  }\n\n  i = protoRegistries.length;\n  while (i--) {\n    var name$1 = protoRegistries[i];\n    ractive[name$1] = assign(create(ractive.constructor.prototype[name$1]), options[name$1]);\n  }\n\n  if (ractive._attributePartial) {\n    ractive.partials['extra-attributes'] = ractive._attributePartial;\n    delete ractive._attributePartial;\n  }\n\n  // Create a viewmodel\n  var viewmodel = new RootModel({\n    adapt: getAdaptors(ractive, ractive.adapt, options),\n    data: dataConfigurator.init(ractive.constructor, ractive, options),\n    ractive: ractive\n  });\n\n  // once resolved, share the adaptors array between the root model and instance\n  ractive.adapt = viewmodel.adaptors;\n\n  ractive.viewmodel = viewmodel;\n\n  for (var k in ractive.computed) {\n    compute.call(ractive, k, ractive.computed[k]);\n  }\n}\n\nfunction getAdaptors(ractive, protoAdapt, options) {\n  protoAdapt = protoAdapt.map(lookup);\n  var adapt = ensureArray(options.adapt).map(lookup);\n\n  var srcs = [protoAdapt, adapt];\n  if (ractive.parent && !ractive.isolated) {\n    srcs.push(ractive.parent.viewmodel.adaptors);\n  }\n\n  return combine.apply(null, srcs);\n\n  function lookup(adaptor) {\n    if (isString(adaptor)) {\n      adaptor = findInViewHierarchy('adaptors', ractive, adaptor);\n\n      if (!adaptor) {\n        fatal(missingPlugin(adaptor, 'adaptor'));\n      }\n    }\n\n    return adaptor;\n  }\n}\n\nfunction initialiseProperties(ractive) {\n  // Generate a unique identifier, for places where you'd use a weak map if it\n  // existed\n  ractive._guid = 'r-' + uid++;\n\n  // events\n  ractive._subs = create(null);\n  ractive._nsSubs = 0;\n\n  // storage for item configuration from instantiation to reset,\n  // like dynamic functions or original values\n  ractive._config = {};\n\n  // events\n  ractive.event = null;\n  ractive._eventQueue = [];\n\n  // observers\n  ractive._observers = [];\n\n  // external children\n  ractive._children = [];\n  ractive._children.byName = {};\n  ractive.children = ractive._children;\n\n  if (!ractive.component) {\n    ractive.root = ractive;\n    ractive.parent = ractive.container = null; // TODO container still applicable?\n  }\n}\n\nfunction handleAttributes(ractive) {\n  var component = ractive.component;\n  var attributes = ractive.constructor.attributes;\n\n  if (attributes && component) {\n    var tpl = component.template;\n    var attrs = tpl.m ? tpl.m.slice() : [];\n\n    // grab all of the passed attribute names\n    var props = attrs.filter(function (a) { return a.t === ATTRIBUTE; }).map(function (a) { return a.n; });\n\n    // warn about missing requireds\n    attributes.required.forEach(function (p) {\n      if (!~props.indexOf(p)) {\n        warnIfDebug((\"Component '\" + (component.name) + \"' requires attribute '\" + p + \"' to be provided\"));\n      }\n    });\n\n    // set up a partial containing non-property attributes\n    var all = attributes.optional.concat(attributes.required);\n    var partial = [];\n    var i = attrs.length;\n    while (i--) {\n      var a = attrs[i];\n      if (a.t === ATTRIBUTE && !~all.indexOf(a.n)) {\n        if (attributes.mapAll) {\n          // map the attribute if requested and make the extra attribute in the partial refer to the mapping\n          partial.unshift({\n            t: ATTRIBUTE,\n            n: a.n,\n            f: [{ t: INTERPOLATOR, r: (\"~/\" + (a.n)) }]\n          });\n        } else {\n          // transfer the attribute to the extra attributes partal\n          partial.unshift(attrs.splice(i, 1)[0]);\n        }\n      } else if (\n        !attributes.mapAll &&\n        (a.t === DECORATOR || a.t === TRANSITION || a.t === BINDING_FLAG)\n      ) {\n        partial.unshift(attrs.splice(i, 1)[0]);\n      }\n    }\n\n    if (partial.length) { component.template = { t: tpl.t, e: tpl.e, f: tpl.f, m: attrs, p: tpl.p }; }\n    ractive._attributePartial = partial;\n  }\n}\n\nvar Component = (function (Item) {\n  function Component(options, ComponentConstructor) {\n    var this$1 = this;\n\n    Item.call(this, options);\n    var template = options.template;\n    this.isAnchor = template.t === ANCHOR;\n    this.type = this.isAnchor ? ANCHOR : COMPONENT; // override ELEMENT from super\n    var attrs = template.m;\n\n    var partials = template.p || {};\n    if (!('content' in partials)) { partials.content = template.f || []; }\n    this._partials = partials; // TEMP\n\n    if (this.isAnchor) {\n      this.name = template.n;\n\n      this.addChild = addChild;\n      this.removeChild = removeChild;\n    } else {\n      var instance = new ComponentConstructor({ component: true });\n\n      this.instance = instance;\n      this.name = template.e;\n\n      if (instance.el || instance.target) {\n        warnIfDebug(\n          (\"The <\" + (this.name) + \"> component has a default '\" + (instance.el ? 'el' : 'target') + \"' property; it has been disregarded\")\n        );\n        instance.el = instance.target = null;\n      }\n\n      // find container\n      var fragment = options.up;\n      var container;\n      while (fragment) {\n        if (fragment.owner.type === YIELDER) {\n          container = fragment.owner.container;\n          break;\n        }\n\n        fragment = fragment.parent;\n      }\n\n      // add component-instance-specific properties\n      instance.parent = this.up.ractive;\n      instance.container = container || null;\n      instance.root = instance.parent.root;\n      instance.component = this;\n\n      construct(this.instance, { partials: partials }, ComponentConstructor);\n\n      // these can be modified during construction\n      template = this.template;\n      attrs = template.m;\n\n      // allow components that are so inclined to add programmatic mappings\n      if (isArray(this.mappings)) {\n        attrs = (attrs || []).concat(this.mappings);\n      } else if (isString(this.mappings)) {\n        attrs = (attrs || []).concat(parser.parse(this.mappings, { attributes: true }).t);\n      }\n\n      // for hackability, this could be an open option\n      // for any ractive instance, but for now, just\n      // for components and just for ractive...\n      instance._inlinePartials = partials;\n    }\n\n    this.attributeByName = {};\n    this.attributes = [];\n\n    if (attrs) {\n      var leftovers = [];\n      attrs.forEach(function (template) {\n        switch (template.t) {\n          case ATTRIBUTE:\n          case EVENT:\n            this$1.attributes.push(\n              createItem({\n                owner: this$1,\n                up: this$1.up,\n                template: template\n              })\n            );\n            break;\n\n          case TRANSITION:\n          case BINDING_FLAG:\n          case DECORATOR:\n            break;\n\n          default:\n            leftovers.push(template);\n            break;\n        }\n      });\n\n      if (leftovers.length) {\n        this.attributes.push(\n          new ConditionalAttribute({\n            owner: this,\n            up: this.up,\n            template: leftovers\n          })\n        );\n      }\n    }\n\n    this.eventHandlers = [];\n  }\n\n  if ( Item ) Component.__proto__ = Item;\n  var Component__proto__ = Component.prototype = Object.create( Item && Item.prototype );\n  Component__proto__.constructor = Component;\n\n  Component__proto__.bind = function bind () {\n    if (!this.isAnchor) {\n      this.attributes.forEach(bind$1);\n      this.eventHandlers.forEach(bind$1);\n\n      initialise(\n        this.instance,\n        {\n          partials: this._partials\n        },\n        {\n          cssIds: this.up.cssIds\n        }\n      );\n\n      if (this.instance.target || this.instance.el) { this.extern = true; }\n\n      this.bound = true;\n    }\n  };\n\n  Component__proto__.bubble = function bubble () {\n    if (!this.dirty) {\n      this.dirty = true;\n      this.up.bubble();\n    }\n  };\n\n  Component__proto__.destroyed = function destroyed () {\n    if (!this.isAnchor && this.instance.fragment) { this.instance.fragment.destroyed(); }\n  };\n\n  Component__proto__.detach = function detach () {\n    if (this.isAnchor) {\n      if (this.instance) { return this.instance.fragment.detach(); }\n      return createDocumentFragment();\n    }\n\n    return this.instance.fragment.detach();\n  };\n\n  Component__proto__.find = function find (selector, options) {\n    if (this.instance) { return this.instance.fragment.find(selector, options); }\n  };\n\n  Component__proto__.findAll = function findAll (selector, options) {\n    if (this.instance) { this.instance.fragment.findAll(selector, options); }\n  };\n\n  Component__proto__.findComponent = function findComponent (name, options) {\n    if (!name || this.name === name) { return this.instance; }\n\n    if (this.instance.fragment) {\n      return this.instance.fragment.findComponent(name, options);\n    }\n  };\n\n  Component__proto__.findAllComponents = function findAllComponents (name, options) {\n    var result = options.result;\n\n    if (this.instance && (!name || this.name === name)) {\n      result.push(this.instance);\n    }\n\n    if (this.instance) { this.instance.findAllComponents(name, options); }\n  };\n\n  Component__proto__.firstNode = function firstNode (skipParent) {\n    if (this.instance) { return this.instance.fragment.firstNode(skipParent); }\n  };\n\n  Component__proto__.getContext = function getContext () {\n    var assigns = [], len = arguments.length;\n    while ( len-- ) assigns[ len ] = arguments[ len ];\n\n    assigns.unshift(this.instance);\n    return getRactiveContext.apply(null, assigns);\n  };\n\n  Component__proto__.rebound = function rebound (update$$1) {\n    this.attributes.forEach(function (x) { return x.rebound(update$$1); });\n  };\n\n  Component__proto__.render = function render$2 (target, occupants) {\n    if (this.isAnchor) {\n      this.rendered = true;\n      this.target = target;\n\n      if (!checking.length) {\n        checking.push(this.ractive);\n        if (occupants) {\n          this.occupants = occupants;\n          checkAnchors();\n          this.occupants = null;\n        } else {\n          runloop.scheduleTask(checkAnchors, true);\n        }\n      }\n    } else {\n      this.attributes.forEach(render);\n      this.eventHandlers.forEach(render);\n\n      if (this.extern) {\n        this.instance.delegate = false;\n        this.instance.render();\n      } else {\n        render$1(this.instance, target, null, occupants);\n      }\n\n      this.rendered = true;\n    }\n  };\n\n  Component__proto__.shuffled = function shuffled () {\n    Item.prototype.shuffled.call(this);\n    this.instance &&\n      !this.instance.isolated &&\n      this.instance.fragment &&\n      this.instance.fragment.shuffled();\n  };\n\n  Component__proto__.toString = function toString () {\n    if (this.instance) { return this.instance.toHTML(); }\n  };\n\n  Component__proto__.unbind = function unbind$1 (view) {\n    if (!this.isAnchor) {\n      this.bound = false;\n\n      this.attributes.forEach(unbind);\n\n      if (view) { this.instance.fragment.unbind(); }\n      else { teardown$1(this.instance, function () { return runloop.promise(); }); }\n    }\n  };\n\n  Component__proto__.unrender = function unrender$1 (shouldDestroy) {\n    this.shouldDestroy = shouldDestroy;\n\n    if (this.isAnchor) {\n      if (this.item) { unrenderItem(this, this.item); }\n      this.target = null;\n      if (!checking.length) {\n        checking.push(this.ractive);\n        runloop.scheduleTask(checkAnchors, true);\n      }\n    } else {\n      this.instance.unrender();\n      this.instance.el = this.instance.target = null;\n      this.attributes.forEach(unrender);\n      this.eventHandlers.forEach(unrender);\n    }\n\n    this.rendered = false;\n  };\n\n  Component__proto__.update = function update$2 () {\n    this.dirty = false;\n    if (this.instance) {\n      this.instance.fragment.update();\n      this.attributes.forEach(update);\n      this.eventHandlers.forEach(update);\n    }\n  };\n\n  return Component;\n}(Item));\n\nfunction addChild(meta) {\n  if (this.item) { this.removeChild(this.item); }\n\n  var child = meta.instance;\n  meta.anchor = this;\n\n  meta.up = this.up;\n  meta.name = meta.nameOption || this.name;\n  this.name = meta.name;\n\n  if (!child.isolated) { child.viewmodel.attached(this.up); }\n\n  // render as necessary\n  if (this.rendered) {\n    renderItem(this, meta);\n  }\n}\n\nfunction removeChild(meta) {\n  // unrender as necessary\n  if (this.item === meta) {\n    unrenderItem(this, meta);\n    this.name = this.template.n;\n  }\n}\n\nfunction renderItem(anchor, meta) {\n  if (!anchor.rendered) { return; }\n\n  meta.shouldDestroy = false;\n  meta.up = anchor.up;\n\n  anchor.item = meta;\n  anchor.instance = meta.instance;\n  var nextNode = anchor.up.findNextNode(anchor);\n\n  if (meta.instance.fragment.rendered) {\n    meta.instance.unrender();\n  }\n\n  meta.partials = meta.instance.partials;\n  meta.instance.partials = assign(create(meta.partials), meta.partials, anchor._partials);\n\n  meta.instance.fragment.unbind(true);\n  meta.instance.fragment.componentParent = anchor.up;\n  meta.instance.fragment.bind(meta.instance.viewmodel);\n\n  anchor.attributes.forEach(bind$1);\n  anchor.eventHandlers.forEach(bind$1);\n  anchor.attributes.forEach(render);\n  anchor.eventHandlers.forEach(render);\n\n  var target = anchor.up.findParentNode();\n  render$1(meta.instance, target, target.contains(nextNode) ? nextNode : null, anchor.occupants);\n\n  if (meta.lastBound !== anchor) {\n    meta.lastBound = anchor;\n  }\n}\n\nfunction unrenderItem(anchor, meta) {\n  if (!anchor.rendered) { return; }\n\n  meta.shouldDestroy = true;\n  meta.instance.unrender();\n\n  anchor.eventHandlers.forEach(unrender);\n  anchor.attributes.forEach(unrender);\n  anchor.eventHandlers.forEach(unbind);\n  anchor.attributes.forEach(unbind);\n\n  meta.instance.el = meta.instance.anchor = null;\n  meta.instance.fragment.componentParent = null;\n  meta.up = null;\n  meta.anchor = null;\n  anchor.item = null;\n  anchor.instance = null;\n}\n\nvar checking = [];\nfunction checkAnchors() {\n  var list = checking;\n  checking = [];\n\n  list.forEach(updateAnchors);\n}\n\nvar ComputationChild = (function (Model) {\n  function ComputationChild(parent, key) {\n    Model.call(this, parent, key);\n\n    this.isReadonly = !this.root.ractive.syncComputedChildren;\n    this.dirty = true;\n    this.isComputed = true;\n  }\n\n  if ( Model ) ComputationChild.__proto__ = Model;\n  var ComputationChild__proto__ = ComputationChild.prototype = Object.create( Model && Model.prototype );\n  ComputationChild__proto__.constructor = ComputationChild;\n\n  var prototypeAccessors$1 = { setRoot: {} };\n\n  prototypeAccessors$1.setRoot.get = function () {\n    return this.parent.setRoot;\n  };\n\n  ComputationChild__proto__.applyValue = function applyValue (value) {\n    Model.prototype.applyValue.call(this, value);\n\n    if (!this.isReadonly) {\n      var source = this.parent;\n      // computed models don't have a shuffle method\n      while (source && source.shuffle) {\n        source = source.parent;\n      }\n\n      if (source) {\n        source.dependencies.forEach(mark);\n      }\n    }\n\n    if (this.setRoot) {\n      this.setRoot.set(this.setRoot.value);\n    }\n  };\n\n  ComputationChild__proto__.get = function get (shouldCapture, opts) {\n    if (shouldCapture) { capture(this); }\n\n    if (this.dirty) {\n      var parentValue = this.parent.get();\n      this.value = parentValue ? parentValue[this.key] : undefined;\n      if (this.wrapper) { this.newWrapperValue = this.value; }\n      this.adapt();\n    }\n\n    this.dirty = false;\n\n    return (opts && 'unwrap' in opts ? opts.unwrap !== false : shouldCapture) && this.wrapper\n      ? this.wrapperValue\n      : this.value;\n  };\n\n  ComputationChild__proto__.handleChange = function handleChange$2 () {\n    if (this.dirty) {\n      this.deps.forEach(handleChange);\n      return;\n    }\n\n    this.dirty = true;\n\n    if (this.boundValue) { this.boundValue = null; }\n\n    this.links.forEach(marked);\n    this.deps.forEach(handleChange);\n    this.children.forEach(handleChange);\n  };\n\n  ComputationChild__proto__.joinKey = function joinKey (key) {\n    if (isUndefined(key) || key === '') { return this; }\n\n    if (!hasOwn(this.childByKey, key)) {\n      var child = new ComputationChild(this, key);\n      this.children.push(child);\n      this.childByKey[key] = child;\n    }\n\n    return this.childByKey[key];\n  };\n\n  Object.defineProperties( ComputationChild__proto__, prototypeAccessors$1 );\n\n  return ComputationChild;\n}(Model));\n\n/* global console */\n/* eslint no-console:\"off\" */\n\nvar Computation = (function (Model) {\n  function Computation(parent, signature, key) {\n    Model.call(this, parent, key);\n\n    this.signature = signature;\n\n    this.isReadonly = !this.signature.setter;\n    this.isComputed = true;\n\n    this.dependencies = [];\n\n    this.children = [];\n    this.childByKey = {};\n\n    this.deps = [];\n\n    this.dirty = true;\n\n    // TODO: is there a less hackish way to do this?\n    this.shuffle = undefined;\n  }\n\n  if ( Model ) Computation.__proto__ = Model;\n  var Computation__proto__ = Computation.prototype = Object.create( Model && Model.prototype );\n  Computation__proto__.constructor = Computation;\n\n  var prototypeAccessors$2 = { setRoot: {} };\n\n  prototypeAccessors$2.setRoot.get = function () {\n    if (this.signature.setter) { return this; }\n  };\n\n  Computation__proto__.get = function get (shouldCapture, opts) {\n    if (shouldCapture) { capture(this); }\n\n    if (this.dirty) {\n      var old = this.value;\n      this.value = this.getValue();\n      // this may cause a view somewhere to update, so it must be in a runloop\n      if (!runloop.active()) {\n        runloop.start();\n        if (!isEqual(old, this.value)) { this.notifyUpstream(); }\n        runloop.end();\n      } else {\n        if (!isEqual(old, this.value)) { this.notifyUpstream(); }\n      }\n      if (this.wrapper) { this.newWrapperValue = this.value; }\n      this.adapt();\n      this.dirty = false;\n    }\n\n    // if capturing, this value needs to be unwrapped because it's for external use\n    return maybeBind(\n      this,\n      // if unwrap is supplied, it overrides capture\n      this.wrapper && (opts && 'unwrap' in opts ? opts.unwrap !== false : shouldCapture)\n        ? this.wrapperValue\n        : this.value,\n      !opts || opts.shouldBind !== false\n    );\n  };\n\n  Computation__proto__.getContext = function getContext () {\n    return this.parent.isRoot ? this.root.ractive : this.parent.get(false, noVirtual);\n  };\n\n  Computation__proto__.getValue = function getValue () {\n    startCapturing();\n    var result;\n\n    try {\n      result = this.signature.getter.call(this.root.ractive, this.getContext(), this.getKeypath());\n    } catch (err) {\n      warnIfDebug((\"Failed to compute \" + (this.getKeypath()) + \": \" + (err.message || err)));\n\n      // TODO this is all well and good in Chrome, but...\n      // ...also, should encapsulate this stuff better, and only\n      // show it if Ractive.DEBUG\n      if (hasConsole) {\n        if (console.groupCollapsed)\n          { console.groupCollapsed(\n            '%cshow details',\n            'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;'\n          ); }\n        var sig = this.signature;\n        console.error(\n          ((err.name) + \": \" + (err.message) + \"\\n\\n\" + (sig.getterString) + (sig.getterUseStack ? '\\n\\n' + err.stack : ''))\n        );\n        if (console.groupCollapsed) { console.groupEnd(); }\n      }\n    }\n\n    var dependencies = stopCapturing();\n    if (this.parent.keypath && !~dependencies.indexOf(this.parent)) { dependencies.push(this.parent); }\n    this.setDependencies(dependencies);\n\n    return result;\n  };\n\n  Computation__proto__.mark = function mark () {\n    this.handleChange();\n  };\n\n  Computation__proto__.rebind = function rebind (next, previous) {\n    // computations will grab all of their deps again automagically\n    if (next !== previous) { this.handleChange(); }\n  };\n\n  Computation__proto__.set = function set (value) {\n    if (this.isReadonly) {\n      throw new Error((\"Cannot set read-only computed value '\" + (this.key) + \"'\"));\n    }\n\n    this.signature.setter(value, this.getContext(), this.getKeypath());\n    this.mark();\n  };\n\n  Computation__proto__.setDependencies = function setDependencies (dependencies) {\n    var this$1 = this;\n\n    // unregister any soft dependencies we no longer have\n    var i = this.dependencies.length;\n    while (i--) {\n      var model = this$1.dependencies[i];\n      if (!~dependencies.indexOf(model)) { model.unregister(this$1); }\n    }\n\n    // and add any new ones\n    i = dependencies.length;\n    while (i--) {\n      var model$1 = dependencies[i];\n      if (!~this$1.dependencies.indexOf(model$1)) { model$1.register(this$1); }\n    }\n\n    this.dependencies = dependencies;\n  };\n\n  Computation__proto__.teardown = function teardown () {\n    var this$1 = this;\n\n    var i = this.dependencies.length;\n    while (i--) {\n      if (this$1.dependencies[i]) { this$1.dependencies[i].unregister(this$1); }\n    }\n    if (this.parent.computed[this.key] === this) { delete this.parent.computed[this.key]; }\n    Model.prototype.teardown.call(this);\n  };\n\n  Object.defineProperties( Computation__proto__, prototypeAccessors$2 );\n\n  return Computation;\n}(Model));\n\nvar prototype = Computation.prototype;\nvar child = ComputationChild.prototype;\nprototype.handleChange = child.handleChange;\nprototype.joinKey = child.joinKey;\n\nshared$1.Computation = Computation;\n\nvar ExpressionProxy = (function (Model) {\n  function ExpressionProxy(fragment, template) {\n    var this$1 = this;\n\n    Model.call(this, fragment.ractive.viewmodel, null);\n\n    this.fragment = fragment;\n    this.template = template;\n\n    this.isReadonly = true;\n    this.isComputed = true;\n    this.dirty = true;\n\n    this.fn =\n      fragment.ractive.allowExpressions === false\n        ? noop\n        : getFunction(template.s, template.r.length);\n\n    this.models = this.template.r.map(function (ref) {\n      return resolveReference(this$1.fragment, ref);\n    });\n    this.dependencies = [];\n\n    this.shuffle = undefined;\n\n    this.bubble();\n  }\n\n  if ( Model ) ExpressionProxy.__proto__ = Model;\n  var ExpressionProxy__proto__ = ExpressionProxy.prototype = Object.create( Model && Model.prototype );\n  ExpressionProxy__proto__.constructor = ExpressionProxy;\n\n  ExpressionProxy__proto__.bubble = function bubble (actuallyChanged) {\n    if ( actuallyChanged === void 0 ) actuallyChanged = true;\n\n    // refresh the keypath\n    this.keypath = undefined;\n\n    if (actuallyChanged) {\n      this.handleChange();\n    }\n  };\n\n  ExpressionProxy__proto__.getKeypath = function getKeypath () {\n    var this$1 = this;\n\n    if (!this.template) { return '@undefined'; }\n    if (!this.keypath) {\n      this.keypath =\n        '@' +\n        this.template.s.replace(/_(\\d+)/g, function (match, i) {\n          if (i >= this$1.models.length) { return match; }\n\n          var model = this$1.models[i];\n          return model ? model.getKeypath() : '@undefined';\n        });\n    }\n\n    return this.keypath;\n  };\n\n  ExpressionProxy__proto__.getValue = function getValue () {\n    var this$1 = this;\n\n    startCapturing();\n    var result;\n\n    try {\n      var params = this.models.map(function (m) { return (m ? m.get(true) : undefined); });\n      result = this.fn.apply(this.fragment.ractive, params);\n    } catch (err) {\n      warnIfDebug((\"Failed to compute \" + (this.getKeypath()) + \": \" + (err.message || err)));\n    }\n\n    var dependencies = stopCapturing();\n    // remove missing deps\n    this.dependencies\n      .filter(function (d) { return !~dependencies.indexOf(d); })\n      .forEach(function (d) {\n        d.unregister(this$1);\n        removeFromArray(this$1.dependencies, d);\n      });\n    // register new deps\n    dependencies\n      .filter(function (d) { return !~this$1.dependencies.indexOf(d); })\n      .forEach(function (d) {\n        d.register(this$1);\n        this$1.dependencies.push(d);\n      });\n\n    return result;\n  };\n\n  ExpressionProxy__proto__.notifyUpstream = function notifyUpstream () {};\n\n  ExpressionProxy__proto__.rebind = function rebind (next, previous, safe) {\n    var idx = this.models.indexOf(previous);\n\n    if (~idx) {\n      next = rebindMatch(this.template.r[idx], next, previous);\n      if (next !== previous) {\n        previous.unregister(this);\n        this.models.splice(idx, 1, next);\n        if (next) { next.addShuffleRegister(this, 'mark'); }\n      }\n    }\n    this.bubble(!safe);\n  };\n\n  ExpressionProxy__proto__.rebound = function rebound (update) {\n    var this$1 = this;\n\n    this.models = this.template.r.map(function (ref) { return resolveReference(this$1.fragment, ref); });\n    if (update) { this.bubble(true); }\n  };\n\n  ExpressionProxy__proto__.retrieve = function retrieve () {\n    return this.get();\n  };\n\n  ExpressionProxy__proto__.teardown = function teardown () {\n    var this$1 = this;\n\n    this.fragment = undefined;\n    if (this.dependencies) { this.dependencies.forEach(function (d) { return d.unregister(this$1); }); }\n    Model.prototype.teardown.call(this);\n  };\n\n  ExpressionProxy__proto__.unreference = function unreference () {\n    Model.prototype.unreference.call(this);\n    collect(this);\n  };\n\n  ExpressionProxy__proto__.unregister = function unregister (dep) {\n    Model.prototype.unregister.call(this, dep);\n    collect(this);\n  };\n\n  ExpressionProxy__proto__.unregisterLink = function unregisterLink (link) {\n    Model.prototype.unregisterLink.call(this, link);\n    collect(this);\n  };\n\n  return ExpressionProxy;\n}(Model));\n\nvar prototype$1 = ExpressionProxy.prototype;\nvar computation = Computation.prototype;\nprototype$1.get = computation.get;\nprototype$1.handleChange = computation.handleChange;\nprototype$1.joinKey = computation.joinKey;\nprototype$1.mark = computation.mark;\nprototype$1.unbind = noop;\n\nfunction collect(model) {\n  if (!model.deps.length && !model.refs && !model.links.length) { model.teardown(); }\n}\n\nfunction setupArgsFn(item, template, fragment, opts) {\n  if ( opts === void 0 ) opts = {};\n\n  if (template && template.f && template.f.s) {\n    if (opts.register) {\n      item.model = new ExpressionProxy(fragment, template.f);\n      item.model.register(item);\n    } else {\n      item.fn = getFunction(template.f.s, template.f.r.length);\n    }\n  }\n}\n\nfunction resolveArgs(item, template, fragment, opts) {\n  if ( opts === void 0 ) opts = {};\n\n  return template.f.r.map(function (ref, i) {\n    var model;\n\n    if (opts.specialRef && (model = opts.specialRef(ref, i))) { return model; }\n\n    model = resolveReference(fragment, ref);\n\n    return model;\n  });\n}\n\nfunction teardownArgsFn(item) {\n  if (item.model) { item.model.unregister(item); }\n}\n\nvar missingDecorator = {\n  update: noop,\n  teardown: noop\n};\n\nvar Decorator = function Decorator(options) {\n  this.owner = options.owner || options.up.owner || findElement(options.up);\n  this.element = this.owner.attributeByName ? this.owner : findElement(options.up);\n  this.up = options.up || this.owner.up;\n  this.ractive = this.up.ractive || this.owner.ractive;\n  var template = (this.template = options.template);\n\n  this.name = template.n;\n\n  this.node = null;\n  this.handle = null;\n\n  this.element.decorators.push(this);\n};\nvar Decorator__proto__ = Decorator.prototype;\n\nDecorator__proto__.bind = function bind () {\n  // if the owner is the elment, make sure the context includes the element\n  var frag = this.element === this.owner ? new Fragment({ owner: this.owner }) : this.up;\n  setupArgsFn(this, this.template, frag, { register: true });\n};\n\nDecorator__proto__.bubble = function bubble () {\n  if (!this.dirty) {\n    this.dirty = true;\n    // decorators may be owned directly by an element or by a fragment if conditional\n    this.owner.bubble();\n    this.up.bubble();\n  }\n};\n\nDecorator__proto__.destroyed = function destroyed () {\n  if (this.handle) {\n    this.handle.teardown();\n    this.handle = null;\n  }\n  this.shouldDestroy = true;\n};\n\nDecorator__proto__.handleChange = function handleChange () {\n  this.bubble();\n};\n\nDecorator__proto__.rebound = function rebound (update) {\n  if (this.model) { this.model.rebound(update); }\n};\n\nDecorator__proto__.render = function render () {\n    var this$1 = this;\n\n  this.shouldDestroy = false;\n  if (this.handle) { this.unrender(); }\n  var ractive = this.ractive;\n  runloop.scheduleTask(function () {\n    // bail if the host element has managed to become unrendered\n    if (!this$1.element.rendered) { return; }\n\n    var fn = findInViewHierarchy('decorators', ractive, this$1.name);\n\n    if (!fn) {\n      warnOnce(missingPlugin(this$1.name, 'decorator'));\n      this$1.handle = missingDecorator;\n      return;\n    }\n\n    this$1.node = this$1.element.node;\n\n    var args = this$1.model ? this$1.model.get() : [];\n    localFragment.f = this$1.up;\n    this$1.handle = fn.apply(ractive, [this$1.node].concat(args));\n    localFragment.f = null;\n\n    if (!this$1.handle || !this$1.handle.teardown) {\n      throw new Error(\n        (\"The '\" + (this$1.name) + \"' decorator must return an object with a teardown method\")\n      );\n    }\n\n    // watch out for decorators that cause their host element to be unrendered\n    if (this$1.shouldDestroy) { this$1.destroyed(); }\n  }, true);\n};\n\nDecorator__proto__.shuffled = function shuffled () {\n  if (this.handle && this.handle.shuffled) { this.handle.shuffled(); }\n};\n\nDecorator__proto__.toString = function toString () {\n  return '';\n};\n\nDecorator__proto__.unbind = function unbind () {\n  teardownArgsFn(this, this.template);\n};\n\nDecorator__proto__.unrender = function unrender (shouldDestroy) {\n  if ((!shouldDestroy || this.element.rendered) && this.handle) {\n    this.handle.teardown();\n    this.handle = null;\n  }\n};\n\nDecorator__proto__.update = function update () {\n  var instance = this.handle;\n\n  if (!this.dirty) {\n    if (instance && instance.invalidate) {\n      runloop.scheduleTask(function () { return instance.invalidate(); }, true);\n    }\n    return;\n  }\n\n  this.dirty = false;\n\n  if (instance) {\n    if (!instance.update) {\n      this.unrender();\n      this.render();\n    } else {\n      var args = this.model ? this.model.get() : [];\n      instance.update.apply(this.ractive, args);\n    }\n  }\n};\n\nDecorator.prototype.firstNode = noop;\n\nvar Doctype = (function (Item) {\n  function Doctype () {\n    Item.apply(this, arguments);\n  }\n\n  if ( Item ) Doctype.__proto__ = Item;\n  var Doctype__proto__ = Doctype.prototype = Object.create( Item && Item.prototype );\n  Doctype__proto__.constructor = Doctype;\n\n  Doctype__proto__.toString = function toString () {\n    return '<!DOCTYPE' + this.template.a + '>';\n  };\n\n  return Doctype;\n}(Item));\n\nvar proto$2 = Doctype.prototype;\nproto$2.bind = proto$2.render = proto$2.teardown = proto$2.unbind = proto$2.unrender = proto$2.update = noop;\n\nvar Binding = function Binding(element, name) {\n  if ( name === void 0 ) name = 'value';\n\n  this.element = element;\n  this.ractive = element.ractive;\n  this.attribute = element.attributeByName[name];\n\n  var interpolator = this.attribute.interpolator;\n  interpolator.twowayBinding = this;\n\n  var model = interpolator.model;\n\n  if (model.isReadonly && !model.setRoot) {\n    var keypath = model.getKeypath().replace(/^@/, '');\n    warnOnceIfDebug(\n      (\"Cannot use two-way binding on <\" + (element.name) + \"> element: \" + keypath + \" is read-only. To suppress this warning use <\" + (element.name) + \" twoway='false'...>\"),\n      { ractive: this.ractive }\n    );\n    return false;\n  }\n\n  this.attribute.isTwoway = true;\n  this.model = model;\n\n  // initialise value, if it's undefined\n  var value = model.get();\n  this.wasUndefined = isUndefined(value);\n\n  if (isUndefined(value) && this.getInitialValue) {\n    value = this.getInitialValue();\n    model.set(value);\n  }\n  this.lastVal(true, value);\n\n  var parentForm = findElement(this.element, false, 'form');\n  if (parentForm) {\n    this.resetValue = value;\n    parentForm.formBindings.push(this);\n  }\n};\nvar Binding__proto__ = Binding.prototype;\n\nBinding__proto__.bind = function bind () {\n  this.model.registerTwowayBinding(this);\n};\n\nBinding__proto__.handleChange = function handleChange () {\n    var this$1 = this;\n\n  var value = this.getValue();\n  if (this.lastVal() === value) { return; }\n\n  runloop.start();\n  this.attribute.locked = true;\n  this.model.set(value);\n  this.lastVal(true, value);\n\n  // if the value changes before observers fire, unlock to be updatable cause something weird and potentially freezy is up\n  if (this.model.get() !== value) { this.attribute.locked = false; }\n  else { runloop.scheduleTask(function () { return (this$1.attribute.locked = false); }); }\n\n  runloop.end();\n};\n\nBinding__proto__.lastVal = function lastVal (setting, value) {\n  if (setting) { this.lastValue = value; }\n  else { return this.lastValue; }\n};\n\nBinding__proto__.rebind = function rebind (next, previous) {\n    var this$1 = this;\n\n  if (this.model && this.model === previous) { previous.unregisterTwowayBinding(this); }\n  if (next) {\n    this.model = next;\n    runloop.scheduleTask(function () { return next.registerTwowayBinding(this$1); });\n  }\n};\n\nBinding__proto__.rebound = function rebound () {\n  if (this.model) { this.model.unregisterTwowayBinding(this); }\n  this.model = this.attribute.interpolator.model;\n  this.model && this.model.registerTwowayBinding(this);\n};\n\nBinding__proto__.render = function render () {\n  this.node = this.element.node;\n  this.node._ractive.binding = this;\n  this.rendered = true; // TODO is this used anywhere?\n};\n\nBinding__proto__.setFromNode = function setFromNode (node) {\n  this.model.set(node.value);\n};\n\nBinding__proto__.unbind = function unbind () {\n  this.model && this.model.unregisterTwowayBinding(this);\n};\n\nBinding.prototype.unrender = noop;\n\n// This is the handler for DOM events that would lead to a change in the model\n// (i.e. change, sometimes, input, and occasionally click and keyup)\nfunction handleDomEvent() {\n  this._ractive.binding.handleChange();\n}\n\nvar CheckboxBinding = (function (Binding) {\n  function CheckboxBinding(element) {\n    Binding.call(this, element, 'checked');\n  }\n\n  if ( Binding ) CheckboxBinding.__proto__ = Binding;\n  var CheckboxBinding__proto__ = CheckboxBinding.prototype = Object.create( Binding && Binding.prototype );\n  CheckboxBinding__proto__.constructor = CheckboxBinding;\n\n  CheckboxBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    this.element.on('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      this.element.on('click', handleDomEvent);\n    }\n  };\n\n  CheckboxBinding__proto__.unrender = function unrender () {\n    this.element.off('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      this.element.off('click', handleDomEvent);\n    }\n  };\n\n  CheckboxBinding__proto__.getInitialValue = function getInitialValue () {\n    return !!this.element.getAttribute('checked');\n  };\n\n  CheckboxBinding__proto__.getValue = function getValue () {\n    return this.node.checked;\n  };\n\n  CheckboxBinding__proto__.setFromNode = function setFromNode (node) {\n    this.model.set(node.checked);\n  };\n\n  return CheckboxBinding;\n}(Binding));\n\nfunction getBindingGroup(group, model, getValue) {\n  var hash = group + \"-bindingGroup\";\n  return model[hash] || (model[hash] = new BindingGroup(hash, model, getValue));\n}\n\nvar BindingGroup = function BindingGroup(hash, model, getValue) {\n  var this$1 = this;\n\n  this.model = model;\n  this.hash = hash;\n  this.getValue = function () {\n    this$1.value = getValue.call(this$1);\n    return this$1.value;\n  };\n\n  this.bindings = [];\n};\nvar BindingGroup__proto__ = BindingGroup.prototype;\n\nBindingGroup__proto__.add = function add (binding) {\n  this.bindings.push(binding);\n};\n\nBindingGroup__proto__.bind = function bind () {\n    var this$1 = this;\n\n  this.value = this.model.get();\n  this.bindings.forEach(function (b) { return b.lastVal(true, this$1.value); });\n  this.model.registerTwowayBinding(this);\n  this.bound = true;\n};\n\nBindingGroup__proto__.remove = function remove (binding) {\n  removeFromArray(this.bindings, binding);\n  if (!this.bindings.length) {\n    this.unbind();\n  }\n};\n\nBindingGroup__proto__.unbind = function unbind () {\n  this.model.unregisterTwowayBinding(this);\n  this.bound = false;\n  delete this.model[this.hash];\n};\n\nBindingGroup.prototype.rebind = Binding.prototype.rebind;\n\nvar push$1 = [].push;\n\nfunction getValue() {\n  var this$1 = this;\n\n  var all = this.bindings\n    .filter(function (b) { return b.node && b.node.checked; })\n    .map(function (b) { return b.element.getAttribute('value'); });\n  var res = [];\n  all.forEach(function (v) {\n    if (!this$1.bindings[0].arrayContains(res, v)) { res.push(v); }\n  });\n  return res;\n}\n\nvar CheckboxNameBinding = (function (Binding) {\n  function CheckboxNameBinding(element) {\n    Binding.call(this, element, 'name');\n\n    this.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\n    // Each input has a reference to an array containing it and its\n    // group, as two-way binding depends on being able to ascertain\n    // the status of all inputs within the group\n    this.group = getBindingGroup('checkboxes', this.model, getValue);\n    this.group.add(this);\n\n    if (this.noInitialValue) {\n      this.group.noInitialValue = true;\n    }\n\n    // If no initial value was set, and this input is checked, we\n    // update the model\n    if (this.group.noInitialValue && this.element.getAttribute('checked')) {\n      var existingValue = this.model.get();\n      var bindingValue = this.element.getAttribute('value');\n\n      if (!this.arrayContains(existingValue, bindingValue)) {\n        push$1.call(existingValue, bindingValue); // to avoid triggering runloop with array adaptor\n      }\n    }\n  }\n\n  if ( Binding ) CheckboxNameBinding.__proto__ = Binding;\n  var CheckboxNameBinding__proto__ = CheckboxNameBinding.prototype = Object.create( Binding && Binding.prototype );\n  CheckboxNameBinding__proto__.constructor = CheckboxNameBinding;\n\n  CheckboxNameBinding__proto__.bind = function bind () {\n    if (!this.group.bound) {\n      this.group.bind();\n    }\n  };\n\n  CheckboxNameBinding__proto__.getInitialValue = function getInitialValue () {\n    // This only gets called once per group (of inputs that\n    // share a name), because it only gets called if there\n    // isn't an initial value. By the same token, we can make\n    // a note of that fact that there was no initial value,\n    // and populate it using any `checked` attributes that\n    // exist (which users should avoid, but which we should\n    // support anyway to avoid breaking expectations)\n    this.noInitialValue = true; // TODO are noInitialValue and wasUndefined the same thing?\n    return [];\n  };\n\n  CheckboxNameBinding__proto__.getValue = function getValue () {\n    return this.group.value;\n  };\n\n  CheckboxNameBinding__proto__.handleChange = function handleChange () {\n    this.isChecked = this.element.node.checked;\n    var mval = this.model.get();\n    this.group.value = mval === undefined ? [] : mval.slice();\n    var value = this.element.getAttribute('value');\n    if (this.isChecked && !this.arrayContains(this.group.value, value)) {\n      this.group.value.push(value);\n    } else if (!this.isChecked && this.arrayContains(this.group.value, value)) {\n      this.removeFromArray(this.group.value, value);\n    }\n    // make sure super knows there's a change\n    this.lastValue = null;\n    Binding.prototype.handleChange.call(this);\n  };\n\n  CheckboxNameBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    var node = this.node;\n\n    var existingValue = this.model.get();\n    var bindingValue = this.element.getAttribute('value');\n\n    if (isArray(existingValue)) {\n      this.isChecked = this.arrayContains(existingValue, bindingValue);\n    } else {\n      this.isChecked = this.element.compare(existingValue, bindingValue);\n    }\n    node.name = '{{' + this.model.getKeypath() + '}}';\n    node.checked = this.isChecked;\n\n    this.element.on('change', handleDomEvent);\n\n    // in case of IE emergency, bind to click event as well\n    if (this.node.attachEvent) {\n      this.element.on('click', handleDomEvent);\n    }\n  };\n\n  CheckboxNameBinding__proto__.setFromNode = function setFromNode (node) {\n    this.group.bindings.forEach(function (binding) { return (binding.wasUndefined = true); });\n\n    if (node.checked) {\n      var valueSoFar = this.group.getValue();\n      valueSoFar.push(this.element.getAttribute('value'));\n\n      this.group.model.set(valueSoFar);\n    }\n  };\n\n  CheckboxNameBinding__proto__.unbind = function unbind () {\n    this.group.remove(this);\n  };\n\n  CheckboxNameBinding__proto__.unrender = function unrender () {\n    var el = this.element;\n\n    el.off('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      el.off('click', handleDomEvent);\n    }\n  };\n\n  CheckboxNameBinding__proto__.arrayContains = function arrayContains (selectValue, optionValue) {\n    var this$1 = this;\n\n    var i = selectValue.length;\n    while (i--) {\n      if (this$1.element.compare(optionValue, selectValue[i])) { return true; }\n    }\n    return false;\n  };\n\n  CheckboxNameBinding__proto__.removeFromArray = function removeFromArray (array, item) {\n    var this$1 = this;\n\n    if (!array) { return; }\n    var i = array.length;\n    while (i--) {\n      if (this$1.element.compare(item, array[i])) {\n        array.splice(i, 1);\n      }\n    }\n  };\n\n  return CheckboxNameBinding;\n}(Binding));\n\nvar ContentEditableBinding = (function (Binding) {\n  function ContentEditableBinding () {\n    Binding.apply(this, arguments);\n  }\n\n  if ( Binding ) ContentEditableBinding.__proto__ = Binding;\n  var ContentEditableBinding__proto__ = ContentEditableBinding.prototype = Object.create( Binding && Binding.prototype );\n  ContentEditableBinding__proto__.constructor = ContentEditableBinding;\n\n  ContentEditableBinding__proto__.getInitialValue = function getInitialValue () {\n    return this.element.fragment ? this.element.fragment.toString() : '';\n  };\n\n  ContentEditableBinding__proto__.getValue = function getValue () {\n    return this.element.node.innerHTML;\n  };\n\n  ContentEditableBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    var el = this.element;\n\n    el.on('change', handleDomEvent);\n    el.on('blur', handleDomEvent);\n\n    if (!this.ractive.lazy) {\n      el.on('input', handleDomEvent);\n\n      if (this.node.attachEvent) {\n        el.on('keyup', handleDomEvent);\n      }\n    }\n  };\n\n  ContentEditableBinding__proto__.setFromNode = function setFromNode (node) {\n    this.model.set(node.innerHTML);\n  };\n\n  ContentEditableBinding__proto__.unrender = function unrender () {\n    var el = this.element;\n\n    el.off('blur', handleDomEvent);\n    el.off('change', handleDomEvent);\n    el.off('input', handleDomEvent);\n    el.off('keyup', handleDomEvent);\n  };\n\n  return ContentEditableBinding;\n}(Binding));\n\nfunction handleBlur() {\n  handleDomEvent.call(this);\n\n  var value = this._ractive.binding.model.get();\n  this.value = value == undefined ? '' : value;\n}\n\nfunction handleDelay(delay) {\n  var timeout;\n\n  return function() {\n    var this$1 = this;\n\n    if (timeout) { clearTimeout(timeout); }\n\n    timeout = setTimeout(function () {\n      var binding = this$1._ractive.binding;\n      if (binding.rendered) { handleDomEvent.call(this$1); }\n      timeout = null;\n    }, delay);\n  };\n}\n\nvar GenericBinding = (function (Binding) {\n  function GenericBinding () {\n    Binding.apply(this, arguments);\n  }\n\n  if ( Binding ) GenericBinding.__proto__ = Binding;\n  var GenericBinding__proto__ = GenericBinding.prototype = Object.create( Binding && Binding.prototype );\n  GenericBinding__proto__.constructor = GenericBinding;\n\n  GenericBinding__proto__.getInitialValue = function getInitialValue () {\n    return '';\n  };\n\n  GenericBinding__proto__.getValue = function getValue () {\n    return this.node.value;\n  };\n\n  GenericBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    // any lazy setting for this element overrides the root\n    // if the value is a number, it's a timeout\n    var lazy = this.ractive.lazy;\n    var timeout = false;\n    var el = this.element;\n\n    if ('lazy' in this.element) {\n      lazy = this.element.lazy;\n    }\n\n    if (isNumeric(lazy)) {\n      timeout = +lazy;\n      lazy = false;\n    }\n\n    this.handler = timeout ? handleDelay(timeout) : handleDomEvent;\n\n    var node = this.node;\n\n    el.on('change', handleDomEvent);\n\n    if (node.type !== 'file') {\n      if (!lazy) {\n        el.on('input', this.handler);\n\n        // IE is a special snowflake\n        if (node.attachEvent) {\n          el.on('keyup', this.handler);\n        }\n      }\n\n      el.on('blur', handleBlur);\n    }\n  };\n\n  GenericBinding__proto__.unrender = function unrender () {\n    var el = this.element;\n    this.rendered = false;\n\n    el.off('change', handleDomEvent);\n    el.off('input', this.handler);\n    el.off('keyup', this.handler);\n    el.off('blur', handleBlur);\n  };\n\n  return GenericBinding;\n}(Binding));\n\nvar FileBinding = (function (GenericBinding) {\n  function FileBinding () {\n    GenericBinding.apply(this, arguments);\n  }\n\n  if ( GenericBinding ) FileBinding.__proto__ = GenericBinding;\n  var FileBinding__proto__ = FileBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );\n  FileBinding__proto__.constructor = FileBinding;\n\n  FileBinding__proto__.getInitialValue = function getInitialValue () {\n    /* istanbul ignore next */\n    return undefined;\n  };\n\n  FileBinding__proto__.getValue = function getValue () {\n    /* istanbul ignore next */\n    return this.node.files;\n  };\n\n  FileBinding__proto__.render = function render () {\n    /* istanbul ignore next */\n    this.element.lazy = false;\n    /* istanbul ignore next */\n    GenericBinding.prototype.render.call(this);\n  };\n\n  FileBinding__proto__.setFromNode = function setFromNode (node) {\n    /* istanbul ignore next */\n    this.model.set(node.files);\n  };\n\n  return FileBinding;\n}(GenericBinding));\n\nfunction getSelectedOptions(select) {\n  /* istanbul ignore next */\n  return select.selectedOptions\n    ? toArray(select.selectedOptions)\n    : select.options\n    ? toArray(select.options).filter(function (option) { return option.selected; })\n    : [];\n}\n\nvar MultipleSelectBinding = (function (Binding) {\n  function MultipleSelectBinding () {\n    Binding.apply(this, arguments);\n  }\n\n  if ( Binding ) MultipleSelectBinding.__proto__ = Binding;\n  var MultipleSelectBinding__proto__ = MultipleSelectBinding.prototype = Object.create( Binding && Binding.prototype );\n  MultipleSelectBinding__proto__.constructor = MultipleSelectBinding;\n\n  MultipleSelectBinding__proto__.getInitialValue = function getInitialValue () {\n    return this.element.options\n      .filter(function (option) { return option.getAttribute('selected'); })\n      .map(function (option) { return option.getAttribute('value'); });\n  };\n\n  MultipleSelectBinding__proto__.getValue = function getValue () {\n    var options = this.element.node.options;\n    var len = options.length;\n\n    var selectedValues = [];\n\n    for (var i = 0; i < len; i += 1) {\n      var option = options[i];\n\n      if (option.selected) {\n        var optionValue = option._ractive ? option._ractive.value : option.value;\n        selectedValues.push(optionValue);\n      }\n    }\n\n    return selectedValues;\n  };\n\n  MultipleSelectBinding__proto__.handleChange = function handleChange () {\n    var attribute = this.attribute;\n    var previousValue = attribute.getValue();\n\n    var value = this.getValue();\n\n    if (isUndefined(previousValue) || !arrayContentsMatch(value, previousValue)) {\n      Binding.prototype.handleChange.call(this);\n    }\n\n    return this;\n  };\n\n  MultipleSelectBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    this.element.on('change', handleDomEvent);\n\n    if (isUndefined(this.model.get())) {\n      // get value from DOM, if possible\n      this.handleChange();\n    }\n  };\n\n  MultipleSelectBinding__proto__.setFromNode = function setFromNode (node) {\n    var selectedOptions = getSelectedOptions(node);\n    var i = selectedOptions.length;\n    var result = new Array(i);\n\n    while (i--) {\n      var option = selectedOptions[i];\n      result[i] = option._ractive ? option._ractive.value : option.value;\n    }\n\n    this.model.set(result);\n  };\n\n  MultipleSelectBinding__proto__.unrender = function unrender () {\n    this.element.off('change', handleDomEvent);\n  };\n\n  return MultipleSelectBinding;\n}(Binding));\n\nvar NumericBinding = (function (GenericBinding) {\n  function NumericBinding () {\n    GenericBinding.apply(this, arguments);\n  }\n\n  if ( GenericBinding ) NumericBinding.__proto__ = GenericBinding;\n  var NumericBinding__proto__ = NumericBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );\n  NumericBinding__proto__.constructor = NumericBinding;\n\n  NumericBinding__proto__.getInitialValue = function getInitialValue () {\n    return undefined;\n  };\n\n  NumericBinding__proto__.getValue = function getValue () {\n    var value = parseFloat(this.node.value);\n    return isNaN(value) ? undefined : value;\n  };\n\n  NumericBinding__proto__.setFromNode = function setFromNode (node) {\n    var value = parseFloat(node.value);\n    if (!isNaN(value)) { this.model.set(value); }\n  };\n\n  return NumericBinding;\n}(GenericBinding));\n\nvar siblings = {};\n\nfunction getSiblings(hash) {\n  return siblings[hash] || (siblings[hash] = []);\n}\n\nvar RadioBinding = (function (Binding) {\n  function RadioBinding(element) {\n    Binding.call(this, element, 'checked');\n\n    this.siblings = getSiblings(this.ractive._guid + this.element.getAttribute('name'));\n    this.siblings.push(this);\n  }\n\n  if ( Binding ) RadioBinding.__proto__ = Binding;\n  var RadioBinding__proto__ = RadioBinding.prototype = Object.create( Binding && Binding.prototype );\n  RadioBinding__proto__.constructor = RadioBinding;\n\n  RadioBinding__proto__.getValue = function getValue () {\n    return this.node.checked;\n  };\n\n  RadioBinding__proto__.handleChange = function handleChange () {\n    runloop.start();\n\n    this.siblings.forEach(function (binding) {\n      binding.model.set(binding.getValue());\n    });\n\n    runloop.end();\n  };\n\n  RadioBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    this.element.on('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      this.element.on('click', handleDomEvent);\n    }\n  };\n\n  RadioBinding__proto__.setFromNode = function setFromNode (node) {\n    this.model.set(node.checked);\n  };\n\n  RadioBinding__proto__.unbind = function unbind () {\n    removeFromArray(this.siblings, this);\n  };\n\n  RadioBinding__proto__.unrender = function unrender () {\n    this.element.off('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      this.element.off('click', handleDomEvent);\n    }\n  };\n\n  return RadioBinding;\n}(Binding));\n\nfunction getValue$1() {\n  var checked = this.bindings.filter(function (b) { return b.node.checked; });\n  if (checked.length > 0) {\n    return checked[0].element.getAttribute('value');\n  }\n}\n\nvar RadioNameBinding = (function (Binding) {\n  function RadioNameBinding(element) {\n    var this$1 = this;\n\n    Binding.call(this, element, 'name');\n\n    this.group = getBindingGroup('radioname', this.model, getValue$1);\n    this.group.add(this);\n\n    if (element.checked) {\n      this.group.value = this.getValue();\n    }\n\n    this.attribute.interpolator.pathChanged = function () { return this$1.updateName(); };\n  }\n\n  if ( Binding ) RadioNameBinding.__proto__ = Binding;\n  var RadioNameBinding__proto__ = RadioNameBinding.prototype = Object.create( Binding && Binding.prototype );\n  RadioNameBinding__proto__.constructor = RadioNameBinding;\n\n  RadioNameBinding__proto__.bind = function bind () {\n    if (!this.group.bound) {\n      this.group.bind();\n    }\n  };\n\n  RadioNameBinding__proto__.getInitialValue = function getInitialValue () {\n    if (this.element.getAttribute('checked')) {\n      return this.element.getAttribute('value');\n    }\n  };\n\n  RadioNameBinding__proto__.getValue = function getValue () {\n    return this.element.getAttribute('value');\n  };\n\n  RadioNameBinding__proto__.handleChange = function handleChange () {\n    // If this <input> is the one that's checked, then the value of its\n    // `name` model gets set to its value\n    if (this.node.checked) {\n      this.group.value = this.getValue();\n      Binding.prototype.handleChange.call(this);\n    }\n\n    this.updateName();\n  };\n\n  RadioNameBinding__proto__.lastVal = function lastVal (setting, value) {\n    if (!this.group) { return; }\n    if (setting) { this.group.lastValue = value; }\n    else { return this.group.lastValue; }\n  };\n\n  RadioNameBinding__proto__.rebind = function rebind (next, previous) {\n    Binding.prototype.rebind.call(this, next, previous);\n    this.updateName();\n  };\n\n  RadioNameBinding__proto__.rebound = function rebound (update) {\n    Binding.prototype.rebound.call(this, update);\n    this.updateName();\n  };\n\n  RadioNameBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    var node = this.node;\n\n    this.updateName();\n    node.checked = this.element.compare(this.model.get(), this.element.getAttribute('value'));\n\n    this.element.on('change', handleDomEvent);\n\n    if (node.attachEvent) {\n      this.element.on('click', handleDomEvent);\n    }\n  };\n\n  RadioNameBinding__proto__.setFromNode = function setFromNode (node) {\n    if (node.checked) {\n      this.group.model.set(this.element.getAttribute('value'));\n    }\n  };\n\n  RadioNameBinding__proto__.unbind = function unbind () {\n    this.group.remove(this);\n  };\n\n  RadioNameBinding__proto__.unrender = function unrender () {\n    var el = this.element;\n\n    el.off('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      el.off('click', handleDomEvent);\n    }\n  };\n\n  RadioNameBinding__proto__.updateName = function updateName () {\n    if (this.node) { this.node.name = \"{{\" + (this.model.getKeypath()) + \"}}\"; }\n  };\n\n  return RadioNameBinding;\n}(Binding));\n\nvar SingleSelectBinding = (function (Binding) {\n  function SingleSelectBinding () {\n    Binding.apply(this, arguments);\n  }\n\n  if ( Binding ) SingleSelectBinding.__proto__ = Binding;\n  var SingleSelectBinding__proto__ = SingleSelectBinding.prototype = Object.create( Binding && Binding.prototype );\n  SingleSelectBinding__proto__.constructor = SingleSelectBinding;\n\n  SingleSelectBinding__proto__.forceUpdate = function forceUpdate () {\n    var this$1 = this;\n\n    var value = this.getValue();\n\n    if (value !== undefined) {\n      this.attribute.locked = true;\n      runloop.scheduleTask(function () { return (this$1.attribute.locked = false); });\n      this.model.set(value);\n    }\n  };\n\n  SingleSelectBinding__proto__.getInitialValue = function getInitialValue () {\n    if (this.element.getAttribute('value') !== undefined) {\n      return;\n    }\n\n    var options = this.element.options;\n    var len = options.length;\n\n    if (!len) { return; }\n\n    var value;\n    var optionWasSelected;\n    var i = len;\n\n    // take the final selected option...\n    while (i--) {\n      var option = options[i];\n\n      if (option.getAttribute('selected')) {\n        if (!option.getAttribute('disabled')) {\n          value = option.getAttribute('value');\n        }\n\n        optionWasSelected = true;\n        break;\n      }\n    }\n\n    // or the first non-disabled option, if none are selected\n    if (!optionWasSelected) {\n      while (++i < len) {\n        if (!options[i].getAttribute('disabled')) {\n          value = options[i].getAttribute('value');\n          break;\n        }\n      }\n    }\n\n    // This is an optimisation (aka hack) that allows us to forgo some\n    // other more expensive work\n    // TODO does it still work? seems at odds with new architecture\n    if (value !== undefined) {\n      this.element.attributeByName.value.value = value;\n    }\n\n    return value;\n  };\n\n  SingleSelectBinding__proto__.getValue = function getValue () {\n    var options = this.node.options;\n    var len = options.length;\n\n    var i;\n    for (i = 0; i < len; i += 1) {\n      var option = options[i];\n\n      if (options[i].selected && !options[i].disabled) {\n        return option._ractive ? option._ractive.value : option.value;\n      }\n    }\n  };\n\n  SingleSelectBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n    this.element.on('change', handleDomEvent);\n  };\n\n  SingleSelectBinding__proto__.setFromNode = function setFromNode (node) {\n    var option = getSelectedOptions(node)[0];\n    this.model.set(option._ractive ? option._ractive.value : option.value);\n  };\n\n  SingleSelectBinding__proto__.unrender = function unrender () {\n    this.element.off('change', handleDomEvent);\n  };\n\n  return SingleSelectBinding;\n}(Binding));\n\nfunction isBindable(attribute) {\n  // The fragment must be a single non-string fragment\n  if (\n    !attribute ||\n    !attribute.template.f ||\n    attribute.template.f.length !== 1 ||\n    attribute.template.f[0].s\n  )\n    { return false; }\n\n  // A binding is an interpolator `{{ }}`, yey.\n  if (attribute.template.f[0].t === INTERPOLATOR) { return true; }\n\n  // The above is probably the only true case. For the rest, show an appropriate\n  // warning before returning false.\n\n  // You can't bind a triple curly. HTML values on an attribute makes no sense.\n  if (attribute.template.f[0].t === TRIPLE)\n    { warnIfDebug('It is not possible create a binding using a triple mustache.'); }\n\n  return false;\n}\n\nfunction selectBinding(element) {\n  var name = element.name;\n  var attributes = element.attributeByName;\n  if (name !== 'input' && name !== 'textarea' && name !== 'select' && !attributes.contenteditable)\n    { return; }\n  var isBindableByValue = isBindable(attributes.value);\n  var isBindableByContentEditable = isBindable(attributes.contenteditable);\n  var isContentEditable = element.getAttribute('contenteditable');\n\n  // contenteditable\n  // Bind if the contenteditable is true or a binding that may become true.\n  if ((isContentEditable || isBindableByContentEditable) && isBindableByValue)\n    { return ContentEditableBinding; }\n\n  // <input>\n  if (name === 'input') {\n    var type = element.getAttribute('type');\n\n    if (type === 'radio') {\n      var isBindableByName = isBindable(attributes.name);\n      var isBindableByChecked = isBindable(attributes.checked);\n\n      // For radios we can either bind the name or checked, but not both.\n      // Name binding is handed instead.\n      if (isBindableByName && isBindableByChecked) {\n        warnIfDebug(\n          'A radio input can have two-way binding on its name attribute, or its checked attribute - not both',\n          { ractive: element.root }\n        );\n        return RadioNameBinding;\n      }\n\n      if (isBindableByName) { return RadioNameBinding; }\n\n      if (isBindableByChecked) { return RadioBinding; }\n\n      // Dead end. Unknown binding on radio input.\n      return null;\n    }\n\n    if (type === 'checkbox') {\n      var isBindableByName$1 = isBindable(attributes.name);\n      var isBindableByChecked$1 = isBindable(attributes.checked);\n\n      // A checkbox with bindings for both name and checked. Checked treated as\n      // the checkbox value, name is treated as a regular binding.\n      //\n      // See https://github.com/ractivejs/ractive/issues/1749\n      if (isBindableByName$1 && isBindableByChecked$1) { return CheckboxBinding; }\n\n      if (isBindableByName$1) { return CheckboxNameBinding; }\n\n      if (isBindableByChecked$1) { return CheckboxBinding; }\n\n      // Dead end. Unknown binding on checkbox input.\n      return null;\n    }\n\n    if (type === 'file' && isBindableByValue) { return FileBinding; }\n\n    if (type === 'number' && isBindableByValue) { return NumericBinding; }\n\n    if (type === 'range' && isBindableByValue) { return NumericBinding; }\n\n    // Some input of unknown type (browser usually falls back to text).\n    if (isBindableByValue) { return GenericBinding; }\n\n    // Dead end. Some unknown input and an unbindable.\n    return null;\n  }\n\n  // <select>\n  if (name === 'select' && isBindableByValue) {\n    return element.getAttribute('multiple') ? MultipleSelectBinding : SingleSelectBinding;\n  }\n\n  // <textarea>\n  if (name === 'textarea' && isBindableByValue) { return GenericBinding; }\n\n  // Dead end. Some unbindable element.\n  return null;\n}\n\nvar endsWithSemi = /;\\s*$/;\n\nvar Element = (function (ContainerItem) {\n  function Element(options) {\n    var this$1 = this;\n\n    ContainerItem.call(this, options);\n\n    this.name = options.template.e.toLowerCase();\n\n    // find parent element\n    this.parent = findElement(this.up, false);\n\n    if (this.parent && this.parent.name === 'option') {\n      throw new Error(\n        (\"An <option> element cannot contain other elements (encountered <\" + (this.name) + \">)\")\n      );\n    }\n\n    this.decorators = [];\n\n    // create attributes\n    this.attributeByName = {};\n\n    var attrs;\n    var n, attr, val, cls, name, template, leftovers;\n\n    var m = this.template.m;\n    var len = (m && m.length) || 0;\n\n    for (var i = 0; i < len; i++) {\n      template = m[i];\n      if (template.g) {\n        (this$1.statics || (this$1.statics = {}))[template.n] = isString(template.f)\n          ? template.f\n          : template.n;\n      } else {\n        switch (template.t) {\n          case ATTRIBUTE:\n          case BINDING_FLAG:\n          case DECORATOR:\n          case EVENT:\n          case TRANSITION:\n            attr = createItem({\n              owner: this$1,\n              up: this$1.up,\n              template: template\n            });\n\n            n = template.n;\n\n            attrs = attrs || (attrs = this$1.attributes = []);\n\n            if (n === 'value') { val = attr; }\n            else if (n === 'name') { name = attr; }\n            else if (n === 'class') { cls = attr; }\n            else { attrs.push(attr); }\n\n            break;\n\n          case DELEGATE_FLAG:\n            this$1.delegate = false;\n            break;\n\n          default:\n            (leftovers || (leftovers = [])).push(template);\n            break;\n        }\n      }\n    }\n\n    if (val) { attrs.push(val); }\n    if (name) { attrs.push(name); }\n    if (cls) { attrs.unshift(cls); }\n\n    if (leftovers) {\n      (attrs || (this.attributes = [])).push(\n        new ConditionalAttribute({\n          owner: this,\n          up: this.up,\n          template: leftovers\n        })\n      );\n\n      // empty leftovers array\n      leftovers = [];\n    }\n\n    // create children\n    if (options.template.f && !options.deferContent) {\n      this.fragment = new Fragment({\n        template: options.template.f,\n        owner: this,\n        cssIds: null\n      });\n    }\n\n    this.binding = null; // filled in later\n  }\n\n  if ( ContainerItem ) Element.__proto__ = ContainerItem;\n  var Element__proto__ = Element.prototype = Object.create( ContainerItem && ContainerItem.prototype );\n  Element__proto__.constructor = Element;\n\n  Element__proto__.bind = function bind () {\n    var attrs = this.attributes;\n    if (attrs) {\n      attrs.binding = true;\n      var len = attrs.length;\n      for (var i = 0; i < len; i++) { attrs[i].bind(); }\n      attrs.binding = false;\n    }\n\n    if (this.fragment) { this.fragment.bind(); }\n\n    // create two-way binding if necessary\n    if (!this.binding) { this.recreateTwowayBinding(); }\n    else { this.binding.bind(); }\n  };\n\n  Element__proto__.createTwowayBinding = function createTwowayBinding () {\n    if ('twoway' in this ? this.twoway : this.ractive.twoway) {\n      var Binding = selectBinding(this);\n      if (Binding) {\n        var binding = new Binding(this);\n        if (binding && binding.model) { return binding; }\n      }\n    }\n  };\n\n  Element__proto__.destroyed = function destroyed$1 () {\n    if (this.attributes) { this.attributes.forEach(destroyed); }\n    if (this.fragment) { this.fragment.destroyed(); }\n  };\n\n  Element__proto__.detach = function detach () {\n    // if this element is no longer rendered, the transitions are complete and the attributes can be torn down\n    if (!this.rendered) { this.destroyed(); }\n\n    return detachNode(this.node);\n  };\n\n  Element__proto__.find = function find (selector, options) {\n    if (this.node && matches(this.node, selector)) { return this.node; }\n    if (this.fragment) {\n      return this.fragment.find(selector, options);\n    }\n  };\n\n  Element__proto__.findAll = function findAll (selector, options) {\n    var result = options.result;\n\n    if (matches(this.node, selector)) {\n      result.push(this.node);\n    }\n\n    if (this.fragment) {\n      this.fragment.findAll(selector, options);\n    }\n  };\n\n  Element__proto__.findNextNode = function findNextNode () {\n    return null;\n  };\n\n  Element__proto__.firstNode = function firstNode () {\n    return this.node;\n  };\n\n  Element__proto__.getAttribute = function getAttribute (name) {\n    if (this.statics && name in this.statics) { return this.statics[name]; }\n    var attribute = this.attributeByName[name];\n    return attribute ? attribute.getValue() : undefined;\n  };\n\n  Element__proto__.getContext = function getContext () {\n    var assigns = [], len = arguments.length;\n    while ( len-- ) assigns[ len ] = arguments[ len ];\n\n    if (this.fragment) { return (ref = this.fragment).getContext.apply(ref, assigns); }\n\n    if (!this.ctx) { this.ctx = new Context(this.up, this); }\n    assigns.unshift(create(this.ctx));\n    return assign.apply(null, assigns);\n    var ref;\n  };\n\n  Element__proto__.off = function off (event, callback, capture) {\n    if ( capture === void 0 ) capture = false;\n\n    var delegate = this.up.delegate;\n    var ref = this.listeners && this.listeners[event];\n\n    if (!ref) { return; }\n    removeFromArray(ref, callback);\n\n    if (delegate) {\n      var listeners =\n        (delegate.listeners || (delegate.listeners = [])) &&\n        (delegate.listeners[event] || (delegate.listeners[event] = []));\n      if (listeners.refs && !--listeners.refs) { delegate.off(event, delegateHandler, true); }\n    } else if (this.rendered) {\n      var n = this.node;\n      var add = n.addEventListener;\n      var rem = n.removeEventListener;\n\n      if (!ref.length) {\n        rem.call(n, event, handler, capture);\n      } else if (ref.length && !ref.refs && capture) {\n        rem.call(n, event, handler, true);\n        add.call(n, event, handler, false);\n      }\n    }\n  };\n\n  Element__proto__.on = function on (event, callback, capture) {\n    if ( capture === void 0 ) capture = false;\n\n    var delegate = this.up.delegate;\n    var ref = (this.listeners || (this.listeners = {}))[event] || (this.listeners[event] = []);\n\n    if (delegate) {\n      var listeners =\n        ((delegate.listeners || (delegate.listeners = [])) && delegate.listeners[event]) ||\n        (delegate.listeners[event] = []);\n      if (!listeners.refs) {\n        listeners.refs = 0;\n        delegate.on(event, delegateHandler, true);\n        listeners.refs++;\n      } else {\n        listeners.refs++;\n      }\n    } else if (this.rendered) {\n      var n = this.node;\n      var add = n.addEventListener;\n      var rem = n.removeEventListener;\n\n      if (!ref.length) {\n        add.call(n, event, handler, capture);\n      } else if (ref.length && !ref.refs && capture) {\n        rem.call(n, event, handler, false);\n        add.call(n, event, handler, true);\n      }\n    }\n\n    addToArray(this.listeners[event], callback);\n  };\n\n  Element__proto__.recreateTwowayBinding = function recreateTwowayBinding () {\n    if (this.binding) {\n      this.binding.unbind();\n      this.binding.unrender();\n    }\n\n    if ((this.binding = this.createTwowayBinding())) {\n      this.binding.bind();\n      if (this.rendered) { this.binding.render(); }\n    }\n  };\n\n  Element__proto__.rebound = function rebound (update$$1) {\n    ContainerItem.prototype.rebound.call(this, update$$1);\n    if (this.attributes) { this.attributes.forEach(function (x) { return x.rebound(update$$1); }); }\n    if (this.binding) { this.binding.rebound(update$$1); }\n  };\n\n  Element__proto__.render = function render (target, occupants) {\n    var this$1 = this;\n\n    // TODO determine correct namespace\n    this.namespace = getNamespace(this);\n\n    var node;\n    var existing = false;\n\n    if (occupants) {\n      var n;\n      while ((n = occupants.shift())) {\n        if (\n          n.nodeName.toUpperCase() === this$1.template.e.toUpperCase() &&\n          n.namespaceURI === this$1.namespace\n        ) {\n          this$1.node = node = n;\n          existing = true;\n          break;\n        } else {\n          detachNode(n);\n        }\n      }\n    }\n\n    if (!existing && this.node) {\n      node = this.node;\n      target.appendChild(node);\n      existing = true;\n    }\n\n    if (!node) {\n      var name = this.template.e;\n      node = createElement(\n        this.namespace === html ? name.toLowerCase() : name,\n        this.namespace,\n        this.getAttribute('is')\n      );\n      this.node = node;\n    }\n\n    // tie the node to this vdom element\n    defineProperty(node, '_ractive', {\n      value: {\n        proxy: this\n      },\n      configurable: true\n    });\n\n    if (this.statics) {\n      keys(this.statics).forEach(function (k) {\n        node.setAttribute(k, this$1.statics[k]);\n      });\n    }\n\n    if (existing && this.foundNode) { this.foundNode(node); }\n\n    // register intro before rendering content so children can find the intro\n    var intro = this.intro;\n    if (intro && intro.shouldFire('intro')) {\n      intro.isIntro = true;\n      intro.isOutro = false;\n      runloop.registerTransition(intro);\n    }\n\n    if (this.fragment) {\n      var children = existing ? toArray(node.childNodes) : undefined;\n\n      this.fragment.render(node, children);\n\n      // clean up leftover children\n      if (children) {\n        children.forEach(detachNode);\n      }\n    }\n\n    if (existing) {\n      // store initial values for two-way binding\n      if (this.binding && this.binding.wasUndefined) { this.binding.setFromNode(node); }\n      // remove unused attributes\n      var i = node.attributes.length;\n      while (i--) {\n        var name$1 = node.attributes[i].name;\n        if (!(name$1 in this$1.attributeByName) && (!this$1.statics || !(name$1 in this$1.statics)))\n          { node.removeAttribute(name$1); }\n      }\n    }\n\n    // Is this a top-level node of a component? If so, we may need to add\n    // a data-ractive-css attribute, for CSS encapsulation\n    if (this.up.cssIds) {\n      node.setAttribute('data-ractive-css', this.up.cssIds.map(function (x) { return (\"{\" + x + \"}\"); }).join(' '));\n    }\n\n    if (this.attributes) {\n      var len = this.attributes.length;\n      for (var i$1 = 0; i$1 < len; i$1++) { this$1.attributes[i$1].render(); }\n    }\n    if (this.binding) { this.binding.render(); }\n\n    if (!this.up.delegate && this.listeners) {\n      var ls = this.listeners;\n      for (var k in ls) {\n        if (ls[k] && ls[k].length) { this$1.node.addEventListener(k, handler, !!ls[k].refs); }\n      }\n    }\n\n    if (!existing) {\n      target.appendChild(node);\n    }\n\n    this.rendered = true;\n  };\n\n  Element__proto__.shuffled = function shuffled$1 () {\n    ContainerItem.prototype.shuffled.call(this);\n    this.decorators.forEach(shuffled);\n  };\n\n  Element__proto__.toString = function toString () {\n    var this$1 = this;\n\n    var tagName = this.template.e;\n\n    var attrs = (this.attributes && this.attributes.map(stringifyAttribute).join('')) || '';\n\n    if (this.statics)\n      { keys(this.statics).forEach(\n        function (k) { return k !== 'class' &&\n          k !== 'style' &&\n          (attrs = \" \" + k + \"=\\\"\" + (safeAttributeString(this$1.statics[k])) + \"\\\"\" + attrs); }\n      ); }\n\n    // Special case - selected options\n    if (this.name === 'option' && this.isSelected()) {\n      attrs += ' selected';\n    }\n\n    // Special case - two-way radio name bindings\n    if (this.name === 'input' && inputIsCheckedRadio(this)) {\n      attrs += ' checked';\n    }\n\n    // Special case style and class attributes and directives\n    var style = this.statics ? this.statics.style : undefined;\n    var cls = this.statics ? this.statics.class : undefined;\n    this.attributes &&\n      this.attributes.forEach(function (attr) {\n        if (attr.name === 'class') {\n          cls = (cls || '') + (cls ? ' ' : '') + safeAttributeString(attr.getString());\n        } else if (attr.name === 'style') {\n          style = (style || '') + (style ? ' ' : '') + safeAttributeString(attr.getString());\n          if (style && !endsWithSemi.test(style)) { style += ';'; }\n        } else if (attr.style) {\n          style =\n            (style || '') +\n            (style ? ' ' : '') +\n            (attr.style) + \": \" + (safeAttributeString(attr.getString())) + \";\";\n        } else if (attr.inlineClass && attr.getValue()) {\n          cls = (cls || '') + (cls ? ' ' : '') + attr.inlineClass;\n        }\n      });\n    // put classes first, then inline style\n    if (style !== undefined) { attrs = ' style' + (style ? (\"=\\\"\" + style + \"\\\"\") : '') + attrs; }\n    if (cls !== undefined) { attrs = ' class' + (cls ? (\"=\\\"\" + cls + \"\\\"\") : '') + attrs; }\n\n    if (this.up.cssIds) {\n      attrs += \" data-ractive-css=\\\"\" + (this.up.cssIds.map(function (x) { return (\"{\" + x + \"}\"); }).join(' ')) + \"\\\"\";\n    }\n\n    var str = \"<\" + tagName + attrs + \">\";\n\n    if (voidElements[this.name.toLowerCase()]) { return str; }\n\n    // Special case - textarea\n    if (this.name === 'textarea' && this.getAttribute('value') !== undefined) {\n      str += escapeHtml(this.getAttribute('value'));\n    } else if (this.getAttribute('contenteditable') !== undefined) {\n      // Special case - contenteditable\n      str += this.getAttribute('value') || '';\n    }\n\n    if (this.fragment) {\n      str += this.fragment.toString(!/^(?:script|style)$/i.test(this.template.e)); // escape text unless script/style\n    }\n\n    str += \"</\" + tagName + \">\";\n    return str;\n  };\n\n  Element__proto__.unbind = function unbind (view) {\n    var attrs = this.attributes;\n    if (attrs) {\n      attrs.unbinding = true;\n      var len = attrs.length;\n      for (var i = 0; i < len; i++) { attrs[i].unbind(view); }\n      attrs.unbinding = false;\n    }\n\n    if (this.binding) { this.binding.unbind(view); }\n    if (this.fragment) { this.fragment.unbind(view); }\n  };\n\n  Element__proto__.unrender = function unrender (shouldDestroy) {\n    if (!this.rendered) { return; }\n    this.rendered = false;\n\n    // unrendering before intro completed? complete it now\n    // TODO should be an API for aborting transitions\n    var transition = this.intro;\n    if (transition && transition.complete) { transition.complete(); }\n\n    // Detach as soon as we can\n    if (this.name === 'option') {\n      // <option> elements detach immediately, so that\n      // their parent <select> element syncs correctly, and\n      // since option elements can't have transitions anyway\n      this.detach();\n    } else if (shouldDestroy) {\n      runloop.detachWhenReady(this);\n    }\n\n    // outro transition\n    var outro = this.outro;\n    if (outro && outro.shouldFire('outro')) {\n      outro.isIntro = false;\n      outro.isOutro = true;\n      runloop.registerTransition(outro);\n    }\n\n    if (this.fragment) { this.fragment.unrender(); }\n\n    if (this.binding) { this.binding.unrender(); }\n  };\n\n  Element__proto__.update = function update () {\n    if (this.dirty) {\n      this.dirty = false;\n\n      var attrs = this.attributes;\n      if (attrs) {\n        var len = attrs.length;\n        for (var i = 0; i < len; i++) { attrs[i].update(); }\n      }\n\n      if (this.fragment) { this.fragment.update(); }\n    }\n  };\n\n  return Element;\n}(ContainerItem));\n\nfunction inputIsCheckedRadio(element) {\n  var nameAttr = element.attributeByName.name;\n  return (\n    element.getAttribute('type') === 'radio' &&\n    (nameAttr || {}).interpolator &&\n    element.getAttribute('value') === nameAttr.interpolator.model.get()\n  );\n}\n\nfunction stringifyAttribute(attribute) {\n  var str = attribute.toString();\n  return str ? ' ' + str : '';\n}\n\nfunction getNamespace(element) {\n  // Use specified namespace...\n  var xmlns$$1 = element.getAttribute('xmlns');\n  if (xmlns$$1) { return xmlns$$1; }\n\n  // ...or SVG namespace, if this is an <svg> element\n  if (element.name === 'svg') { return svg$1; }\n\n  var parent = element.parent;\n\n  if (parent) {\n    // ...or HTML, if the parent is a <foreignObject>\n    if (parent.name === 'foreignobject') { return html; }\n\n    // ...or inherit from the parent node\n    return parent.node.namespaceURI;\n  }\n\n  return element.ractive.el.namespaceURI;\n}\n\nvar stop = false;\nfunction stopPropagation() {\n  stop = true;\n}\nvar immediate$1 = false;\nfunction stopImmediatePropagation() {\n  immediate$1 = true;\n}\nvar prevent = false;\nfunction preventDefault() {\n  prevent = true;\n}\n\nfunction delegateHandler(ev) {\n  var name = ev.type;\n  var end = ev.currentTarget;\n  var endEl = end._ractive && end._ractive.proxy;\n  var node = ev.target;\n  var bubble = true;\n  var listeners;\n  var prevented = false;\n\n  stop = immediate$1 = prevent = false;\n  var oldStop = ev.stopPropagation;\n  var oldImmediate = ev.stopImmediatePropagation;\n  var oldPrevent = ev.preventDefault;\n  ev.stopPropagation = stopPropagation;\n  ev.stopImmediatePropagation = stopImmediatePropagation;\n  ev.preventDefault = preventDefault;\n\n  // starting with the origin node, walk up the DOM looking for ractive nodes with a matching event listener\n  while (bubble && node && node !== end) {\n    var proxy = node._ractive && node._ractive.proxy;\n    if (proxy && proxy.up.delegate === endEl && shouldFire(ev, node, end)) {\n      listeners = proxy.listeners && proxy.listeners[name];\n\n      if (listeners) {\n        var len = listeners.length;\n        for (var i = 0; i < len; i++) {\n          bubble = listeners[i].call(node, ev) !== false && bubble;\n          if (immediate$1) {\n            bubble = false;\n            break;\n          }\n          if (stop) { bubble = false; }\n          if (prevent && !prevented) {\n            prevented = true;\n            oldPrevent.call(ev);\n          }\n        }\n      }\n    }\n\n    node = node.parentNode || node.correspondingUseElement; // SVG with a <use> element in certain environments\n  }\n\n  if (bubble) { bubble = !stop && !immediate$1; }\n\n  if (stop) { oldStop.call(ev); }\n  if (immediate$1) { oldImmediate.call(ev); }\n\n  ev.stopPropagation = oldStop;\n  ev.stopImmediaitePropagation = oldImmediate;\n  ev.preventDefault = oldPrevent;\n\n  return bubble;\n}\n\nvar UIEvent = win !== null ? win.UIEvent : null;\nfunction shouldFire(event, start, end) {\n  if (UIEvent && event instanceof UIEvent) {\n    var node = start;\n    while (node && node !== end) {\n      if (node.disabled) { return false; }\n      node = node.parentNode || node.correspondingUseElement;\n    }\n  }\n\n  return true;\n}\n\nfunction handler(ev) {\n  var this$1 = this;\n\n  var el = this._ractive.proxy;\n  var listeners;\n  if (el.listeners && (listeners = el.listeners[ev.type])) {\n    var len = listeners.length;\n    for (var i = 0; i < len; i++) { listeners[i] && listeners[i].call(this$1, ev); }\n  }\n}\n\nvar Form = (function (Element) {\n  function Form(options) {\n    Element.call(this, options);\n    this.formBindings = [];\n  }\n\n  if ( Element ) Form.__proto__ = Element;\n  var Form__proto__ = Form.prototype = Object.create( Element && Element.prototype );\n  Form__proto__.constructor = Form;\n\n  Form__proto__.render = function render (target, occupants) {\n    Element.prototype.render.call(this, target, occupants);\n    this.on('reset', handleReset);\n  };\n\n  Form__proto__.unrender = function unrender (shouldDestroy) {\n    this.off('reset', handleReset);\n    Element.prototype.unrender.call(this, shouldDestroy);\n  };\n\n  return Form;\n}(Element));\n\nfunction handleReset() {\n  var element = this._ractive.proxy;\n\n  runloop.start();\n  element.formBindings.forEach(updateModel);\n  runloop.end();\n}\n\nfunction updateModel(binding) {\n  binding.model.set(binding.resetValue);\n}\n\nvar DOMEvent = function DOMEvent(name, owner) {\n  if (name.indexOf('*') !== -1) {\n    fatal(\n      (\"Only component proxy-events may contain \\\"*\\\" wildcards, <\" + (owner.name) + \" on-\" + name + \"=\\\"...\\\"/> is not valid\")\n    );\n  }\n\n  this.name = name;\n  this.owner = owner;\n  this.handler = null;\n};\nvar DOMEvent__proto__ = DOMEvent.prototype;\n\nDOMEvent__proto__.bind = function bind () {};\n\nDOMEvent__proto__.render = function render (directive) {\n    var this$1 = this;\n\n  var name = this.name;\n\n  var register = function () {\n    var node = this$1.owner.node;\n\n    this$1.owner.on(\n      name,\n      (this$1.handler = function (event) {\n        return directive.fire({\n          node: node,\n          original: event,\n          event: event,\n          name: name\n        });\n      })\n    );\n  };\n\n  if (name !== 'load') {\n    // schedule events so that they take place after twoway binding\n    runloop.scheduleTask(register, true);\n  } else {\n    // unless its a load event\n    register();\n  }\n};\n\nDOMEvent__proto__.unbind = function unbind () {};\n\nDOMEvent__proto__.unrender = function unrender () {\n  if (this.handler) { this.owner.off(this.name, this.handler); }\n};\n\nvar CustomEvent = function CustomEvent(eventPlugin, owner, name, args) {\n  this.eventPlugin = eventPlugin;\n  this.owner = owner;\n  this.name = name;\n  this.handler = null;\n  this.args = args;\n};\nvar CustomEvent__proto__ = CustomEvent.prototype;\n\nCustomEvent__proto__.bind = function bind () {};\n\nCustomEvent__proto__.render = function render (directive) {\n    var this$1 = this;\n\n  runloop.scheduleTask(function () {\n    var node = this$1.owner.node;\n\n    localFragment.f = directive.up;\n    this$1.handler = this$1.eventPlugin.apply(\n      this$1.owner.ractive,\n      [\n        node,\n        function (event) {\n            if ( event === void 0 ) event = {};\n\n          if (event.original) { event.event = event.original; }\n          else { event.original = event.event; }\n\n          event.name = this$1.name;\n          event.node = event.node || node;\n          return directive.fire(event);\n        }\n      ].concat(this$1.args || [])\n    );\n    localFragment.f = null;\n  });\n};\n\nCustomEvent__proto__.unbind = function unbind () {};\n\nCustomEvent__proto__.unrender = function unrender () {\n    var this$1 = this;\n\n  if (this.handler) { this.handler.teardown(); }\n  else { runloop.scheduleTask(function () { return this$1.handler && this$1.handler.teardown(); }); }\n};\n\nvar RactiveEvent = function RactiveEvent(component, name) {\n  this.component = component;\n  this.name = name;\n  this.handler = null;\n};\nvar RactiveEvent__proto__ = RactiveEvent.prototype;\n\nRactiveEvent__proto__.bind = function bind (directive) {\n  var ractive = this.component.instance;\n\n  this.handler = ractive.on(this.name, function () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n    // watch for reproxy\n    if (args[0] instanceof Context) {\n      var ctx = args.shift();\n      ctx.component = ractive;\n      directive.fire(ctx, args);\n    } else {\n      directive.fire({}, args);\n    }\n\n    // cancel bubbling\n    return false;\n  });\n};\n\nRactiveEvent__proto__.render = function render () {};\n\nRactiveEvent__proto__.unbind = function unbind () {\n  this.handler.cancel();\n};\n\nRactiveEvent__proto__.unrender = function unrender () {};\n\nvar specialPattern = /^(event|arguments|@node|@event|@context)(\\..+)?$/;\nvar dollarArgsPattern = /^\\$(\\d+)(\\..+)?$/;\n\nvar EventDirective = function EventDirective(options) {\n  this.owner = options.owner || options.up.owner || findElement(options.up);\n  this.element = this.owner.attributeByName ? this.owner : findElement(options.up, true);\n  this.template = options.template;\n  this.up = options.up;\n  this.ractive = options.up.ractive;\n  this.events = [];\n};\nvar EventDirective__proto__ = EventDirective.prototype;\n\nEventDirective__proto__.bind = function bind () {\n    var this$1 = this;\n\n  // sometimes anchors will cause an unbind without unrender\n  if (this.events.length) {\n    this.events.forEach(function (e) { return e.unrender(); });\n    this.events = [];\n  }\n\n  if (this.element.type === COMPONENT || this.element.type === ANCHOR) {\n    this.template.n.forEach(function (n) {\n      this$1.events.push(new RactiveEvent(this$1.element, n));\n    });\n  } else {\n    var args;\n    if ((args = this.template.a)) {\n      var rs = args.r.map(function (r) {\n        var model = resolveReference(this$1.up, r);\n        return model ? model.get() : undefined;\n      });\n      try {\n        args = getFunction(args.s, rs.length).apply(null, rs);\n      } catch (err) {\n        args = null;\n        warnIfDebug(\n          (\"Failed to compute args for event on-\" + (this.template.n.join('- ')) + \": \" + (err.message ||\n            err))\n        );\n      }\n    }\n\n    this.template.n.forEach(function (n) {\n      var fn = findInViewHierarchy('events', this$1.ractive, n);\n      if (fn) {\n        this$1.events.push(new CustomEvent(fn, this$1.element, n, args));\n      } else {\n        this$1.events.push(new DOMEvent(n, this$1.element));\n      }\n    });\n  }\n\n  // method calls\n  this.models = null;\n\n  addToArray(this.element.events || (this.element.events = []), this);\n\n  setupArgsFn(this, this.template);\n  if (!this.fn) { this.action = this.template.f; }\n\n  this.events.forEach(function (e) { return e.bind(this$1); });\n};\n\nEventDirective__proto__.destroyed = function destroyed () {\n  this.events.forEach(function (e) { return e.unrender(); });\n};\n\nEventDirective__proto__.fire = function fire (event, args) {\n    var this$1 = this;\n    if ( args === void 0 ) args = [];\n\n  var context =\n    event instanceof Context && event.refire ? event : this.element.getContext(event);\n\n  if (this.fn) {\n    var values = [];\n\n    var models = resolveArgs(this, this.template, this.up, {\n      specialRef: function specialRef(ref) {\n        var specialMatch = specialPattern.exec(ref);\n        if (specialMatch) {\n          // on-click=\"foo(event.node)\"\n          return {\n            special: specialMatch[1],\n            keys: specialMatch[2] ? splitKeypath(specialMatch[2].substr(1)) : []\n          };\n        }\n\n        var dollarMatch = dollarArgsPattern.exec(ref);\n        if (dollarMatch) {\n          // on-click=\"foo($1)\"\n          return {\n            special: 'arguments',\n            keys: [dollarMatch[1] - 1].concat(\n              dollarMatch[2] ? splitKeypath(dollarMatch[2].substr(1)) : []\n            )\n          };\n        }\n      }\n    });\n\n    if (models) {\n      models.forEach(function (model) {\n        if (!model) { return values.push(undefined); }\n\n        if (model.special) {\n          var which = model.special;\n          var obj;\n\n          if (which === '@node') {\n            obj = this$1.element.node;\n          } else if (which === '@event') {\n            obj = event && event.event;\n          } else if (which === 'event') {\n            warnOnceIfDebug(\n              \"The event reference available to event directives is deprecated and should be replaced with @context and @event\"\n            );\n            obj = context;\n          } else if (which === '@context') {\n            obj = context;\n          } else {\n            obj = args;\n          }\n\n          var keys = model.keys.slice();\n\n          while (obj && keys.length) { obj = obj[keys.shift()]; }\n          return values.push(obj);\n        }\n\n        if (model.wrapper) {\n          return values.push(model.wrapperValue);\n        }\n\n        values.push(model.get());\n      });\n    }\n\n    // make event available as `this.event`\n    var ractive = this.ractive;\n    var oldEvent = ractive.event;\n\n    ractive.event = context;\n    var returned = this.fn.apply(ractive, values);\n    var result = returned.pop();\n\n    // Auto prevent and stop if return is explicitly false\n    if (result === false) {\n      var original = event ? event.original : undefined;\n      if (original) {\n        original.preventDefault && original.preventDefault();\n        original.stopPropagation && original.stopPropagation();\n      } else {\n        warnOnceIfDebug(\n          (\"handler '\" + (this.template.n.join(\n            ' '\n          )) + \"' returned false, but there is no event available to cancel\")\n        );\n      }\n    } else if (!returned.length && isArray(result) && isString(result[0])) {\n      // watch for proxy events\n      result = fireEvent(this.ractive, result.shift(), context, result);\n    }\n\n    ractive.event = oldEvent;\n\n    return result;\n  } else {\n    return fireEvent(this.ractive, this.action, context, args);\n  }\n};\n\nEventDirective__proto__.handleChange = function handleChange () {};\n\nEventDirective__proto__.render = function render () {\n    var this$1 = this;\n\n  this.events.forEach(function (e) { return e.render(this$1); });\n};\n\nEventDirective__proto__.toString = function toString () {\n  return '';\n};\n\nEventDirective__proto__.unbind = function unbind (view) {\n  removeFromArray(this.element.events, this);\n  this.events.forEach(function (e) { return e.unbind(view); });\n};\n\nEventDirective__proto__.unrender = function unrender () {\n  this.events.forEach(function (e) { return e.unrender(); });\n};\n\nvar proto$3 = EventDirective.prototype;\nproto$3.firstNode = proto$3.rebound = proto$3.update = noop;\n\nfunction progressiveText(item, target, occupants, text) {\n  if (occupants) {\n    var n = occupants[0];\n    if (n && n.nodeType === 3) {\n      var idx = n.nodeValue.indexOf(text);\n      occupants.shift();\n\n      if (idx === 0) {\n        if (n.nodeValue.length !== text.length) {\n          occupants.unshift(n.splitText(text.length));\n        }\n      } else {\n        n.nodeValue = text;\n      }\n    } else {\n      n = item.node = doc.createTextNode(text);\n      if (occupants[0]) {\n        target.insertBefore(n, occupants[0]);\n      } else {\n        target.appendChild(n);\n      }\n    }\n\n    item.node = n;\n  } else {\n    if (!item.node) { item.node = doc.createTextNode(text); }\n    target.appendChild(item.node);\n  }\n}\n\nvar ReferenceExpressionProxy = (function (LinkModel) {\n  function ReferenceExpressionProxy(fragment, template) {\n    LinkModel.call(this, null, null, null, '@undefined');\n    this.root = fragment.ractive.viewmodel;\n    this.template = template;\n    this.rootLink = true;\n    this.template = template;\n    this.fragment = fragment;\n\n    this.rebound();\n  }\n\n  if ( LinkModel ) ReferenceExpressionProxy.__proto__ = LinkModel;\n  var ReferenceExpressionProxy__proto__ = ReferenceExpressionProxy.prototype = Object.create( LinkModel && LinkModel.prototype );\n  ReferenceExpressionProxy__proto__.constructor = ReferenceExpressionProxy;\n\n  ReferenceExpressionProxy__proto__.getKeypath = function getKeypath () {\n    return this.model ? this.model.getKeypath() : '@undefined';\n  };\n\n  ReferenceExpressionProxy__proto__.rebound = function rebound () {\n    var this$1 = this;\n\n    var fragment = this.fragment;\n    var template = this.template;\n\n    var base = (this.base = resolve(fragment, template));\n    var idx;\n\n    if (this.proxy) {\n      teardown$2(this);\n    }\n\n    var proxy = (this.proxy = {\n      rebind: function (next, previous) {\n        if (previous === base) {\n          next = rebindMatch(template, next, previous);\n          if (next !== base) {\n            this$1.base = base = next;\n          }\n        } else if (~(idx = members.indexOf(previous))) {\n          next = rebindMatch(template.m[idx].n, next, previous);\n          if (next !== members[idx]) {\n            members.splice(idx, 1, next || Missing);\n          }\n        }\n\n        if (next !== previous) {\n          previous.unregister(proxy);\n          if (next) { next.addShuffleTask(function () { return next.register(proxy); }); }\n        }\n      },\n      handleChange: function () {\n        pathChanged();\n      }\n    });\n\n    base.register(proxy);\n\n    var members = (this.members = template.m.map(function (tpl) {\n      if (isString(tpl)) {\n        return { get: function () { return tpl; } };\n      }\n\n      var model;\n\n      if (tpl.t === REFERENCE) {\n        model = resolveReference(fragment, tpl.n);\n        model.register(proxy);\n\n        return model;\n      }\n\n      model = new ExpressionProxy(fragment, tpl);\n      model.register(proxy);\n      return model;\n    }));\n\n    var pathChanged = function () {\n      var model =\n        base &&\n        base.joinAll(\n          members.reduce(function (list, m) {\n            var k = m.get();\n            if (isArray(k)) { return list.concat(k); }\n            else { list.push(escapeKey(String(k))); }\n            return list;\n          }, [])\n        );\n\n      if (model !== this$1.model) {\n        this$1.model = model;\n        this$1.relinking(model);\n        fireShuffleTasks();\n        refreshPathDeps(this$1);\n        this$1.fragment.shuffled();\n      }\n    };\n\n    pathChanged();\n  };\n\n  ReferenceExpressionProxy__proto__.teardown = function teardown () {\n    teardown$2(this);\n    LinkModel.prototype.teardown.call(this);\n  };\n\n  ReferenceExpressionProxy__proto__.unreference = function unreference () {\n    LinkModel.prototype.unreference.call(this);\n    if (!this.deps.length && !this.refs) { this.teardown(); }\n  };\n\n  ReferenceExpressionProxy__proto__.unregister = function unregister (dep) {\n    LinkModel.prototype.unregister.call(this, dep);\n    if (!this.deps.length && !this.refs) { this.teardown(); }\n  };\n\n  return ReferenceExpressionProxy;\n}(LinkModel));\n\nfunction teardown$2(proxy) {\n  if (proxy.base) { proxy.base.unregister(proxy.proxy); }\n  if (proxy.models) {\n    proxy.models.forEach(function (m) {\n      if (m.unregister) { m.unregister(proxy); }\n    });\n  }\n}\n\nfunction refreshPathDeps(proxy) {\n  var len = proxy.deps.length;\n  var i, v;\n\n  for (i = 0; i < len; i++) {\n    v = proxy.deps[i];\n    if (v.pathChanged) { v.pathChanged(); }\n    if (v.fragment && v.fragment.pathModel) { v.fragment.pathModel.applyValue(proxy.getKeypath()); }\n  }\n\n  len = proxy.children.length;\n  for (i = 0; i < len; i++) {\n    refreshPathDeps(proxy.children[i]);\n  }\n}\n\nvar eproto = ExpressionProxy.prototype;\nvar proto$4 = ReferenceExpressionProxy.prototype;\n\nproto$4.unreference = eproto.unreference;\nproto$4.unregister = eproto.unregister;\nproto$4.unregisterLink = eproto.unregisterLink;\n\nfunction resolve(fragment, template) {\n  if (template.r) {\n    return resolveReference(fragment, template.r);\n  } else if (template.x) {\n    return new ExpressionProxy(fragment, template.x);\n  } else if (template.rx) {\n    return new ReferenceExpressionProxy(fragment, template.rx);\n  }\n}\n\nvar Mustache = (function (Item) {\n  function Mustache(options) {\n    Item.call(this, options);\n\n    if (options.owner) { this.parent = options.owner; }\n\n    this.isStatic = !!options.template.s;\n\n    this.model = null;\n    this.dirty = false;\n  }\n\n  if ( Item ) Mustache.__proto__ = Item;\n  var Mustache__proto__ = Mustache.prototype = Object.create( Item && Item.prototype );\n  Mustache__proto__.constructor = Mustache;\n\n  Mustache__proto__.bind = function bind (pre) {\n    // yield mustaches and inner contexts should resolve in container context\n    var start = this.template.y\n      ? this.template.y.containerFragment\n      : this.containerFragment || this.up;\n    // try to find a model for this view\n    var model = pre || resolve(start, this.template);\n\n    if (model) {\n      var value = model.get();\n\n      if (this.isStatic) {\n        this.model = { get: function () { return value; } };\n        model.unreference();\n        return;\n      }\n\n      model.register(this);\n      this.model = model;\n    }\n  };\n\n  Mustache__proto__.handleChange = function handleChange () {\n    this.bubble();\n  };\n\n  Mustache__proto__.rebind = function rebind (next, previous, safe) {\n    if (this.isStatic) { return; }\n\n    next = rebindMatch(this.template, next, previous, this.up);\n    if (next === this.model) { return false; }\n\n    if (this.model) {\n      this.model.unregister(this);\n    }\n    if (next) { next.addShuffleRegister(this, 'mark'); }\n    this.model = next;\n    if (!safe) { this.handleChange(); }\n    return true;\n  };\n\n  Mustache__proto__.rebound = function rebound (update) {\n    if (this.model) {\n      if (this.model.rebound) { this.model.rebound(update); }\n      else {\n        // check to see if the model actually changed...\n        // yield mustaches and inner contexts should resolve in container context\n        var start = this.template.y\n          ? this.template.y.containerFragment\n          : this.containerFragment || this.up;\n        // try to find a model for this view\n        var model = resolve(start, this.template);\n        if (model !== this.model) {\n          this.model.unregister(this);\n          this.bind(model);\n        }\n      }\n\n      if (update) { this.bubble(); }\n    }\n    if (this.fragment) { this.fragment.rebound(update); }\n  };\n\n  Mustache__proto__.unbind = function unbind () {\n    if (!this.isStatic) {\n      this.model && this.model.unregister(this);\n      this.model = undefined;\n    }\n  };\n\n  return Mustache;\n}(Item));\n\nfunction MustacheContainer(options) {\n  Mustache.call(this, options);\n}\n\nvar proto$5 = (MustacheContainer.prototype = Object.create(ContainerItem.prototype));\n\nassign(proto$5, Mustache.prototype, { constructor: MustacheContainer });\n\nvar Interpolator = (function (Mustache) {\n  function Interpolator () {\n    Mustache.apply(this, arguments);\n  }\n\n  if ( Mustache ) Interpolator.__proto__ = Mustache;\n  var Interpolator__proto__ = Interpolator.prototype = Object.create( Mustache && Mustache.prototype );\n  Interpolator__proto__.constructor = Interpolator;\n\n  Interpolator__proto__.bubble = function bubble () {\n    if (this.owner) { this.owner.bubble(); }\n    Mustache.prototype.bubble.call(this);\n  };\n\n  Interpolator__proto__.detach = function detach () {\n    return detachNode(this.node);\n  };\n\n  Interpolator__proto__.firstNode = function firstNode () {\n    return this.node;\n  };\n\n  Interpolator__proto__.getString = function getString () {\n    return this.model ? safeToStringValue(this.model.get()) : '';\n  };\n\n  Interpolator__proto__.render = function render (target, occupants) {\n    if (inAttributes()) { return; }\n    var value = (this.value = this.getString());\n\n    this.rendered = true;\n\n    progressiveText(this, target, occupants, value);\n  };\n\n  Interpolator__proto__.toString = function toString (escape) {\n    var string = this.getString();\n    return escape ? escapeHtml(string) : string;\n  };\n\n  Interpolator__proto__.unrender = function unrender (shouldDestroy) {\n    if (shouldDestroy) { this.detach(); }\n    this.rendered = false;\n  };\n\n  Interpolator__proto__.update = function update () {\n    if (this.dirty) {\n      this.dirty = false;\n      if (this.rendered) {\n        var value = this.getString();\n        if (value !== this.value) { this.node.data = this.value = value; }\n      }\n    }\n  };\n\n  Interpolator__proto__.valueOf = function valueOf () {\n    return this.model ? this.model.get() : undefined;\n  };\n\n  return Interpolator;\n}(Mustache));\n\nvar Input = (function (Element) {\n  function Input () {\n    Element.apply(this, arguments);\n  }\n\n  if ( Element ) Input.__proto__ = Element;\n  var Input__proto__ = Input.prototype = Object.create( Element && Element.prototype );\n  Input__proto__.constructor = Input;\n\n  Input__proto__.render = function render (target, occupants) {\n    Element.prototype.render.call(this, target, occupants);\n    this.node.defaultValue = this.node.value;\n  };\n  Input__proto__.compare = function compare (value, attrValue) {\n    var comparator = this.getAttribute('value-comparator');\n    if (comparator) {\n      if (isFunction(comparator)) {\n        return comparator(value, attrValue);\n      }\n      if (value && attrValue) {\n        return value[comparator] == attrValue[comparator];\n      }\n    }\n    return value == attrValue;\n  };\n\n  return Input;\n}(Element));\n\n// simple JSON parser, without the restrictions of JSON parse\n// (i.e. having to double-quote keys).\n//\n// If passed a hash of values as the second argument, ${placeholders}\n// will be replaced with those values\n\nvar specials$1 = {\n  true: true,\n  false: false,\n  null: null,\n  undefined: undefined\n};\n\nvar specialsPattern = new RegExp('^(?:' + keys(specials$1).join('|') + ')');\nvar numberPattern$1 = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\nvar placeholderPattern = /\\$\\{([^\\}]+)\\}/g;\nvar placeholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\nvar onlyWhitespace$1 = /^\\s*$/;\n\nvar JsonParser = Parser.extend({\n  init: function init(str, options) {\n    this.values = options.values;\n    this.sp();\n  },\n\n  postProcess: function postProcess(result) {\n    if (result.length !== 1 || !onlyWhitespace$1.test(this.leftover)) {\n      return null;\n    }\n\n    return { value: result[0].v };\n  },\n\n  converters: [\n    function getPlaceholder(parser) {\n      if (!parser.values) { return null; }\n\n      var placeholder = parser.matchPattern(placeholderAtStartPattern);\n\n      if (placeholder && hasOwn(parser.values, placeholder)) {\n        return { v: parser.values[placeholder] };\n      }\n    },\n\n    function getSpecial(parser) {\n      var special = parser.matchPattern(specialsPattern);\n      if (special) { return { v: specials$1[special] }; }\n    },\n\n    function getNumber(parser) {\n      var number = parser.matchPattern(numberPattern$1);\n      if (number) { return { v: +number }; }\n    },\n\n    function getString(parser) {\n      var stringLiteral = readStringLiteral(parser);\n      var values = parser.values;\n\n      if (stringLiteral && values) {\n        return {\n          v: stringLiteral.v.replace(placeholderPattern, function (match, $1) { return $1 in values ? values[$1] : $1; }\n          )\n        };\n      }\n\n      return stringLiteral;\n    },\n\n    function getObject(parser) {\n      if (!parser.matchString('{')) { return null; }\n\n      var result = {};\n\n      parser.sp();\n\n      if (parser.matchString('}')) {\n        return { v: result };\n      }\n\n      var pair;\n      while ((pair = getKeyValuePair(parser))) {\n        result[pair.key] = pair.value;\n\n        parser.sp();\n\n        if (parser.matchString('}')) {\n          return { v: result };\n        }\n\n        if (!parser.matchString(',')) {\n          return null;\n        }\n      }\n\n      return null;\n    },\n\n    function getArray(parser) {\n      if (!parser.matchString('[')) { return null; }\n\n      var result = [];\n\n      parser.sp();\n\n      if (parser.matchString(']')) {\n        return { v: result };\n      }\n\n      var valueToken;\n      while ((valueToken = parser.read())) {\n        result.push(valueToken.v);\n\n        parser.sp();\n\n        if (parser.matchString(']')) {\n          return { v: result };\n        }\n\n        if (!parser.matchString(',')) {\n          return null;\n        }\n\n        parser.sp();\n      }\n\n      return null;\n    }\n  ]\n});\n\nfunction getKeyValuePair(parser) {\n  parser.sp();\n\n  var key = readKey(parser);\n\n  if (!key) { return null; }\n\n  var pair = { key: key };\n\n  parser.sp();\n  if (!parser.matchString(':')) {\n    return null;\n  }\n  parser.sp();\n\n  var valueToken = parser.read();\n\n  if (!valueToken) { return null; }\n\n  pair.value = valueToken.v;\n  return pair;\n}\n\nfunction parseJSON(str, values) {\n  var parser = new JsonParser(str, { values: values });\n  return parser.result;\n}\n\nvar Mapping = (function (Item) {\n  function Mapping(options) {\n    Item.call(this, options);\n\n    this.name = options.template.n;\n\n    this.owner = options.owner || options.up.owner || options.element || findElement(options.up);\n    this.element =\n      options.element || (this.owner.attributeByName ? this.owner : findElement(options.up));\n    this.up = this.element.up; // shared\n    this.ractive = this.up.ractive;\n\n    this.element.attributeByName[this.name] = this;\n\n    this.value = options.template.f;\n  }\n\n  if ( Item ) Mapping.__proto__ = Item;\n  var Mapping__proto__ = Mapping.prototype = Object.create( Item && Item.prototype );\n  Mapping__proto__.constructor = Mapping;\n\n  Mapping__proto__.bind = function bind () {\n    var template = this.template.f;\n    var viewmodel = this.element.instance.viewmodel;\n\n    if (template === 0) {\n      // empty attributes are `true`\n      viewmodel.joinKey(this.name).set(true);\n    } else if (isString(template)) {\n      var parsed = parseJSON(template);\n      viewmodel.joinKey(this.name).set(parsed ? parsed.value : template);\n    } else if (isArray(template)) {\n      createMapping(this, true);\n    }\n  };\n\n  Mapping__proto__.rebound = function rebound (update) {\n    if (this.boundFragment) { this.boundFragment.rebound(update); }\n    if (this.link) {\n      this.model = resolve(this.up, this.template.f[0]);\n      var model = this.element.instance.viewmodel.joinAll(splitKeypath(this.name));\n      model.link(this.model, this.name, { mapping: true });\n    }\n  };\n\n  Mapping__proto__.render = function render () {};\n\n  Mapping__proto__.unbind = function unbind (view) {\n    if (this.model) { this.model.unregister(this); }\n    if (this.boundFragment) { this.boundFragment.unbind(view); }\n\n    if (this.element.bound) {\n      if (this.link.target === this.model) { this.link.owner.unlink(); }\n    }\n  };\n\n  Mapping__proto__.unrender = function unrender () {};\n\n  Mapping__proto__.update = function update () {\n    if (this.dirty) {\n      this.dirty = false;\n      if (this.boundFragment) { this.boundFragment.update(); }\n    }\n  };\n\n  return Mapping;\n}(Item));\n\nfunction createMapping(item) {\n  var template = item.template.f;\n  var viewmodel = item.element.instance.viewmodel;\n  var childData = viewmodel.value;\n\n  if (template.length === 1 && template[0].t === INTERPOLATOR) {\n    var model = resolve(item.up, template[0]);\n    var val = model.get(false);\n\n    // if the interpolator is not static\n    if (!template[0].s) {\n      item.model = model;\n      item.link = viewmodel.createLink(item.name, model, template[0].r, {\n        mapping: true\n      });\n\n      // initialize parent side of the mapping from child data\n      if (isUndefined(val) && !model.isReadonly && item.name in childData) {\n        model.set(childData[item.name]);\n      }\n    } else if (!isObjectType(val) || template[0].x) {\n      // copy non-object, non-computed vals through\n      viewmodel.joinKey(splitKeypath(item.name)).set(val);\n    } else {\n      // warn about trying to copy an object\n      warnIfDebug((\"Cannot copy non-computed object value from static mapping '\" + (item.name) + \"'\"));\n    }\n\n    // if the item isn't going to manage the model, give it a change to tear down if it's computed\n    if (model !== item.model) { model.unregister(); }\n  } else {\n    item.boundFragment = new Fragment({\n      owner: item,\n      template: template\n    }).bind();\n\n    item.model = viewmodel.joinKey(splitKeypath(item.name));\n    item.model.set(item.boundFragment.valueOf());\n\n    // item is a *bit* of a hack\n    item.boundFragment.bubble = function () {\n      Fragment.prototype.bubble.call(item.boundFragment);\n      // defer this to avoid mucking around model deps if there happens to be an expression involved\n      runloop.scheduleTask(function () {\n        item.boundFragment.update();\n        item.model.set(item.boundFragment.valueOf());\n      });\n    };\n  }\n}\n\nvar Option = (function (Element) {\n  function Option(options) {\n    var template = options.template;\n    if (!template.a) { template.a = {}; }\n\n    // If the value attribute is missing, use the element's content,\n    // as long as it isn't disabled\n    if (isUndefined(template.a.value) && !('disabled' in template.a)) {\n      template.a.value = template.f || '';\n    }\n\n    Element.call(this, options);\n\n    this.select = findElement(this.parent || this.up, false, 'select');\n  }\n\n  if ( Element ) Option.__proto__ = Element;\n  var Option__proto__ = Option.prototype = Object.create( Element && Element.prototype );\n  Option__proto__.constructor = Option;\n\n  Option__proto__.bind = function bind () {\n    if (!this.select) {\n      Element.prototype.bind.call(this);\n      return;\n    }\n\n    // If the select has a value, it overrides the `selected` attribute on\n    // this option - so we delete the attribute\n    var selectedAttribute = this.attributeByName.selected;\n    if (selectedAttribute && this.select.getAttribute('value') !== undefined) {\n      var index = this.attributes.indexOf(selectedAttribute);\n      this.attributes.splice(index, 1);\n      delete this.attributeByName.selected;\n    }\n\n    Element.prototype.bind.call(this);\n    this.select.options.push(this);\n  };\n\n  Option__proto__.bubble = function bubble () {\n    // if we're using content as value, may need to update here\n    var value = this.getAttribute('value');\n    if (this.node && this.node.value !== value) {\n      this.node._ractive.value = value;\n    }\n    Element.prototype.bubble.call(this);\n  };\n\n  Option__proto__.getAttribute = function getAttribute (name) {\n    var attribute = this.attributeByName[name];\n    return attribute\n      ? attribute.getValue()\n      : name === 'value' && this.fragment\n      ? this.fragment.valueOf()\n      : undefined;\n  };\n\n  Option__proto__.isSelected = function isSelected () {\n    var this$1 = this;\n\n    var optionValue = this.getAttribute('value');\n\n    if (isUndefined(optionValue) || !this.select) {\n      return false;\n    }\n\n    var selectValue = this.select.getAttribute('value');\n\n    if (this.select.compare(selectValue, optionValue)) {\n      return true;\n    }\n\n    if (this.select.getAttribute('multiple') && isArray(selectValue)) {\n      var i = selectValue.length;\n      while (i--) {\n        if (this$1.select.compare(selectValue[i], optionValue)) {\n          return true;\n        }\n      }\n    }\n  };\n\n  Option__proto__.render = function render (target, occupants) {\n    Element.prototype.render.call(this, target, occupants);\n\n    if (!this.attributeByName.value) {\n      this.node._ractive.value = this.getAttribute('value');\n    }\n  };\n\n  Option__proto__.unbind = function unbind (view) {\n    Element.prototype.unbind.call(this, view);\n\n    if (this.select) {\n      removeFromArray(this.select.options, this);\n    }\n  };\n\n  return Option;\n}(Element));\n\nfunction getPartialTemplate(ractive, name, up) {\n  // If the partial in instance or view heirarchy instances, great\n  var partial = getPartialFromRegistry(ractive, name, up || {});\n  if (partial) { return partial; }\n\n  // Does it exist on the page as a script tag?\n  partial = parser.fromId(name, { noThrow: true });\n  if (partial) {\n    // parse and register to this ractive instance\n    var parsed = parser.parseFor(partial, ractive);\n\n    // register extra partials on the ractive instance if they don't already exist\n    if (parsed.p) { fillGaps(ractive.partials, parsed.p); }\n\n    // register (and return main partial if there are others in the template)\n    return (ractive.partials[name] = parsed.t);\n  }\n}\n\nfunction getPartialFromRegistry(ractive, name, up) {\n  // if there was an instance up-hierarchy, cool\n  var partial = findParentPartial(name, up.owner);\n  if (partial) { return partial; }\n\n  // find first instance in the ractive or view hierarchy that has this partial\n  var instance = findInstance('partials', ractive, name);\n\n  if (!instance) {\n    return;\n  }\n\n  partial = instance.partials[name];\n\n  // partial is a function?\n  var fn;\n  if (isFunction(partial)) {\n    fn = partial;\n    // super partial\n    if (fn.styleSet) { return fn; }\n\n    fn = partial.bind(instance);\n    fn.isOwner = hasOwn(instance.partials, name);\n    partial = fn.call(ractive, parser);\n  }\n\n  if (!partial && partial !== '') {\n    warnIfDebug(noRegistryFunctionReturn, name, 'partial', 'partial', {\n      ractive: ractive\n    });\n    return;\n  }\n\n  // If this was added manually to the registry,\n  // but hasn't been parsed, parse it now\n  if (!parser.isParsed(partial)) {\n    // use the parseOptions of the ractive instance on which it was found\n    var parsed = parser.parseFor(partial, instance);\n\n    // Partials cannot contain nested partials!\n    // TODO add a test for this\n    if (parsed.p) {\n      warnIfDebug('Partials ({{>%s}}) cannot contain nested inline partials', name, { ractive: ractive });\n    }\n\n    // if fn, use instance to store result, otherwise needs to go\n    // in the correct point in prototype chain on instance or constructor\n    var target = fn ? instance : findOwner(instance, name);\n\n    // may be a template with partials, which need to be registered and main template extracted\n    target.partials[name] = partial = parsed.t;\n  }\n\n  // store for reset\n  if (fn) { partial._fn = fn; }\n\n  // if the partial is a pre-parsed template object, import any expressions and update the registry\n  if (partial.v) {\n    addFunctions(partial);\n    return (instance.partials[name] = partial.t);\n  } else {\n    return partial;\n  }\n}\n\nfunction findOwner(ractive, key) {\n  return hasOwn(ractive.partials, key) ? ractive : findConstructor(ractive.constructor, key);\n}\n\nfunction findConstructor(constructor, key) {\n  if (!constructor) {\n    return;\n  }\n  return hasOwn(constructor.partials, key) ? constructor : findConstructor(constructor.Parent, key);\n}\n\nfunction findParentPartial(name, parent) {\n  if (parent) {\n    if (\n      parent.template &&\n      parent.template.p &&\n      !isArray(parent.template.p) &&\n      hasOwn(parent.template.p, name)\n    ) {\n      return parent.template.p[name];\n    } else if (parent.up && parent.up.owner) {\n      return findParentPartial(name, parent.up.owner);\n    }\n  }\n}\n\nfunction Partial(options) {\n  MustacheContainer.call(this, options);\n\n  var tpl = options.template;\n\n  // yielder is a special form of partial that will later require special handling\n  if (tpl.t === YIELDER) {\n    this.yielder = 1;\n  } else if (tpl.t === ELEMENT) {\n    // this is a macro partial, complete with macro constructor\n    // leaving this as an element will confuse up-template searches\n    this.type = PARTIAL;\n    this.macro = options.macro;\n  }\n}\n\nvar proto$6 = (Partial.prototype = create(MustacheContainer.prototype));\n\nassign(proto$6, {\n  constructor: Partial,\n\n  bind: function bind() {\n    var template = this.template;\n\n    if (this.yielder) {\n      // the container is the instance that owns this node\n      this.container = this.up.ractive;\n      this.component = this.container.component;\n      this.containerFragment = this.up;\n\n      // normal component\n      if (this.component) {\n        // yields skip the owning instance and go straight to the surrounding context\n        this.up = this.component.up;\n\n        // {{yield}} is equivalent to {{yield content}}\n        if (!template.r && !template.x && !template.rx) { this.refName = 'content'; }\n      } else {\n        // plain-ish instance that may be attached to a parent later\n        this.fragment = new Fragment({\n          owner: this,\n          template: []\n        });\n        this.fragment.bind();\n        return;\n      }\n    }\n\n    // this is a macro/super partial\n    if (this.macro) {\n      this.fn = this.macro;\n    } else {\n      // this is a plain partial or yielder\n      if (!this.refName) { this.refName = template.r; }\n\n      // if the refName exists as a partial, this is a plain old partial reference where no model binding will happen\n      if (this.refName) {\n        partialFromValue(this, this.refName);\n      }\n\n      // this is a dynamic/inline partial\n      if (!this.partial && !this.fn) {\n        MustacheContainer.prototype.bind.call(this);\n        if (this.model) { partialFromValue(this, this.model.get()); }\n      }\n    }\n\n    if (!this.partial && !this.fn) {\n      warnOnceIfDebug((\"Could not find template for partial '\" + (this.name) + \"'\"));\n    }\n\n    createFragment(this, this.partial || []);\n\n    // macro/super partial\n    if (this.fn) { initMacro(this); }\n\n    this.fragment.bind();\n  },\n\n  bubble: function bubble() {\n    if (!this.dirty) {\n      this.dirty = true;\n\n      if (this.yielder) {\n        this.containerFragment.bubble();\n      } else {\n        this.up.bubble();\n      }\n    }\n  },\n\n  findNextNode: function findNextNode() {\n    return (this.containerFragment || this.up).findNextNode(this);\n  },\n\n  handleChange: function handleChange() {\n    this.dirtyTemplate = true;\n    this.externalChange = true;\n    this.bubble();\n  },\n\n  rebound: function rebound(update) {\n    var this$1 = this;\n\n    if (this._attrs) {\n      keys(this._attrs).forEach(function (k) { return this$1._attrs[k].rebound(update); });\n    }\n    MustacheContainer.prototype.rebound.call(this, update);\n  },\n\n  refreshAttrs: function refreshAttrs() {\n    var this$1 = this;\n\n    keys(this._attrs).forEach(function (k) {\n      this$1.handle.attributes[k] = !this$1._attrs[k].items.length || this$1._attrs[k].valueOf();\n    });\n  },\n\n  resetTemplate: function resetTemplate() {\n    var this$1 = this;\n\n    if (this.fn && this.proxy) {\n      this.last = 0;\n      if (this.externalChange) {\n        if (isFunction(this.proxy.teardown)) { this.proxy.teardown(); }\n        this.fn = this.proxy = null;\n      } else {\n        this.partial = this.fnTemplate;\n        return true;\n      }\n    }\n\n    this.partial = null;\n\n    if (this.refName) {\n      this.partial = getPartialTemplate(this.ractive, this.refName, this.up);\n    }\n\n    if (!this.partial && this.model) {\n      partialFromValue(this, this.model.get());\n    }\n\n    if (!this.fn) {\n      if (this.last && this.partial === this.last) { return false; }\n      else if (this.partial) {\n        this.last = this.partial;\n        contextifyTemplate(this);\n      }\n    }\n\n    this.unbindAttrs();\n\n    if (this.fn) {\n      initMacro(this);\n      if (isFunction(this.proxy.render)) { runloop.scheduleTask(function () { return this$1.proxy.render(); }); }\n    } else if (!this.partial) {\n      warnOnceIfDebug((\"Could not find template for partial '\" + (this.name) + \"'\"));\n    }\n\n    return true;\n  },\n\n  render: function render(target, occupants) {\n    if (this.fn && this.fn._cssDef && !this.fn._cssDef.applied) { applyCSS(); }\n\n    this.fragment.render(target, occupants);\n\n    if (this.proxy && isFunction(this.proxy.render)) { this.proxy.render(); }\n  },\n\n  unbind: function unbind(view) {\n    this.fragment.unbind(view);\n\n    this.unbindAttrs(view);\n\n    MustacheContainer.prototype.unbind.call(this, view);\n  },\n\n  unbindAttrs: function unbindAttrs(view) {\n    var this$1 = this;\n\n    if (this._attrs) {\n      keys(this._attrs).forEach(function (k) {\n        this$1._attrs[k].unbind(view);\n      });\n    }\n  },\n\n  unrender: function unrender(shouldDestroy) {\n    if (this.proxy && isFunction(this.proxy.teardown)) { this.proxy.teardown(); }\n\n    this.fragment.unrender(shouldDestroy);\n  },\n\n  update: function update() {\n    var this$1 = this;\n\n    var proxy = this.proxy;\n    this.updating = 1;\n\n    if (this.dirtyAttrs) {\n      this.dirtyAttrs = false;\n      keys(this._attrs).forEach(function (k) { return this$1._attrs[k].update(); });\n      this.refreshAttrs();\n      if (isFunction(proxy.update)) { proxy.update(this.handle.attributes); }\n    }\n\n    if (this.dirtyTemplate) {\n      this.dirtyTemplate = false;\n      this.resetTemplate() && this.fragment.resetTemplate(this.partial || []);\n    }\n\n    if (this.dirty) {\n      this.dirty = false;\n      if (proxy && isFunction(proxy.invalidate)) { proxy.invalidate(); }\n      this.fragment.update();\n    }\n\n    this.externalChange = false;\n    this.updating = 0;\n  }\n});\n\nfunction createFragment(self, partial) {\n  self.partial = self.last = partial;\n  contextifyTemplate(self);\n\n  var options = {\n    owner: self,\n    template: self.partial\n  };\n\n  if (self.yielder) { options.ractive = self.container.parent; }\n\n  if (self.fn) { options.cssIds = self.fn._cssIds; }\n\n  self.fragment = new Fragment(options);\n}\n\nfunction contextifyTemplate(self) {\n  if (self.template.c) {\n    self.partial = [{ t: SECTION, n: SECTION_WITH, f: self.partial }];\n    assign(self.partial[0], self.template.c);\n    if (self.yielder) { self.partial[0].y = self; }\n    else { self.partial[0].z = self.template.z; }\n  }\n}\n\nfunction partialFromValue(self, value, okToParse) {\n  var tpl = value;\n\n  if (isArray(tpl)) {\n    self.partial = tpl;\n  } else if (tpl && isObjectType(tpl)) {\n    if (isArray(tpl.t)) { self.partial = tpl.t; }\n    else if (isString(tpl.template))\n      { self.partial = parsePartial(tpl.template, tpl.template, self.ractive).t; }\n  } else if (isFunction(tpl) && tpl.styleSet) {\n    self.fn = tpl;\n    if (self.fragment) { self.fragment.cssIds = tpl._cssIds; }\n  } else if (tpl != null) {\n    tpl = getPartialTemplate(self.ractive, '' + tpl, self.containerFragment || self.up);\n    if (tpl) {\n      self.name = value;\n      if (tpl.styleSet) {\n        self.fn = tpl;\n        if (self.fragment) { self.fragment.cssIds = tpl._cssIds; }\n      } else { self.partial = tpl; }\n    } else if (okToParse) {\n      self.partial = parsePartial('' + value, '' + value, self.ractive).t;\n    } else {\n      self.name = value;\n    }\n  }\n\n  return self.partial;\n}\n\nfunction setTemplate(template) {\n  partialFromValue(this, template, true);\n\n  if (!this.initing) {\n    this.dirtyTemplate = true;\n    this.fnTemplate = this.partial;\n\n    if (this.updating) {\n      this.bubble();\n      runloop.promise();\n    } else {\n      var promise = runloop.start();\n\n      this.bubble();\n      runloop.end();\n\n      return promise;\n    }\n  }\n}\n\nfunction aliasLocal(ref, name) {\n  var aliases = this.fragment.aliases || (this.fragment.aliases = {});\n  if (!name) {\n    aliases[ref] = this._data;\n  } else {\n    aliases[name] = this._data.joinAll(splitKeypath(ref));\n  }\n}\n\nvar extras = 'extra-attributes';\n\nfunction initMacro(self) {\n  var fn = self.fn;\n  var fragment = self.fragment;\n\n  // defensively copy the template in case it changes\n  var template = (self.template = assign({}, self.template));\n  var handle = (self.handle = fragment.getContext({\n    proxy: self,\n    aliasLocal: aliasLocal,\n    name: self.template.e || self.name,\n    attributes: {},\n    setTemplate: setTemplate.bind(self),\n    template: template,\n    macro: fn\n  }));\n\n  if (!template.p) { template.p = {}; }\n  template.p = handle.partials = assign({}, template.p);\n  if (!hasOwn(template.p, 'content')) { template.p.content = template.f || []; }\n\n  if (isArray(fn.attributes)) {\n    self._attrs = {};\n\n    var invalidate = function() {\n      this.dirty = true;\n      self.dirtyAttrs = true;\n      self.bubble();\n    };\n\n    if (isArray(template.m)) {\n      var attrs = template.m;\n      template.p[extras] = template.m = attrs.filter(function (a) { return !~fn.attributes.indexOf(a.n); });\n      attrs\n        .filter(function (a) { return ~fn.attributes.indexOf(a.n); })\n        .forEach(function (a) {\n          var fragment = new Fragment({\n            template: a.f,\n            owner: self\n          });\n          fragment.bubble = invalidate;\n          fragment.findFirstNode = noop;\n          self._attrs[a.n] = fragment;\n        });\n    } else {\n      template.p[extras] = [];\n    }\n  } else {\n    template.p[extras] = template.m;\n  }\n\n  if (self._attrs) {\n    keys(self._attrs).forEach(function (k) {\n      self._attrs[k].bind();\n    });\n    self.refreshAttrs();\n  }\n\n  self.initing = 1;\n  self.proxy = fn.call(self.ractive, handle, handle.attributes) || {};\n  if (!self.partial) { self.partial = []; }\n  self.fnTemplate = self.partial;\n  self.initing = 0;\n\n  contextifyTemplate(self);\n  fragment.resetTemplate(self.partial);\n}\n\nfunction parsePartial(name, partial, ractive) {\n  var parsed;\n\n  try {\n    parsed = parser.parse(partial, parser.getParseOptions(ractive));\n  } catch (e) {\n    warnIfDebug((\"Could not parse partial from expression '\" + name + \"'\\n\" + (e.message)));\n  }\n\n  return parsed || { t: [] };\n}\n\nvar KeyModel = function KeyModel(value, context, instance) {\n  this.value = this.key = value;\n  this.context = context;\n  this.isReadonly = this.isKey = true;\n  this.deps = [];\n  this.links = [];\n  this.children = [];\n  this.instance = instance;\n};\nvar KeyModel__proto__ = KeyModel.prototype;\n\nKeyModel__proto__.applyValue = function applyValue (value) {\n  if (value !== this.value) {\n    this.value = this.key = value;\n    this.deps.forEach(handleChange);\n    this.links.forEach(handleChange);\n    this.children.forEach(function (c) {\n      c.applyValue(c.context.getKeypath(c.instance));\n    });\n  }\n};\n\nKeyModel__proto__.destroyed = function destroyed () {\n  if (this.upstream) { this.upstream.unregisterChild(this); }\n};\n\nKeyModel__proto__.get = function get (shouldCapture) {\n  if (shouldCapture) { capture(this); }\n  return unescapeKey(this.value);\n};\n\nKeyModel__proto__.getKeypath = function getKeypath () {\n  return unescapeKey(this.value);\n};\n\nKeyModel__proto__.has = function has () {\n  return false;\n};\n\nKeyModel__proto__.rebind = function rebind (next, previous) {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) { this$1.deps[i].rebind(next, previous, false); }\n\n  i = this.links.length;\n  while (i--) { this$1.links[i].relinking(next, false); }\n};\n\nKeyModel__proto__.register = function register (dependant) {\n  this.deps.push(dependant);\n};\n\nKeyModel__proto__.registerChild = function registerChild (child) {\n  addToArray(this.children, child);\n  child.upstream = this;\n};\n\nKeyModel__proto__.registerLink = function registerLink (link) {\n  addToArray(this.links, link);\n};\n\nKeyModel__proto__.unregister = function unregister (dependant) {\n  removeFromArray(this.deps, dependant);\n};\n\nKeyModel__proto__.unregisterChild = function unregisterChild (child) {\n  removeFromArray(this.children, child);\n};\n\nKeyModel__proto__.unregisterLink = function unregisterLink (link) {\n  removeFromArray(this.links, link);\n};\n\nKeyModel.prototype.reference = noop;\nKeyModel.prototype.unreference = noop;\n\nvar keypathString = /^\"(\\\\\"|[^\"])+\"$/;\n\nvar RepeatedFragment = function RepeatedFragment(options) {\n  this.parent = options.owner.up;\n\n  // bit of a hack, so reference resolution works without another\n  // layer of indirection\n  this.up = this;\n  this.owner = options.owner;\n  this.ractive = this.parent.ractive;\n  this.delegate =\n    this.ractive.delegate !== false && (this.parent.delegate || findDelegate(this.parent));\n  // delegation disabled by directive\n  if (this.delegate && this.delegate.delegate === false) { this.delegate = false; }\n  // let the element know it's a delegate handler\n  if (this.delegate) { this.delegate.delegate = this.delegate; }\n\n  // encapsulated styles should be inherited until they get applied by an element\n  this.cssIds = 'cssIds' in options ? options.cssIds : this.parent ? this.parent.cssIds : null;\n\n  this.context = null;\n  this.rendered = false;\n  this.iterations = [];\n\n  this.template = options.template;\n\n  this.indexRef = options.indexRef;\n  this.keyRef = options.keyRef;\n\n  this.pendingNewIndices = null;\n  this.previousIterations = null;\n\n  // track array versus object so updates of type rest\n  this.isArray = false;\n};\nvar RepeatedFragment__proto__ = RepeatedFragment.prototype;\n\nRepeatedFragment__proto__.bind = function bind (context) {\n    var this$1 = this;\n\n  this.context = context;\n  this.bound = true;\n  var value = context.get();\n\n  var aliases = (this.aliases = this.owner.template.z && this.owner.template.z.slice());\n\n  var shuffler = aliases && aliases.find(function (a) { return a.n === 'shuffle'; });\n  if (shuffler && shuffler.x && shuffler.x.x) {\n    if (shuffler.x.x.s === 'true') { this.shuffler = true; }\n    else if (keypathString.test(shuffler.x.x.s))\n      { this.shuffler = splitKeypath(shuffler.x.x.s.slice(1, -1)); }\n  }\n\n  if (this.shuffler) { this.values = shuffleValues(this, this.shuffler); }\n\n  if (this.source) { this.source.model.unbind(this.source); }\n  var source = context.isComputed && aliases && aliases.find(function (a) { return a.n === 'source'; });\n  if (source && source.x && source.x.r) {\n    var model = resolve(this, source.x);\n    this.source = {\n      handleChange: function handleChange() {},\n      rebind: function rebind(next) {\n        this.model.unregister(this);\n        this.model = next;\n        next.register(this);\n      }\n    };\n    this.source.model = model;\n    model.register(this.source);\n  }\n\n  // {{#each array}}...\n  if ((this.isArray = isArray(value))) {\n    // we can't use map, because of sparse arrays\n    this.iterations = [];\n    var max = (this.length = value.length);\n    for (var i = 0; i < max; i += 1) {\n      this$1.iterations[i] = this$1.createIteration(i, i);\n    }\n  } else if (isObject(value)) {\n    // {{#each object}}...\n    this.isArray = false;\n\n    // TODO this is a dreadful hack. There must be a neater way\n    if (this.indexRef) {\n      var refs = this.indexRef.split(',');\n      this.keyRef = refs[0];\n      this.indexRef = refs[1];\n    }\n\n    var ks = keys(value);\n    this.length = ks.length;\n\n    this.iterations = ks.map(function (key, index) {\n      return this$1.createIteration(key, index);\n    });\n  }\n\n  return this;\n};\n\nRepeatedFragment__proto__.bubble = function bubble (index) {\n  if (!this.bubbled) { this.bubbled = []; }\n  this.bubbled.push(index);\n\n  if (!this.rebounding) { this.owner.bubble(); }\n};\n\nRepeatedFragment__proto__.createIteration = function createIteration (key, index) {\n  var fragment = new Fragment({\n    owner: this,\n    template: this.template\n  });\n\n  fragment.isIteration = true;\n  fragment.delegate = this.delegate;\n\n  if (this.aliases) { fragment.aliases = {}; }\n  swizzleFragment(this, fragment, key, index);\n\n  return fragment.bind(fragment.context);\n};\n\nRepeatedFragment__proto__.destroyed = function destroyed () {\n    var this$1 = this;\n\n  var len = this.iterations.length;\n  for (var i = 0; i < len; i++) { this$1.iterations[i].destroyed(); }\n  if (this.pathModel) { this.pathModel.destroyed(); }\n  if (this.rootModel) { this.rootModel.destroyed(); }\n};\n\nRepeatedFragment__proto__.detach = function detach () {\n  var docFrag = createDocumentFragment();\n  this.iterations.forEach(function (fragment) { return docFrag.appendChild(fragment.detach()); });\n  return docFrag;\n};\n\nRepeatedFragment__proto__.find = function find (selector, options) {\n  return findMap(this.iterations, function (i) { return i.find(selector, options); });\n};\n\nRepeatedFragment__proto__.findAll = function findAll (selector, options) {\n  return this.iterations.forEach(function (i) { return i.findAll(selector, options); });\n};\n\nRepeatedFragment__proto__.findAllComponents = function findAllComponents (name, options) {\n  return this.iterations.forEach(function (i) { return i.findAllComponents(name, options); });\n};\n\nRepeatedFragment__proto__.findComponent = function findComponent (name, options) {\n  return findMap(this.iterations, function (i) { return i.findComponent(name, options); });\n};\n\nRepeatedFragment__proto__.findContext = function findContext () {\n  return this.context;\n};\n\nRepeatedFragment__proto__.findNextNode = function findNextNode (iteration) {\n    var this$1 = this;\n\n  if (iteration.index < this.iterations.length - 1) {\n    for (var i = iteration.index + 1; i < this.iterations.length; i++) {\n      var node = this$1.iterations[i].firstNode(true);\n      if (node) { return node; }\n    }\n  }\n\n  return this.owner.findNextNode();\n};\n\nRepeatedFragment__proto__.firstNode = function firstNode (skipParent) {\n  return this.iterations[0] ? this.iterations[0].firstNode(skipParent) : null;\n};\n\nRepeatedFragment__proto__.getLast = function getLast () {\n  return this.lastModel || (this.lastModel = new KeyModel(this.length - 1));\n};\n\nRepeatedFragment__proto__.rebind = function rebind (next) {\n    var this$1 = this;\n\n  this.context = next;\n  if (this.source) { return; }\n  if (next) {\n    this.iterations.forEach(function (fragment) {\n      swizzleFragment(this$1, fragment, fragment.key, fragment.index);\n    });\n  }\n};\n\nRepeatedFragment__proto__.rebound = function rebound (update$$1) {\n    var this$1 = this;\n\n  this.context = this.owner.model;\n  this.iterations.forEach(function (f, i) {\n    f.context = contextFor(this$1, f, i);\n    f.rebound(update$$1);\n  });\n};\n\nRepeatedFragment__proto__.render = function render (target, occupants) {\n  var xs = this.iterations;\n  if (xs) {\n    var len = xs.length;\n    for (var i = 0; i < len; i++) {\n      xs[i].render(target, occupants);\n    }\n  }\n\n  this.rendered = true;\n};\n\nRepeatedFragment__proto__.shuffle = function shuffle (newIndices, merge) {\n    var this$1 = this;\n\n  if (!this.pendingNewIndices) { this.previousIterations = this.iterations.slice(); }\n\n  if (!this.pendingNewIndices) { this.pendingNewIndices = []; }\n\n  this.pendingNewIndices.push(newIndices);\n\n  var iterations = [];\n\n  newIndices.forEach(function (newIndex, oldIndex) {\n    if (newIndex === -1) { return; }\n\n    var fragment = this$1.iterations[oldIndex];\n    iterations[newIndex] = fragment;\n\n    if (newIndex !== oldIndex && fragment) {\n      fragment.dirty = true;\n      if (merge) { fragment.shouldRebind = 1; }\n    }\n  });\n\n  this.iterations = iterations;\n\n  // if merging, we're in the midst of an update already\n  if (!merge) { this.bubble(); }\n};\n\nRepeatedFragment__proto__.shuffled = function shuffled$2 () {\n  this.iterations.forEach(shuffled);\n};\n\nRepeatedFragment__proto__.toString = function toString (escape) {\n  return this.iterations ? this.iterations.map(escape ? toEscapedString : toString$1).join('') : '';\n};\n\nRepeatedFragment__proto__.unbind = function unbind (view) {\n  this.bound = false;\n  if (this.source) { this.source.model.unregister(this.source); }\n  var iterations = this.pendingNewIndices ? this.previousIterations : this.iterations;\n  var len = iterations.length;\n  for (var i = 0; i < len; i++) { iterations[i].unbind(view); }\n  return this;\n};\n\nRepeatedFragment__proto__.unrender = function unrender (shouldDestroy) {\n    var this$1 = this;\n\n  var len = this.iterations.length;\n  for (var i = 0; i < len; i++) { this$1.iterations[i].unrender(shouldDestroy); }\n  if (this.pendingNewIndices && this.previousIterations) {\n    len = this.previousIterations.length;\n    for (var i$1 = 0; i$1 < len; i$1++) { this$1.previousIterations[i$1].unrender(shouldDestroy); }\n  }\n  this.rendered = false;\n};\n\nRepeatedFragment__proto__.update = function update$3 () {\n    var this$1 = this;\n\n  if (this.pendingNewIndices) {\n    this.bubbled.length = 0;\n    this.updatePostShuffle();\n    return;\n  }\n\n  if (this.updating) { return; }\n  this.updating = true;\n\n  if (this.shuffler) {\n    var values = shuffleValues(this, this.shuffler);\n    var newIndices = buildNewIndices(this.values, values);\n    if (!newIndices.same) {\n      this.shuffle(newIndices, true);\n      this.updatePostShuffle();\n    } else {\n      this.iterations.forEach(update);\n    }\n  } else {\n    var len = this.iterations.length;\n    for (var i = 0; i < len; i++) {\n      var f = this$1.iterations[i];\n      f && f.idxModel && f.idxModel.applyValue(i);\n    }\n\n    var value = this.context.get();\n    var wasArray = this.isArray;\n\n    var toRemove;\n    var oldKeys;\n    var reset = true;\n    var i$1;\n\n    if ((this.isArray = isArray(value))) {\n      // if there's a source to map back to, make sure everything stays bound correctly\n      if (this.source) {\n        this.rebounding = 1;\n        var source = this.source.model.get();\n        this.iterations.forEach(function (f, c) {\n          if (c < value.length && f.lastValue !== value[c] && ~(i$1 = source.indexOf(value[c]))) {\n            swizzleFragment(this$1, f, c, c);\n            f.rebound(true);\n          }\n        });\n        this.rebounding = 0;\n      }\n\n      if (wasArray) {\n        reset = false;\n        if (this.iterations.length > value.length) {\n          toRemove = this.iterations.splice(value.length);\n        }\n      }\n    } else if (isObject(value) && !wasArray) {\n      reset = false;\n      toRemove = [];\n      oldKeys = {};\n      i$1 = this.iterations.length;\n\n      while (i$1--) {\n        var fragment = this$1.iterations[i$1];\n        if (fragment.key in value) {\n          oldKeys[fragment.key] = true;\n        } else {\n          this$1.iterations.splice(i$1, 1);\n          toRemove.push(fragment);\n        }\n      }\n    }\n\n    var newLength = isArray(value) ? value.length : isObject(value) ? keys(value).length : 0;\n    this.length = newLength;\n    this.updateLast();\n\n    if (reset) {\n      toRemove = this.iterations;\n      this.iterations = [];\n    }\n\n    if (toRemove) {\n      len = toRemove.length;\n      for (var i$2 = 0; i$2 < len; i$2++) { toRemove[i$2].unbind().unrender(true); }\n    }\n\n    // update the remaining ones\n    if (!reset && this.isArray && this.bubbled && this.bubbled.length) {\n      var bubbled = this.bubbled;\n      this.bubbled = [];\n      len = bubbled.length;\n      for (var i$3 = 0; i$3 < len; i$3++)\n        { this$1.iterations[bubbled[i$3]] && this$1.iterations[bubbled[i$3]].update(); }\n    } else {\n      len = this.iterations.length;\n      for (var i$4 = 0; i$4 < len; i$4++) { this$1.iterations[i$4].update(); }\n    }\n\n    // add new iterations\n    var docFrag;\n    var fragment$1;\n\n    if (newLength > this.iterations.length) {\n      docFrag = this.rendered ? createDocumentFragment() : null;\n      i$1 = this.iterations.length;\n\n      if (isArray(value)) {\n        while (i$1 < value.length) {\n          fragment$1 = this$1.createIteration(i$1, i$1);\n\n          this$1.iterations.push(fragment$1);\n          if (this$1.rendered) { fragment$1.render(docFrag); }\n\n          i$1 += 1;\n        }\n      } else if (isObject(value)) {\n        // TODO this is a dreadful hack. There must be a neater way\n        if (this.indexRef && !this.keyRef) {\n          var refs = this.indexRef.split(',');\n          this.keyRef = refs[0];\n          this.indexRef = refs[1];\n        }\n\n        keys(value).forEach(function (key) {\n          if (!oldKeys || !(key in oldKeys)) {\n            fragment$1 = this$1.createIteration(key, i$1);\n\n            this$1.iterations.push(fragment$1);\n            if (this$1.rendered) { fragment$1.render(docFrag); }\n\n            i$1 += 1;\n          }\n        });\n      }\n\n      if (this.rendered) {\n        var parentNode = this.parent.findParentNode();\n        var anchor = this.parent.findNextNode(this.owner);\n\n        parentNode.insertBefore(docFrag, anchor);\n      }\n    }\n  }\n\n  this.updating = false;\n};\n\nRepeatedFragment__proto__.updateLast = function updateLast () {\n  if (this.lastModel) { this.lastModel.applyValue(this.length - 1); }\n};\n\nRepeatedFragment__proto__.updatePostShuffle = function updatePostShuffle () {\n    var this$1 = this;\n\n  var newIndices = this.pendingNewIndices[0];\n  var parentNode = this.rendered ? this.parent.findParentNode() : null;\n  var nextNode = parentNode && this.owner.findNextNode();\n  var docFrag = parentNode ? createDocumentFragment() : null;\n\n  // map first shuffle through\n  this.pendingNewIndices.slice(1).forEach(function (indices) {\n    newIndices.forEach(function (newIndex, oldIndex) {\n      newIndices[oldIndex] = indices[newIndex];\n    });\n  });\n\n  var len = (this.length = this.context.get().length);\n  var prev = this.previousIterations;\n  var iters = this.iterations;\n  var value = this.context.get();\n  var stash = {};\n  var idx, dest, pos, next, anchor, rebound;\n\n  var map = new Array(newIndices.length);\n  newIndices.forEach(function (e, i) { return (map[e] = i); });\n\n  this.updateLast();\n\n  idx = pos = 0;\n  while (idx < len) {\n    // if there's not an existing thing to shuffle, handle that\n    if (isUndefined(map[idx])) {\n      next = iters[idx] = this$1.createIteration(idx, idx);\n      if (parentNode) {\n        anchor = prev[pos];\n        anchor = (anchor && parentNode && anchor.firstNode()) || nextNode;\n\n        next.render(docFrag);\n        parentNode.insertBefore(docFrag, anchor);\n      }\n\n      idx++;\n    } else {\n      dest = newIndices[pos];\n\n      if (dest === -1) {\n        // if it needs to be dropped, drop it\n        prev[pos] && prev[pos].unbind().unrender(true);\n        prev[pos++] = 0;\n      } else if (dest > idx) {\n        // if it needs to move down, stash it\n        stash[dest] = prev[pos];\n        prev[pos++] = null;\n      } else {\n        // get the fragment that goes for this idx\n        iters[idx] = next = iters[idx] || stash[idx] || this$1.createIteration(idx, idx);\n\n        // if it's an existing fragment, swizzle\n        if (stash[idx] || pos !== idx) {\n          rebound = this$1.source && next.lastValue !== value[idx];\n          swizzleFragment(this$1, next, idx, idx);\n        }\n\n        // does next need to be moved?\n        if (parentNode && (stash[idx] || !prev[pos])) {\n          anchor = prev[pos + 1];\n          anchor = (anchor && parentNode && anchor.firstNode()) || nextNode;\n\n          if (stash[idx]) {\n            parentNode.insertBefore(next.detach(), anchor);\n          } else {\n            next.render(docFrag);\n            parentNode.insertBefore(docFrag, anchor);\n          }\n        }\n\n        prev[pos++] = 0;\n        idx++;\n      }\n\n      if (next && isObjectType(next)) {\n        if (next.shouldRebind || rebound) {\n          next.rebound(rebound);\n          next.shouldRebind = 0;\n        }\n        next.update();\n        next.shuffled();\n      }\n    }\n  }\n\n  // clean up any stragglers\n  var plen = prev.length;\n  for (var i = 0; i < plen; i++) { prev[i] && prev[i].unbind().unrender(true); }\n\n  if (this.shuffler) { this.values = shuffleValues(this, this.shuffler); }\n\n  this.pendingNewIndices = null;\n  this.previousIterations = null;\n};\n\nRepeatedFragment.prototype.getContext = getContext;\nRepeatedFragment.prototype.getKeypath = getKeypath;\n\n// find the topmost delegate\nfunction findDelegate(start) {\n  var frag = start;\n  var delegate, el;\n\n  out: while (frag) {\n    // find next element\n    el = 0;\n    while (!el && frag) {\n      if (frag.owner.type === ELEMENT) { el = frag.owner; }\n      if (frag.owner.ractive && frag.owner.ractive.delegate === false) { break out; }\n      frag = frag.parent || frag.componentParent;\n    }\n\n    if (el.delegate === false) { break out; }\n    delegate = el.delegate || el;\n\n    // find next repeated fragment\n    while (frag) {\n      if (frag.iterations) { break; }\n      if (frag.owner.ractive && frag.owner.ractive.delegate === false) { break out; }\n      frag = frag.parent || frag.componentParent;\n    }\n  }\n\n  return delegate;\n}\n\nfunction swizzleFragment(section, fragment, key, idx) {\n  var model = section.context ? contextFor(section, fragment, key) : undefined;\n\n  fragment.key = key;\n  fragment.index = idx;\n  fragment.context = model;\n  if (section.source) { fragment.lastValue = model && model.get(); }\n\n  if (fragment.idxModel) { fragment.idxModel.applyValue(idx); }\n  if (fragment.keyModel) { fragment.keyModel.applyValue(key); }\n  if (fragment.pathModel) {\n    fragment.pathModel.context = model;\n    fragment.pathModel.applyValue(model.getKeypath());\n  }\n  if (fragment.rootModel) {\n    fragment.rootModel.context = model;\n    fragment.rootModel.applyValue(model.getKeypath(fragment.ractive.root));\n  }\n\n  // handle any aliases\n  var aliases = fragment.aliases;\n  section.aliases &&\n    section.aliases.forEach(function (a) {\n      if (a.x.r === '.') { aliases[a.n] = model; }\n      else if (a.x.r === '@index') { aliases[a.n] = fragment.getIndex(); }\n      else if (a.x.r === '@key') { aliases[a.n] = fragment.getKey(); }\n      else if (a.x.r === '@keypath') { aliases[a.n] = fragment.getKeypath(); }\n      else if (a.x.r === '@rootpath') { aliases[a.n] = fragment.getKeypath(true); }\n    });\n}\n\nfunction shuffleValues(section, shuffler) {\n  var array = section.context.get() || [];\n  if (shuffler === true) {\n    return array.slice();\n  } else {\n    return array.map(function (v) { return shuffler.reduce(function (a, c) { return a && a[c]; }, v); });\n  }\n}\n\nfunction contextFor(section, fragment, key) {\n  if (section.source) {\n    var idx;\n    var source = section.source.model.get();\n    if (source.indexOf && ~(idx = source.indexOf(section.context.joinKey(key).get())))\n      { return section.source.model.joinKey(idx); }\n  }\n\n  return section.context.joinKey(key);\n}\n\nfunction isEmpty(value) {\n  return (\n    !value ||\n    (isArray(value) && value.length === 0) ||\n    (isObject(value) && keys(value).length === 0)\n  );\n}\n\nfunction getType(value, hasIndexRef) {\n  if (hasIndexRef || isArray(value)) { return SECTION_EACH; }\n  if (isObjectLike(value)) { return SECTION_IF_WITH; }\n  if (isUndefined(value)) { return null; }\n  return SECTION_IF;\n}\n\nvar Section = (function (MustacheContainer) {\n  function Section(options) {\n    MustacheContainer.call(this, options);\n\n    this.isAlias = options.template.t === ALIAS;\n    this.sectionType = options.template.n || (this.isAlias && SECTION_WITH) || null;\n    this.templateSectionType = this.sectionType;\n    this.subordinate = options.template.l === 1;\n    this.fragment = null;\n  }\n\n  if ( MustacheContainer ) Section.__proto__ = MustacheContainer;\n  var Section__proto__ = Section.prototype = Object.create( MustacheContainer && MustacheContainer.prototype );\n  Section__proto__.constructor = Section;\n\n  Section__proto__.bind = function bind () {\n    MustacheContainer.prototype.bind.call(this);\n\n    if (this.subordinate) {\n      this.sibling = this.up.items[this.up.items.indexOf(this) - 1];\n      this.sibling.nextSibling = this;\n    }\n\n    // if we managed to bind, we need to create children\n    if (this.model || this.isAlias) {\n      this.dirty = true;\n      this.update();\n    } else if (\n      this.sectionType &&\n      this.sectionType === SECTION_UNLESS &&\n      (!this.sibling || !this.sibling.isTruthy())\n    ) {\n      this.fragment = new Fragment({\n        owner: this,\n        template: this.template.f\n      }).bind();\n    }\n  };\n\n  Section__proto__.bubble = function bubble () {\n    if (!this.dirty && this.yield) {\n      this.dirty = true;\n      this.containerFragment.bubble();\n    } else { MustacheContainer.prototype.bubble.call(this); }\n  };\n\n  Section__proto__.detach = function detach () {\n    var frag = this.fragment || this.detached;\n    return frag ? frag.detach() : MustacheContainer.prototype.detach.call(this);\n  };\n\n  Section__proto__.findNextNode = function findNextNode () {\n    return (this.containerFragment || this.up).findNextNode(this);\n  };\n\n  Section__proto__.isTruthy = function isTruthy () {\n    if (this.subordinate && this.sibling.isTruthy()) { return true; }\n    var value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();\n    return !!value && (this.templateSectionType === SECTION_IF_WITH || !isEmpty(value));\n  };\n\n  Section__proto__.rebind = function rebind (next, previous, safe) {\n    if (MustacheContainer.prototype.rebind.call(this, next, previous, safe)) {\n      if (this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS) {\n        this.fragment.rebind(next);\n      }\n    }\n  };\n\n  Section__proto__.rebound = function rebound (update) {\n    if (this.model) {\n      if (this.model.rebound) { this.model.rebound(update); }\n      else {\n        MustacheContainer.prototype.unbind.call(this);\n        MustacheContainer.prototype.bind.call(this);\n        if (\n          this.sectionType === SECTION_WITH ||\n          this.sectionType === SECTION_IF_WITH ||\n          this.sectionType === SECTION_EACH\n        ) {\n          if (this.fragment) { this.fragment.rebind(this.model); }\n        }\n\n        if (update) { this.bubble(); }\n      }\n    }\n    if (this.fragment) { this.fragment.rebound(update); }\n  };\n\n  Section__proto__.render = function render (target, occupants) {\n    this.rendered = true;\n    if (this.fragment) { this.fragment.render(target, occupants); }\n  };\n\n  Section__proto__.shuffle = function shuffle (newIndices) {\n    if (this.fragment && this.sectionType === SECTION_EACH) {\n      this.fragment.shuffle(newIndices);\n    }\n  };\n\n  Section__proto__.unbind = function unbind (view) {\n    MustacheContainer.prototype.unbind.call(this, view);\n    if (this.fragment) { this.fragment.unbind(view); }\n  };\n\n  Section__proto__.unrender = function unrender (shouldDestroy) {\n    if (this.rendered && this.fragment) { this.fragment.unrender(shouldDestroy); }\n    this.rendered = false;\n  };\n\n  Section__proto__.update = function update () {\n    var this$1 = this;\n\n    if (!this.dirty) { return; }\n\n    if (this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS) {\n      this.fragment.context = this.model;\n    }\n\n    if (!this.model && this.sectionType !== SECTION_UNLESS && !this.isAlias) { return; }\n\n    this.dirty = false;\n\n    var value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();\n    var siblingFalsey = !this.subordinate || !this.sibling.isTruthy();\n    var lastType = this.sectionType;\n\n    if (this.yield && this.yield !== value) {\n      this.up = this.containerFragment;\n      this.container = null;\n      this.yield = null;\n      if (this.rendered) { this.fragment.unbind().unrender(true); }\n      this.fragment = null;\n    } else if (this.rendered && !this.yield && value instanceof Context) {\n      if (this.rendered && this.fragment) { this.fragment.unbind().unrender(true); }\n      this.fragment = null;\n    }\n\n    // watch for switching section types\n    if (this.sectionType === null || this.templateSectionType === null)\n      { this.sectionType = getType(value, this.template.i); }\n    if (lastType && lastType !== this.sectionType && this.fragment) {\n      if (this.rendered) {\n        this.fragment.unbind().unrender(true);\n      }\n\n      this.fragment = null;\n    }\n\n    var newFragment;\n\n    var fragmentShouldExist =\n      this.sectionType === SECTION_EACH || // each always gets a fragment, which may have no iterations\n      this.sectionType === SECTION_WITH || // with (partial context) always gets a fragment\n      (siblingFalsey &&\n        (this.sectionType === SECTION_UNLESS ? !this.isTruthy() : this.isTruthy())) || // if, unless, and if-with depend on siblings and the condition\n      this.isAlias;\n\n    if (fragmentShouldExist) {\n      if (!this.fragment) { this.fragment = this.detached; }\n\n      if (this.fragment) {\n        // check for detached fragment\n        if (this.detached) {\n          attach(this, this.fragment);\n          this.detached = false;\n          this.rendered = true;\n        }\n\n        if (!this.fragment.bound) { this.fragment.bind(this.model); }\n        this.fragment.update();\n      } else {\n        if (this.sectionType === SECTION_EACH) {\n          newFragment = new RepeatedFragment({\n            owner: this,\n            template: this.template.f,\n            indexRef: this.template.i\n          }).bind(this.model);\n        } else {\n          // only with and if-with provide context - if and unless do not\n          var context =\n            this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS\n              ? this.model\n              : null;\n\n          if (value instanceof Context) {\n            this.yield = value;\n            this.containerFragment = this.up;\n            this.up = value.fragment;\n            this.container = value.ractive;\n            context = undefined;\n          }\n\n          newFragment = new Fragment({\n            owner: this,\n            template: this.template.f\n          }).bind(context);\n        }\n      }\n    } else {\n      if (this.fragment && this.rendered) {\n        if (keep !== true) {\n          this.fragment.unbind().unrender(true);\n        } else {\n          this.unrender(false);\n          this.detached = this.fragment;\n          runloop.promise().then(function () {\n            if (this$1.detached) { this$1.detach(); }\n          });\n        }\n      } else if (this.fragment) {\n        this.fragment.unbind();\n      }\n\n      this.fragment = null;\n    }\n\n    if (newFragment) {\n      if (this.rendered) {\n        attach(this, newFragment);\n      }\n\n      this.fragment = newFragment;\n    }\n\n    if (this.nextSibling) {\n      this.nextSibling.dirty = true;\n      this.nextSibling.update();\n    }\n  };\n\n  return Section;\n}(MustacheContainer));\n\nfunction attach(section, fragment) {\n  var anchor = (section.containerFragment || section.up).findNextNode(section);\n\n  if (anchor) {\n    var docFrag = createDocumentFragment();\n    fragment.render(docFrag);\n\n    anchor.parentNode.insertBefore(docFrag, anchor);\n  } else {\n    fragment.render(section.up.findParentNode());\n  }\n}\n\nvar Select = (function (Element) {\n  function Select(options) {\n    Element.call(this, options);\n    this.options = [];\n  }\n\n  if ( Element ) Select.__proto__ = Element;\n  var Select__proto__ = Select.prototype = Object.create( Element && Element.prototype );\n  Select__proto__.constructor = Select;\n\n  Select__proto__.foundNode = function foundNode (node) {\n    if (this.binding) {\n      var selectedOptions = getSelectedOptions(node);\n\n      if (selectedOptions.length > 0) {\n        this.selectedOptions = selectedOptions;\n      }\n    }\n  };\n\n  Select__proto__.render = function render (target, occupants) {\n    Element.prototype.render.call(this, target, occupants);\n    this.sync();\n\n    var node = this.node;\n\n    var i = node.options.length;\n    while (i--) {\n      node.options[i].defaultSelected = node.options[i].selected;\n    }\n\n    this.rendered = true;\n  };\n\n  Select__proto__.sync = function sync () {\n    var this$1 = this;\n\n    var selectNode = this.node;\n\n    if (!selectNode) { return; }\n\n    var options = toArray(selectNode.options);\n\n    if (this.selectedOptions) {\n      options.forEach(function (o) {\n        if (this$1.selectedOptions.indexOf(o) >= 0) { o.selected = true; }\n        else { o.selected = false; }\n      });\n      this.binding.setFromNode(selectNode);\n      delete this.selectedOptions;\n      return;\n    }\n\n    var selectValue = this.getAttribute('value');\n    var isMultiple = this.getAttribute('multiple');\n    var array = isMultiple && isArray(selectValue);\n\n    // If the <select> has a specified value, that should override\n    // these options\n    if (selectValue !== undefined) {\n      var optionWasSelected;\n\n      options.forEach(function (o) {\n        var optionValue = o._ractive ? o._ractive.value : o.value;\n        var shouldSelect = isMultiple\n          ? array && this$1.valueContains(selectValue, optionValue)\n          : this$1.compare(selectValue, optionValue);\n\n        if (shouldSelect) {\n          optionWasSelected = true;\n        }\n\n        o.selected = shouldSelect;\n      });\n\n      if (!optionWasSelected && !isMultiple) {\n        if (this.binding) {\n          this.binding.forceUpdate();\n        }\n      }\n    } else if (this.binding && this.binding.forceUpdate) {\n      // Otherwise the value should be initialised according to which\n      // <option> element is selected, if twoway binding is in effect\n      this.binding.forceUpdate();\n    }\n  };\n  Select__proto__.valueContains = function valueContains (selectValue, optionValue) {\n    var this$1 = this;\n\n    var i = selectValue.length;\n    while (i--) {\n      if (this$1.compare(optionValue, selectValue[i])) { return true; }\n    }\n  };\n  Select__proto__.compare = function compare (optionValue, selectValue) {\n    var comparator = this.getAttribute('value-comparator');\n    if (comparator) {\n      if (isFunction(comparator)) {\n        return comparator(selectValue, optionValue);\n      }\n      if (selectValue && optionValue) {\n        return selectValue[comparator] == optionValue[comparator];\n      }\n    }\n    return selectValue == optionValue;\n  };\n  Select__proto__.update = function update () {\n    var dirty = this.dirty;\n    Element.prototype.update.call(this);\n    if (dirty) {\n      this.sync();\n    }\n  };\n\n  return Select;\n}(Element));\n\nvar Textarea = (function (Input) {\n  function Textarea(options) {\n    var template = options.template;\n\n    options.deferContent = true;\n\n    Input.call(this, options);\n\n    // check for single interpolator binding\n    if (!this.attributeByName.value) {\n      if (template.f && isBindable({ template: template })) {\n        (this.attributes || (this.attributes = [])).push(\n          createItem({\n            owner: this,\n            template: { t: ATTRIBUTE, f: template.f, n: 'value' },\n            up: this.up\n          })\n        );\n      } else {\n        this.fragment = new Fragment({\n          owner: this,\n          cssIds: null,\n          template: template.f\n        });\n      }\n    }\n  }\n\n  if ( Input ) Textarea.__proto__ = Input;\n  var Textarea__proto__ = Textarea.prototype = Object.create( Input && Input.prototype );\n  Textarea__proto__.constructor = Textarea;\n\n  Textarea__proto__.bubble = function bubble () {\n    var this$1 = this;\n\n    if (!this.dirty) {\n      this.dirty = true;\n\n      if (this.rendered && !this.binding && this.fragment) {\n        runloop.scheduleTask(function () {\n          this$1.dirty = false;\n          this$1.node.value = this$1.fragment.toString();\n        });\n      }\n\n      this.up.bubble(); // default behaviour\n    }\n  };\n\n  return Textarea;\n}(Input));\n\nvar Text = (function (Item) {\n  function Text(options) {\n    Item.call(this, options);\n    this.type = TEXT;\n  }\n\n  if ( Item ) Text.__proto__ = Item;\n  var Text__proto__ = Text.prototype = Object.create( Item && Item.prototype );\n  Text__proto__.constructor = Text;\n\n  Text__proto__.detach = function detach () {\n    return detachNode(this.node);\n  };\n\n  Text__proto__.firstNode = function firstNode () {\n    return this.node;\n  };\n\n  Text__proto__.render = function render (target, occupants) {\n    if (inAttributes()) { return; }\n    this.rendered = true;\n\n    progressiveText(this, target, occupants, this.template);\n  };\n\n  Text__proto__.toString = function toString (escape) {\n    return escape ? escapeHtml(this.template) : this.template;\n  };\n\n  Text__proto__.unrender = function unrender (shouldDestroy) {\n    if (this.rendered && shouldDestroy) { this.detach(); }\n    this.rendered = false;\n  };\n\n  Text__proto__.valueOf = function valueOf () {\n    return this.template;\n  };\n\n  return Text;\n}(Item));\n\nvar proto$7 = Text.prototype;\nproto$7.bind = proto$7.unbind = proto$7.update = noop;\n\nvar visible;\nvar hidden = 'hidden';\n\nif (doc) {\n  var prefix$2;\n\n  /* istanbul ignore next */\n  if (hidden in doc) {\n    prefix$2 = '';\n  } else {\n    var i$1 = vendors.length;\n    while (i$1--) {\n      var vendor = vendors[i$1];\n      hidden = vendor + 'Hidden';\n\n      if (hidden in doc) {\n        prefix$2 = vendor;\n        break;\n      }\n    }\n  }\n\n  /* istanbul ignore else */\n  if (prefix$2 !== undefined) {\n    doc.addEventListener(prefix$2 + 'visibilitychange', onChange);\n    onChange();\n  } else {\n    // gah, we're in an old browser\n    if ('onfocusout' in doc) {\n      doc.addEventListener('focusout', onHide);\n      doc.addEventListener('focusin', onShow);\n    } else {\n      win.addEventListener('pagehide', onHide);\n      win.addEventListener('blur', onHide);\n\n      win.addEventListener('pageshow', onShow);\n      win.addEventListener('focus', onShow);\n    }\n\n    visible = true; // until proven otherwise. Not ideal but hey\n  }\n}\n\nfunction onChange() {\n  visible = !doc[hidden];\n}\n\n/* istanbul ignore next */\nfunction onHide() {\n  visible = false;\n}\n\n/* istanbul ignore next */\nfunction onShow() {\n  visible = true;\n}\n\nvar prefix;\n\n/* istanbul ignore next */\nif (!isClient) {\n  prefix = null;\n} else {\n  var prefixCache = {};\n  var testStyle = createElement('div').style;\n\n  // technically this also normalizes on hyphenated styles as well\n  prefix = function(prop) {\n    if (!prefixCache[prop]) {\n      var name = hyphenateCamel(prop);\n\n      if (testStyle[prop] !== undefined) {\n        prefixCache[prop] = name;\n      } else {\n        /* istanbul ignore next */\n        // test vendors...\n        var i = vendors.length;\n        while (i--) {\n          var vendor = \"-\" + (vendors[i]) + \"-\" + name;\n          if (testStyle[vendor] !== undefined) {\n            prefixCache[prop] = vendor;\n            break;\n          }\n        }\n      }\n    }\n\n    return prefixCache[prop];\n  };\n}\n\nvar prefix$1 = prefix;\n\nvar vendorPattern = new RegExp('^(?:' + vendors.join('|') + ')([A-Z])');\n\nfunction hyphenate(str) {\n  /* istanbul ignore next */\n  if (!str) { return ''; } // edge case\n\n  /* istanbul ignore next */\n  if (vendorPattern.test(str)) { str = '-' + str; }\n\n  return str.replace(/[A-Z]/g, function (match) { return '-' + match.toLowerCase(); });\n}\n\nvar createTransitions;\n\nif (!isClient) {\n  createTransitions = null;\n} else {\n  var testStyle$1 = createElement('div').style;\n  var linear$1 = function (x) { return x; };\n\n  var canUseCssTransitions = {};\n  var cannotUseCssTransitions = {};\n\n  // determine some facts about our environment\n  var TRANSITION$1;\n  var TRANSITIONEND;\n  var CSS_TRANSITIONS_ENABLED;\n  var TRANSITION_DURATION;\n  var TRANSITION_PROPERTY;\n  var TRANSITION_TIMING_FUNCTION;\n\n  if (testStyle$1.transition !== undefined) {\n    TRANSITION$1 = 'transition';\n    TRANSITIONEND = 'transitionend';\n    CSS_TRANSITIONS_ENABLED = true;\n  } else if (testStyle$1.webkitTransition !== undefined) {\n    TRANSITION$1 = 'webkitTransition';\n    TRANSITIONEND = 'webkitTransitionEnd';\n    CSS_TRANSITIONS_ENABLED = true;\n  } else {\n    CSS_TRANSITIONS_ENABLED = false;\n  }\n\n  if (TRANSITION$1) {\n    TRANSITION_DURATION = TRANSITION$1 + 'Duration';\n    TRANSITION_PROPERTY = TRANSITION$1 + 'Property';\n    TRANSITION_TIMING_FUNCTION = TRANSITION$1 + 'TimingFunction';\n  }\n\n  createTransitions = function(t, to, options, changedProperties, resolve) {\n    // Wait a beat (otherwise the target styles will be applied immediately)\n    // TODO use a fastdom-style mechanism?\n    setTimeout(function () {\n      var jsTransitionsComplete;\n      var cssTransitionsComplete;\n      var cssTimeout; // eslint-disable-line prefer-const\n\n      function transitionDone() {\n        clearTimeout(cssTimeout);\n      }\n\n      function checkComplete() {\n        if (jsTransitionsComplete && cssTransitionsComplete) {\n          t.unregisterCompleteHandler(transitionDone);\n          // will changes to events and fire have an unexpected consequence here?\n          t.ractive.fire(t.name + ':end', t.node, t.isIntro);\n          resolve();\n        }\n      }\n\n      // this is used to keep track of which elements can use CSS to animate\n      // which properties\n      var hashPrefix = (t.node.namespaceURI || '') + t.node.tagName;\n\n      // need to reset transition properties\n      var style = t.node.style;\n      var previous = {\n        property: style[TRANSITION_PROPERTY],\n        timing: style[TRANSITION_TIMING_FUNCTION],\n        duration: style[TRANSITION_DURATION]\n      };\n\n      function transitionEndHandler(event) {\n        if (event.target !== t.node) { return; }\n        var index = changedProperties.indexOf(event.propertyName);\n\n        if (index !== -1) {\n          changedProperties.splice(index, 1);\n        }\n\n        if (changedProperties.length) {\n          // still transitioning...\n          return;\n        }\n\n        clearTimeout(cssTimeout);\n        cssTransitionsDone();\n      }\n\n      function cssTransitionsDone() {\n        style[TRANSITION_PROPERTY] = previous.property;\n        style[TRANSITION_TIMING_FUNCTION] = previous.duration;\n        style[TRANSITION_DURATION] = previous.timing;\n\n        t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n        cssTransitionsComplete = true;\n        checkComplete();\n      }\n\n      t.node.addEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n      // safety net in case transitionend never fires\n      cssTimeout = setTimeout(function () {\n        changedProperties = [];\n        cssTransitionsDone();\n      }, options.duration + (options.delay || 0) + 50);\n      t.registerCompleteHandler(transitionDone);\n\n      style[TRANSITION_PROPERTY] = changedProperties.join(',');\n      var easingName = hyphenate(options.easing || 'linear');\n      style[TRANSITION_TIMING_FUNCTION] = easingName;\n      var cssTiming = style[TRANSITION_TIMING_FUNCTION] === easingName;\n      style[TRANSITION_DURATION] = options.duration / 1000 + 's';\n\n      setTimeout(function () {\n        var i = changedProperties.length;\n        var hash;\n        var originalValue = null;\n        var index;\n        var propertiesToTransitionInJs = [];\n        var prop;\n        var suffix;\n        var interpolator;\n\n        while (i--) {\n          prop = changedProperties[i];\n          hash = hashPrefix + prop;\n\n          if (cssTiming && CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[hash]) {\n            var initial = style[prop];\n            style[prop] = to[prop];\n\n            // If we're not sure if CSS transitions are supported for\n            // this tag/property combo, find out now\n            if (!(hash in canUseCssTransitions)) {\n              originalValue = t.getStyle(prop);\n\n              // if this property is transitionable in this browser,\n              // the current style will be different from the target style\n              canUseCssTransitions[hash] = t.getStyle(prop) != to[prop];\n              cannotUseCssTransitions[hash] = !canUseCssTransitions[hash];\n\n              // Reset, if we're going to use timers after all\n              if (cannotUseCssTransitions[hash]) {\n                style[prop] = initial;\n              }\n            }\n          }\n\n          if (!cssTiming || !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[hash]) {\n            // we need to fall back to timer-based stuff\n            if (originalValue === null) { originalValue = t.getStyle(prop); }\n\n            // need to remove this from changedProperties, otherwise transitionEndHandler\n            // will get confused\n            index = changedProperties.indexOf(prop);\n            if (index === -1) {\n              warnIfDebug(\n                'Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!',\n                { node: t.node }\n              );\n            } else {\n              changedProperties.splice(index, 1);\n            }\n\n            // TODO Determine whether this property is animatable at all\n\n            suffix = /[^\\d]*$/.exec(originalValue)[0];\n            interpolator = interpolate(parseFloat(originalValue), parseFloat(to[prop]));\n\n            // ...then kick off a timer-based transition\n            if (interpolator) {\n              propertiesToTransitionInJs.push({\n                name: prop,\n                interpolator: interpolator,\n                suffix: suffix\n              });\n            } else {\n              style[prop] = to[prop];\n            }\n\n            originalValue = null;\n          }\n        }\n\n        // javascript transitions\n        if (propertiesToTransitionInJs.length) {\n          var easing;\n\n          if (isString(options.easing)) {\n            easing = t.ractive.easing[options.easing];\n\n            if (!easing) {\n              warnOnceIfDebug(missingPlugin(options.easing, 'easing'));\n              easing = linear$1;\n            }\n          } else if (isFunction(options.easing)) {\n            easing = options.easing;\n          } else {\n            easing = linear$1;\n          }\n\n          new Ticker({\n            duration: options.duration,\n            easing: easing,\n            step: function step(pos) {\n              var i = propertiesToTransitionInJs.length;\n              while (i--) {\n                var prop = propertiesToTransitionInJs[i];\n                style[prop.name] = prop.interpolator(pos) + prop.suffix;\n              }\n            },\n            complete: function complete() {\n              jsTransitionsComplete = true;\n              checkComplete();\n            }\n          });\n        } else {\n          jsTransitionsComplete = true;\n        }\n\n        if (changedProperties.length) {\n          style[TRANSITION_PROPERTY] = changedProperties.join(',');\n        } else {\n          style[TRANSITION_PROPERTY] = 'none';\n\n          // We need to cancel the transitionEndHandler, and deal with\n          // the fact that it will never fire\n          t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n          cssTransitionsComplete = true;\n          checkComplete();\n        }\n      }, 0);\n    }, options.delay || 0);\n  };\n}\n\nvar createTransitions$1 = createTransitions;\n\nvar getComputedStyle = win && win.getComputedStyle;\nvar resolved = Promise.resolve();\n\nvar names = {\n  t0: 'intro-outro',\n  t1: 'intro',\n  t2: 'outro'\n};\n\nvar Transition = function Transition(options) {\n  this.owner = options.owner || options.up.owner || findElement(options.up);\n  this.element = this.owner.attributeByName ? this.owner : findElement(options.up);\n  this.ractive = this.owner.ractive;\n  this.template = options.template;\n  this.up = options.up;\n  this.options = options;\n  this.onComplete = [];\n};\nvar Transition__proto__ = Transition.prototype;\n\nTransition__proto__.animateStyle = function animateStyle (style, value, options) {\n    var this$1 = this;\n\n  if (arguments.length === 4) {\n    throw new Error(\n      't.animateStyle() returns a promise - use .then() instead of passing a callback'\n    );\n  }\n\n  // Special case - page isn't visible. Don't animate anything, because\n  // that way you'll never get CSS transitionend events\n  if (!visible) {\n    this.setStyle(style, value);\n    return resolved;\n  }\n\n  var to;\n\n  if (isString(style)) {\n    to = {};\n    to[style] = value;\n  } else {\n    to = style;\n\n    // shuffle arguments\n    options = value;\n  }\n\n  return new Promise(function (fulfil) {\n    // Edge case - if duration is zero, set style synchronously and complete\n    if (!options.duration) {\n      this$1.setStyle(to);\n      fulfil();\n      return;\n    }\n\n    // Get a list of the properties we're animating\n    var propertyNames = keys(to);\n    var changedProperties = [];\n\n    // Store the current styles\n    var computedStyle = getComputedStyle(this$1.node);\n\n    var i = propertyNames.length;\n    while (i--) {\n      var prop = propertyNames[i];\n      var name = prefix$1(prop);\n\n      var current = computedStyle[prefix$1(prop)];\n\n      // record the starting points\n      var init = this$1.node.style[name];\n      if (!(name in this$1.originals)) { this$1.originals[name] = this$1.node.style[name]; }\n      this$1.node.style[name] = to[prop];\n      this$1.targets[name] = this$1.node.style[name];\n      this$1.node.style[name] = init;\n\n      // we need to know if we're actually changing anything\n      if (current != to[prop]) {\n        // use != instead of !==, so we can compare strings with numbers\n        changedProperties.push(name);\n\n        // if we happened to prefix, make sure there is a properly prefixed value\n        to[name] = to[prop];\n\n        // make the computed style explicit, so we can animate where\n        // e.g. height='auto'\n        this$1.node.style[name] = current;\n      }\n    }\n\n    // If we're not actually changing anything, the transitionend event\n    // will never fire! So we complete early\n    if (!changedProperties.length) {\n      fulfil();\n      return;\n    }\n\n    createTransitions$1(this$1, to, options, changedProperties, fulfil);\n  });\n};\n\nTransition__proto__.bind = function bind () {\n  var options = this.options;\n  var type = options.template && options.template.v;\n  if (type) {\n    if (type === 't0' || type === 't1') { this.element.intro = this; }\n    if (type === 't0' || type === 't2') { this.element.outro = this; }\n    this.eventName = names[type];\n  }\n\n  var ractive = this.owner.ractive;\n\n  this.name = options.name || options.template.n;\n\n  if (options.params) {\n    this.params = options.params;\n  }\n\n  if (isFunction(this.name)) {\n    this._fn = this.name;\n    this.name = this._fn.name;\n  } else {\n    this._fn = findInViewHierarchy('transitions', ractive, this.name);\n  }\n\n  if (!this._fn) {\n    warnOnceIfDebug(missingPlugin(this.name, 'transition'), { ractive: ractive });\n  }\n\n  setupArgsFn(this, options.template);\n};\n\nTransition__proto__.getParams = function getParams () {\n  if (this.params) { return this.params; }\n\n  // get expression args if supplied\n  if (this.fn) {\n    var values = resolveArgs(this, this.template, this.up).map(function (model) {\n      if (!model) { return undefined; }\n\n      return model.get();\n    });\n    return this.fn.apply(this.ractive, values);\n  }\n};\n\nTransition__proto__.getStyle = function getStyle (props) {\n  var computedStyle = getComputedStyle(this.node);\n\n  if (isString(props)) {\n    return computedStyle[prefix$1(props)];\n  }\n\n  if (!isArray(props)) {\n    throw new Error(\n      'Transition$getStyle must be passed a string, or an array of strings representing CSS properties'\n    );\n  }\n\n  var styles = {};\n\n  var i = props.length;\n  while (i--) {\n    var prop = props[i];\n    var value = computedStyle[prefix$1(prop)];\n\n    if (value === '0px') { value = 0; }\n    styles[prop] = value;\n  }\n\n  return styles;\n};\n\nTransition__proto__.processParams = function processParams (params, defaults) {\n  if (isNumber(params)) {\n    params = { duration: params };\n  } else if (isString(params)) {\n    if (params === 'slow') {\n      params = { duration: 600 };\n    } else if (params === 'fast') {\n      params = { duration: 200 };\n    } else {\n      params = { duration: 400 };\n    }\n  } else if (!params) {\n    params = {};\n  }\n\n  return assign({}, defaults, params);\n};\n\nTransition__proto__.registerCompleteHandler = function registerCompleteHandler (fn) {\n  addToArray(this.onComplete, fn);\n};\n\nTransition__proto__.setStyle = function setStyle (style, value) {\n    var this$1 = this;\n\n  if (isString(style)) {\n    var name = prefix$1(style);\n    if (!hasOwn(this.originals, name)) { this.originals[name] = this.node.style[name]; }\n    this.node.style[name] = value;\n    this.targets[name] = this.node.style[name];\n  } else {\n    var prop;\n    for (prop in style) {\n      if (hasOwn(style, prop)) {\n        this$1.setStyle(prop, style[prop]);\n      }\n    }\n  }\n\n  return this;\n};\n\nTransition__proto__.shouldFire = function shouldFire (type) {\n  if (!this.ractive.transitionsEnabled) { return false; }\n\n  // check for noIntro and noOutro cases, which only apply when the owner ractive is rendering and unrendering, respectively\n  if (type === 'intro' && this.ractive.rendering && nearestProp('noIntro', this.ractive, true))\n    { return false; }\n  if (type === 'outro' && this.ractive.unrendering && nearestProp('noOutro', this.ractive, false))\n    { return false; }\n\n  var params = this.getParams(); // this is an array, the params object should be the first member\n  // if there's not a parent element, this can't be nested, so roll on\n  if (!this.element.parent) { return true; }\n\n  // if there is a local param, it takes precedent\n  if (params && params[0] && isObject(params[0]) && 'nested' in params[0]) {\n    if (params[0].nested !== false) { return true; }\n  } else {\n    // use the nearest instance setting\n    // find the nearest instance that actually has a nested setting\n    if (nearestProp('nestedTransitions', this.ractive) !== false) { return true; }\n  }\n\n  // check to see if this is actually a nested transition\n  var el = this.element.parent;\n  while (el) {\n    if (el[type] && el[type].starting) { return false; }\n    el = el.parent;\n  }\n\n  return true;\n};\n\nTransition__proto__.start = function start () {\n    var this$1 = this;\n\n  var node = (this.node = this.element.node);\n  var originals = (this.originals = {}); //= node.getAttribute( 'style' );\n  var targets = (this.targets = {});\n\n  var completed;\n  var args = this.getParams();\n\n  // create t.complete() - we don't want this on the prototype,\n  // because we don't want `this` silliness when passing it as\n  // an argument\n  this.complete = function (noReset) {\n    this$1.starting = false;\n    if (completed) {\n      return;\n    }\n\n    this$1.onComplete.forEach(function (fn) { return fn(); });\n    if (!noReset && this$1.isIntro) {\n      for (var k in targets) {\n        if (node.style[k] === targets[k]) { node.style[k] = originals[k]; }\n      }\n    }\n\n    this$1._manager.remove(this$1);\n\n    completed = true;\n  };\n\n  // If the transition function doesn't exist, abort\n  if (!this._fn) {\n    this.complete();\n    return;\n  }\n\n  var promise = this._fn.apply(this.ractive, [this].concat(args));\n  if (promise) { promise.then(this.complete); }\n};\n\nTransition__proto__.toString = function toString () {\n  return '';\n};\n\nTransition__proto__.unbind = function unbind () {\n  if (!this.element.attributes || !this.element.attributes.unbinding) {\n    var type = this.options && this.options.template && this.options.template.v;\n    if (type === 't0' || type === 't1') { this.element.intro = null; }\n    if (type === 't0' || type === 't2') { this.element.outro = null; }\n  }\n};\n\nTransition__proto__.unregisterCompleteHandler = function unregisterCompleteHandler (fn) {\n  removeFromArray(this.onComplete, fn);\n};\n\nvar proto$8 = Transition.prototype;\nproto$8.destroyed = proto$8.firstNode = proto$8.rebound = proto$8.render = proto$8.unrender = proto$8.update = noop;\n\nfunction nearestProp(prop, ractive, rendering) {\n  var instance = ractive;\n  while (instance) {\n    if (\n      hasOwn(instance, prop) &&\n      (isUndefined(rendering) || rendering ? instance.rendering : instance.unrendering)\n    )\n      { return instance[prop]; }\n    instance = instance.component && instance.component.ractive;\n  }\n\n  return ractive[prop];\n}\n\nvar elementCache = {};\n\nvar ieBug;\nvar ieBlacklist;\n\ntry {\n  createElement('table').innerHTML = 'foo';\n} catch (/* istanbul ignore next */ err) {\n  ieBug = true;\n\n  ieBlacklist = {\n    TABLE: ['<table class=\"x\">', '</table>'],\n    THEAD: ['<table><thead class=\"x\">', '</thead></table>'],\n    TBODY: ['<table><tbody class=\"x\">', '</tbody></table>'],\n    TR: ['<table><tr class=\"x\">', '</tr></table>'],\n    SELECT: ['<select class=\"x\">', '</select>']\n  };\n}\n\nfunction insertHtml(html$$1, node) {\n  var nodes = [];\n\n  // render 0 and false\n  if (html$$1 == null || html$$1 === '') { return nodes; }\n\n  var container;\n  var wrapper;\n  var selectedOption;\n\n  /* istanbul ignore if */\n  if (ieBug && (wrapper = ieBlacklist[node.tagName])) {\n    container = element('DIV');\n    container.innerHTML = wrapper[0] + html$$1 + wrapper[1];\n    container = container.querySelector('.x');\n\n    if (container.tagName === 'SELECT') {\n      selectedOption = container.options[container.selectedIndex];\n    }\n  } else if (node.namespaceURI === svg$1) {\n    container = element('DIV');\n    container.innerHTML = '<svg class=\"x\">' + html$$1 + '</svg>';\n    container = container.querySelector('.x');\n  } else if (node.tagName === 'TEXTAREA') {\n    container = createElement('div');\n\n    if (typeof container.textContent !== 'undefined') {\n      container.textContent = html$$1;\n    } else {\n      container.innerHTML = html$$1;\n    }\n  } else {\n    container = element(node.tagName);\n    container.innerHTML = html$$1;\n\n    if (container.tagName === 'SELECT') {\n      selectedOption = container.options[container.selectedIndex];\n    }\n  }\n\n  var child;\n  while ((child = container.firstChild)) {\n    nodes.push(child);\n    container.removeChild(child);\n  }\n\n  // This is really annoying. Extracting <option> nodes from the\n  // temporary container <select> causes the remaining ones to\n  // become selected. So now we have to deselect them. IE8, you\n  // amaze me. You really do\n  // ...and now Chrome too\n  var i;\n  if (node.tagName === 'SELECT') {\n    i = nodes.length;\n    while (i--) {\n      if (nodes[i] !== selectedOption) {\n        nodes[i].selected = false;\n      }\n    }\n  }\n\n  return nodes;\n}\n\nfunction element(tagName) {\n  return elementCache[tagName] || (elementCache[tagName] = createElement(tagName));\n}\n\nvar Triple = (function (Mustache) {\n  function Triple(options) {\n    Mustache.call(this, options);\n  }\n\n  if ( Mustache ) Triple.__proto__ = Mustache;\n  var Triple__proto__ = Triple.prototype = Object.create( Mustache && Mustache.prototype );\n  Triple__proto__.constructor = Triple;\n\n  Triple__proto__.detach = function detach () {\n    var docFrag = createDocumentFragment();\n    if (this.nodes) { this.nodes.forEach(function (node) { return docFrag.appendChild(node); }); }\n    return docFrag;\n  };\n\n  Triple__proto__.find = function find (selector) {\n    var this$1 = this;\n\n    var len = this.nodes.length;\n    var i;\n\n    for (i = 0; i < len; i += 1) {\n      var node = this$1.nodes[i];\n\n      if (node.nodeType !== 1) { continue; }\n\n      if (matches(node, selector)) { return node; }\n\n      var queryResult = node.querySelector(selector);\n      if (queryResult) { return queryResult; }\n    }\n\n    return null;\n  };\n\n  Triple__proto__.findAll = function findAll (selector, options) {\n    var this$1 = this;\n\n    var result = options.result;\n    var len = this.nodes.length;\n    var i;\n\n    for (i = 0; i < len; i += 1) {\n      var node = this$1.nodes[i];\n\n      if (node.nodeType !== 1) { continue; }\n\n      if (matches(node, selector)) { result.push(node); }\n\n      var queryAllResult = node.querySelectorAll(selector);\n      if (queryAllResult) {\n        result.push.apply(result, queryAllResult);\n      }\n    }\n  };\n\n  Triple__proto__.findComponent = function findComponent () {\n    return null;\n  };\n\n  Triple__proto__.firstNode = function firstNode () {\n    return this.rendered && this.nodes[0];\n  };\n\n  Triple__proto__.render = function render (target, occupants, anchor) {\n    var this$1 = this;\n\n    if (!this.nodes) {\n      var html = this.model ? this.model.get() : '';\n      this.nodes = insertHtml(html, target);\n    }\n\n    var nodes = this.nodes;\n\n    // progressive enhancement\n    if (occupants) {\n      var i = -1;\n      var next;\n\n      // start with the first node that should be rendered\n      while (occupants.length && (next = this.nodes[i + 1])) {\n        var n = (void 0);\n        // look through the occupants until a matching node is found\n        while ((n = occupants.shift())) {\n          var t = n.nodeType;\n\n          if (\n            t === next.nodeType &&\n            ((t === 1 && n.outerHTML === next.outerHTML) ||\n              ((t === 3 || t === 8) && n.nodeValue === next.nodeValue))\n          ) {\n            this$1.nodes.splice(++i, 1, n); // replace the generated node with the existing one\n            break;\n          } else {\n            target.removeChild(n); // remove the non-matching existing node\n          }\n        }\n      }\n\n      if (i >= 0) {\n        // update the list of remaining nodes to attach, excluding any that were replaced by existing nodes\n        nodes = this.nodes.slice(i);\n      }\n\n      // update the anchor to be the next occupant\n      if (occupants.length) { anchor = occupants[0]; }\n    }\n\n    // attach any remainging nodes to the parent\n    if (nodes.length) {\n      var frag = createDocumentFragment();\n      nodes.forEach(function (n) { return frag.appendChild(n); });\n\n      if (anchor) {\n        target.insertBefore(frag, anchor);\n      } else {\n        target.appendChild(frag);\n      }\n    }\n\n    this.rendered = true;\n  };\n\n  Triple__proto__.toString = function toString () {\n    var value = this.model && this.model.get();\n    value = value != null ? '' + value : '';\n\n    return inAttribute() ? decodeCharacterReferences(value) : value;\n  };\n\n  Triple__proto__.unrender = function unrender () {\n    if (this.nodes)\n      { this.nodes.forEach(function (node) {\n        // defer detachment until all relevant outros are done\n        runloop.detachWhenReady({\n          node: node,\n          detach: function detach() {\n            detachNode(node);\n          }\n        });\n      }); }\n    this.rendered = false;\n    this.nodes = null;\n  };\n\n  Triple__proto__.update = function update () {\n    if (this.rendered && this.dirty) {\n      this.dirty = false;\n\n      this.unrender();\n      this.render(this.up.findParentNode(), null, this.up.findNextNode(this));\n    } else {\n      // make sure to reset the dirty flag even if not rendered\n      this.dirty = false;\n    }\n  };\n\n  return Triple;\n}(Mustache));\n\n// finds the component constructor in the registry or view hierarchy registries\nfunction getComponentConstructor(ractive, name) {\n  var instance = findInstance('components', ractive, name);\n  var Component;\n\n  if (instance) {\n    Component = instance.components[name];\n\n    if (Component && !Component.isInstance) {\n      if (Component.default && Component.default.isInstance) { Component = Component.default; }\n      else if (!Component.then && isFunction(Component)) {\n        // function option, execute and store for reset\n        var fn = Component.bind(instance);\n        fn.isOwner = hasOwn(instance.components, name);\n        Component = fn();\n\n        if (!Component) {\n          warnIfDebug(noRegistryFunctionReturn, name, 'component', 'component', {\n            ractive: ractive\n          });\n          return;\n        }\n\n        if (isString(Component)) {\n          // allow string lookup\n          Component = getComponentConstructor(ractive, Component);\n        }\n\n        Component._fn = fn;\n        instance.components[name] = Component;\n      }\n    }\n  }\n\n  return Component;\n}\n\nfunction asyncProxy(promise, options) {\n  var partials = options.template.p || {};\n  var name = options.template.e;\n\n  var opts = assign({}, options, {\n    template: { t: ELEMENT, e: name },\n    macro: function macro(handle) {\n      handle.setTemplate(partials['async-loading'] || []);\n      promise.then(\n        function (cmp) {\n          options.up.ractive.components[name] = cmp;\n          if (partials['async-loaded']) {\n            handle.partials.component = [options.template];\n            handle.setTemplate(partials['async-loaded']);\n          } else {\n            handle.setTemplate([options.template]);\n          }\n        },\n        function (err) {\n          if (partials['async-failed']) {\n            handle.aliasLocal('error', 'error');\n            handle.set('@local.error', err);\n            handle.setTemplate(partials['async-failed']);\n          } else {\n            handle.setTemplate([]);\n          }\n        }\n      );\n    }\n  });\n  return new Partial(opts);\n}\n\nfunction extract(tpl, type, name) {\n  var p = tpl.f.find(function (s) { return s.t === type; });\n  if (p) {\n    if (p.n)\n      { return [\n        {\n          t: 19,\n          n: 54,\n          f: p.f || [],\n          z: [{ n: p.n, x: { r: (\"__await.\" + name) } }]\n        }\n      ]; }\n    else { return p.f || []; }\n  } else { return []; }\n}\n\nfunction Await(options) {\n  var tpl = options.template;\n\n  var success = extract(tpl, THEN, 'value');\n  var error = extract(tpl, CATCH, 'error');\n  var pending = extract(tpl, SECTION);\n  var undef = extract(tpl, ELSE);\n\n  var opts = assign({}, options, {\n    template: {\n      t: ELEMENT,\n      m: [\n        {\n          t: ATTRIBUTE,\n          n: 'for',\n          f: [{ t: INTERPOLATOR, r: tpl.r, rx: tpl.rx, x: tpl.x }]\n        }\n      ]\n    },\n    macro: function macro(handle, attrs) {\n      handle.aliasLocal('__await');\n\n      function update(attrs) {\n        if (attrs.for && isFunction(attrs.for.then)) {\n          handle.setTemplate(pending);\n\n          attrs.for.then(\n            function (v) {\n              handle.set('@local.value', v);\n              handle.setTemplate(success);\n            },\n            function (e) {\n              handle.set('@local.error', e);\n              handle.setTemplate(error);\n            }\n          );\n        } else if (isUndefined(attrs.for)) {\n          handle.setTemplate(undef);\n        } else {\n          handle.set('@local.value', attrs.for);\n          handle.setTemplate(success);\n        }\n      }\n\n      update(attrs);\n\n      return {\n        update: update\n      };\n    }\n  });\n\n  opts.macro.attributes = ['for'];\n\n  return new Partial(opts);\n}\n\nvar constructors = {};\nconstructors[ALIAS] = Section;\nconstructors[ANCHOR] = Component;\nconstructors[AWAIT] = Await;\nconstructors[DOCTYPE] = Doctype;\nconstructors[INTERPOLATOR] = Interpolator;\nconstructors[PARTIAL] = Partial;\nconstructors[SECTION] = Section;\nconstructors[TRIPLE] = Triple;\nconstructors[YIELDER] = Partial;\n\nconstructors[ATTRIBUTE] = Attribute;\nconstructors[BINDING_FLAG] = BindingFlag;\nconstructors[DECORATOR] = Decorator;\nconstructors[EVENT] = EventDirective;\nconstructors[TRANSITION] = Transition;\nconstructors[COMMENT] = Comment;\n\nvar specialElements = {\n  doctype: Doctype,\n  form: Form,\n  input: Input,\n  option: Option,\n  select: Select,\n  textarea: Textarea\n};\n\nfunction createItem(options) {\n  if (isString(options.template)) {\n    return new Text(options);\n  }\n\n  var ctor;\n  var name;\n  var type = options.template.t;\n\n  if (type === ELEMENT) {\n    name = options.template.e;\n\n    // could be a macro partial\n    ctor = findInstance('partials', options.up.ractive, name);\n    if (ctor) {\n      ctor = ctor.partials[name];\n      if (ctor.styleSet) {\n        options.macro = ctor;\n        return new Partial(options);\n      }\n    }\n\n    // could be component or element\n    ctor = getComponentConstructor(options.up.ractive, name);\n    if (ctor) {\n      if (isFunction(ctor.then)) {\n        return asyncProxy(ctor, options);\n      } else if (isFunction(ctor)) {\n        return new Component(options, ctor);\n      }\n    }\n\n    ctor = specialElements[name.toLowerCase()] || Element;\n    return new ctor(options);\n  }\n\n  var Item;\n\n  // component mappings are a special case of attribute\n  if (type === ATTRIBUTE) {\n    var el = options.owner;\n    if (!el || (el.type !== ANCHOR && el.type !== COMPONENT && el.type !== ELEMENT)) {\n      el = findElement(options.up);\n    }\n    options.element = el;\n\n    Item = el.type === COMPONENT || el.type === ANCHOR ? Mapping : Attribute;\n  } else {\n    Item = constructors[type];\n  }\n\n  if (!Item) { throw new Error((\"Unrecognised item type \" + type)); }\n\n  return new Item(options);\n}\n\n// TODO all this code needs to die\nfunction processItems(items, values, guid, counter) {\n  if ( counter === void 0 ) counter = 0;\n\n  return items\n    .map(function (item) {\n      if (item.type === TEXT) {\n        return item.template;\n      }\n\n      if (item.fragment) {\n        if (item.fragment.iterations) {\n          return item.fragment.iterations\n            .map(function (fragment) {\n              return processItems(fragment.items, values, guid, counter);\n            })\n            .join('');\n        } else {\n          return processItems(item.fragment.items, values, guid, counter);\n        }\n      }\n\n      var placeholderId = guid + \"-\" + (counter++);\n      var model = item.model || item.newModel;\n\n      values[placeholderId] = model\n        ? model.wrapper\n          ? model.wrapperValue\n          : model.get()\n        : undefined;\n\n      return '${' + placeholderId + '}';\n    })\n    .join('');\n}\n\nfunction resolveAliases(aliases, fragment, dest) {\n  if ( dest === void 0 ) dest = {};\n\n  for (var i = 0; i < aliases.length; i++) {\n    if (!dest[aliases[i].n]) {\n      var m = resolve(fragment, aliases[i].x);\n      dest[aliases[i].n] = m;\n      m.reference();\n    }\n  }\n\n  return dest;\n}\n\nvar Fragment = function Fragment(options) {\n  this.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute\n\n  this.isRoot = !options.owner.up;\n  this.parent = this.isRoot ? null : this.owner.up;\n  this.ractive = options.ractive || (this.isRoot ? options.owner : this.parent.ractive);\n\n  this.componentParent =\n    this.isRoot && this.ractive.component\n      ? this.ractive.component.up\n      : this.owner.containerFragment || null;\n  if (!this.isRoot || this.ractive.delegate) {\n    this.delegate = this.owner.containerFragment\n      ? this.owner.containerFragment && this.owner.containerFragment.delegate\n      : (this.componentParent && this.componentParent.delegate) ||\n        (this.parent && this.parent.delegate);\n  } else {\n    this.delegate = false;\n  }\n\n  this.context = null;\n  this.rendered = false;\n\n  // encapsulated styles should be inherited until they get applied by an element\n  if ('cssIds' in options) {\n    this.cssIds = options.cssIds && options.cssIds.length && options.cssIds;\n  } else {\n    this.cssIds = this.parent ? this.parent.cssIds : null;\n  }\n\n  this.dirty = false;\n  this.dirtyValue = true; // used for attribute values\n\n  this.template = options.template || [];\n  this.createItems();\n};\nvar Fragment__proto__ = Fragment.prototype;\n\nFragment__proto__.bind = function bind (context) {\n    var this$1 = this;\n\n  this.context = context;\n\n  if (this.owner.template.z) {\n    this.aliases = resolveAliases(\n      this.owner.template.z,\n      this.owner.containerFragment || this.parent\n    );\n  }\n\n  var len = this.items.length;\n  for (var i = 0; i < len; i++) { this$1.items[i].bind(); }\n  this.bound = true;\n\n  // in rare cases, a forced resolution (or similar) will cause the\n  // fragment to be dirty before it's even finished binding. In those\n  // cases we update immediately\n  if (this.dirty) { this.update(); }\n\n  return this;\n};\n\nFragment__proto__.bubble = function bubble () {\n  this.dirtyValue = true;\n\n  if (!this.dirty) {\n    this.dirty = true;\n\n    if (this.isRoot) {\n      // TODO encapsulate 'is component root, but not overall root' check?\n      if (this.ractive.component) {\n        this.ractive.component.bubble();\n      } else if (this.bound) {\n        runloop.addFragment(this);\n      }\n    } else {\n      this.owner.bubble(this.index);\n    }\n  }\n};\n\nFragment__proto__.createItems = function createItems () {\n    var this$1 = this;\n\n  // this is a hot code path\n  var max = this.template.length;\n  this.items = [];\n  for (var i = 0; i < max; i++) {\n    this$1.items[i] = createItem({\n      up: this$1,\n      template: this$1.template[i],\n      index: i\n    });\n  }\n};\n\nFragment__proto__.destroyed = function destroyed () {\n    var this$1 = this;\n\n  var len = this.items.length;\n  for (var i = 0; i < len; i++) { this$1.items[i].destroyed(); }\n  if (this.pathModel) { this.pathModel.destroyed(); }\n  if (this.rootModel) { this.rootModel.destroyed(); }\n};\n\nFragment__proto__.detach = function detach () {\n  var docFrag = createDocumentFragment();\n  var xs = this.items;\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    docFrag.appendChild(xs[i].detach());\n  }\n  return docFrag;\n};\n\nFragment__proto__.find = function find (selector, options) {\n  return findMap(this.items, function (i) { return i.find(selector, options); });\n};\n\nFragment__proto__.findAll = function findAll (selector, options) {\n  if (this.items) {\n    this.items.forEach(function (i) { return i.findAll && i.findAll(selector, options); });\n  }\n};\n\nFragment__proto__.findComponent = function findComponent (name, options) {\n  return findMap(this.items, function (i) { return i.findComponent(name, options); });\n};\n\nFragment__proto__.findAllComponents = function findAllComponents (name, options) {\n  if (this.items) {\n    this.items.forEach(function (i) { return i.findAllComponents && i.findAllComponents(name, options); });\n  }\n};\n\nFragment__proto__.findContext = function findContext () {\n  var base = findParentWithContext(this);\n  if (!base || !base.context) { return this.ractive.viewmodel; }\n  else { return base.context; }\n};\n\nFragment__proto__.findNextNode = function findNextNode (item) {\n    var this$1 = this;\n\n  // search for the next node going forward\n  if (item) {\n    var it;\n    for (var i = item.index + 1; i < this.items.length; i++) {\n      it = this$1.items[i];\n      if (!it || !it.firstNode) { continue; }\n\n      var node = it.firstNode(true);\n      if (node) { return node; }\n    }\n  }\n\n  // if this is the root fragment, and there are no more items,\n  // it means we're at the end...\n  if (this.isRoot) {\n    if (this.ractive.component) {\n      return this.ractive.component.up.findNextNode(this.ractive.component);\n    }\n\n    // TODO possible edge case with other content\n    // appended to this.ractive.el?\n    return null;\n  }\n\n  if (this.parent) { return this.owner.findNextNode(this); } // the argument is in case the parent is a RepeatedFragment\n};\n\nFragment__proto__.findParentNode = function findParentNode () {\n  var fragment = this;\n\n  do {\n    if (fragment.owner.type === ELEMENT) {\n      return fragment.owner.node;\n    }\n\n    if (fragment.isRoot && !fragment.ractive.component) {\n      // TODO encapsulate check\n      return fragment.ractive.el;\n    }\n\n    if (fragment.owner.type === YIELDER) {\n      fragment = fragment.owner.containerFragment;\n    } else {\n      fragment = fragment.componentParent || fragment.parent; // TODO ugh\n    }\n  } while (fragment);\n\n  throw new Error('Could not find parent node'); // TODO link to issue tracker\n};\n\nFragment__proto__.firstNode = function firstNode (skipParent) {\n  var node = findMap(this.items, function (i) { return i.firstNode(true); });\n  if (node) { return node; }\n  if (skipParent) { return null; }\n\n  return this.parent.findNextNode(this.owner);\n};\n\nFragment__proto__.getKey = function getKey () {\n  return this.keyModel || (this.keyModel = new KeyModel(this.key));\n};\n\nFragment__proto__.getIndex = function getIndex () {\n  return this.idxModel || (this.idxModel = new KeyModel(this.index));\n};\n\nFragment__proto__.rebind = function rebind (next) {\n  this.context = next;\n  if (this.rootModel) { this.rootModel.context = this.context; }\n  if (this.pathModel) { this.pathModel.context = this.context; }\n};\n\nFragment__proto__.rebound = function rebound (update$$1) {\n  if (this.owner.template.z) {\n    var aliases = this.aliases;\n    for (var k in aliases) {\n      if (aliases[k].rebound) { aliases[k].rebound(update$$1); }\n      else {\n        aliases[k].unreference();\n        aliases[k] = 0;\n      }\n    }\n\n    resolveAliases(this.owner.template.z, this.owner.containerFragment || this.parent, aliases);\n  }\n\n  this.items.forEach(function (x) { return x.rebound(update$$1); });\n  if (update$$1) {\n    if (this.rootModel) { this.rootModel.applyValue(this.context.getKeypath(this.ractive.root)); }\n    if (this.pathModel) { this.pathModel.applyValue(this.context.getKeypath()); }\n  }\n};\n\nFragment__proto__.render = function render (target, occupants) {\n  if (this.rendered) { throw new Error('Fragment is already rendered!'); }\n  this.rendered = true;\n\n  var xs = this.items;\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    xs[i].render(target, occupants);\n  }\n};\n\nFragment__proto__.resetTemplate = function resetTemplate (template) {\n  var wasBound = this.bound;\n  var wasRendered = this.rendered;\n\n  // TODO ensure transitions are disabled globally during reset\n\n  if (wasBound) {\n    if (wasRendered) { this.unrender(true); }\n    this.unbind();\n  }\n\n  this.template = template;\n  this.createItems();\n\n  if (wasBound) {\n    this.bind(this.context);\n\n    if (wasRendered) {\n      var parentNode = this.findParentNode();\n      var anchor = this.findNextNode();\n\n      if (anchor) {\n        var docFrag = createDocumentFragment();\n        this.render(docFrag);\n        parentNode.insertBefore(docFrag, anchor);\n      } else {\n        this.render(parentNode);\n      }\n    }\n  }\n};\n\nFragment__proto__.shuffled = function shuffled$3 () {\n  this.items.forEach(shuffled);\n  if (this.rootModel) { this.rootModel.applyValue(this.context.getKeypath(this.ractive.root)); }\n  if (this.pathModel) { this.pathModel.applyValue(this.context.getKeypath()); }\n};\n\nFragment__proto__.toString = function toString (escape) {\n  return this.items.map(escape ? toEscapedString : toString$1).join('');\n};\n\nFragment__proto__.unbind = function unbind (view) {\n    var this$1 = this;\n\n  if (this.owner.template.z && !this.owner.yielder) {\n    for (var k in this$1.aliases) {\n      this$1.aliases[k].unreference();\n    }\n\n    this.aliases = {};\n  }\n\n  this.context = null;\n  var len = this.items.length;\n  for (var i = 0; i < len; i++) { this$1.items[i].unbind(view); }\n  this.bound = false;\n\n  return this;\n};\n\nFragment__proto__.unrender = function unrender (shouldDestroy) {\n    var this$1 = this;\n\n  var len = this.items.length;\n  for (var i = 0; i < len; i++) { this$1.items[i].unrender(shouldDestroy); }\n  this.rendered = false;\n};\n\nFragment__proto__.update = function update () {\n    var this$1 = this;\n\n  if (this.dirty) {\n    if (!this.updating) {\n      this.dirty = false;\n      this.updating = true;\n      var len = this.items.length;\n      for (var i = 0; i < len; i++) { this$1.items[i].update(); }\n      this.updating = false;\n    } else if (this.isRoot) {\n      runloop.addFragmentToRoot(this);\n    }\n  }\n};\n\nFragment__proto__.valueOf = function valueOf () {\n  if (this.items.length === 1) {\n    return this.items[0].valueOf();\n  }\n\n  if (this.dirtyValue) {\n    var values = {};\n    var source = processItems(this.items, values, this.ractive._guid);\n    var parsed = parseJSON(source, values);\n\n    this.value = parsed ? parsed.value : this.toString();\n\n    this.dirtyValue = false;\n  }\n\n  return this.value;\n};\nFragment.prototype.getContext = getContext;\nFragment.prototype.getKeypath = getKeypath;\n\nfunction getKeypath(root) {\n  var base = findParentWithContext(this);\n  var model;\n  if (root) {\n    if (!this.rootModel) {\n      this.rootModel = new KeyModel(\n        this.context.getKeypath(this.ractive.root),\n        this.context,\n        this.ractive.root\n      );\n      model = this.rootModel;\n    } else { return this.rootModel; }\n  } else {\n    if (!this.pathModel) {\n      this.pathModel = new KeyModel(this.context.getKeypath(), this.context);\n      model = this.pathModel;\n    } else { return this.pathModel; }\n  }\n\n  if (base && base.context) { base.getKeypath(root).registerChild(model); }\n\n  return model;\n}\n\nfunction initialise(ractive, userOptions, options) {\n  // initialize settable computeds\n  var computed = ractive.viewmodel.computed;\n  if (computed) {\n    for (var k in computed) {\n      if (k in ractive.viewmodel.value && computed[k] && !computed[k].isReadonly) {\n        computed[k].set(ractive.viewmodel.value[k]);\n      }\n    }\n  }\n\n  // init config from Parent and options\n  config.init(ractive.constructor, ractive, userOptions);\n\n  // call any passed in plugins\n  if (isArray(userOptions.use))\n    { ractive.use.apply(ractive, userOptions.use.filter(function (p) { return !p.construct; })); }\n\n  hooks.config.fire(ractive);\n\n  hooks.init.begin(ractive);\n\n  var fragment = (ractive.fragment = createFragment$1(ractive, options));\n  if (fragment) { fragment.bind(ractive.viewmodel); }\n\n  hooks.init.end(ractive);\n\n  // general config done, set up observers\n  subscribe(ractive, userOptions, 'observe');\n\n  if (fragment) {\n    // render automatically ( if `el` is specified )\n    var el = (ractive.el = ractive.target = getElement(ractive.el || ractive.target));\n    if (el && !ractive.component) {\n      var promise = ractive.render(el, ractive.append);\n\n      if (Ractive.DEBUG_PROMISES) {\n        promise.catch(function (err) {\n          warnOnceIfDebug(\n            'Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;'\n          );\n          warnIfDebug('An error happened during rendering', { ractive: ractive });\n          logIfDebug(err);\n\n          throw err;\n        });\n      }\n    }\n  }\n}\n\nfunction createFragment$1(ractive, options) {\n  if ( options === void 0 ) options = {};\n\n  if (ractive.template) {\n    var cssIds = [].concat(ractive.constructor._cssIds || [], options.cssIds || []);\n\n    return new Fragment({\n      owner: ractive,\n      template: ractive.template,\n      cssIds: cssIds\n    });\n  }\n}\n\nfunction render$1(ractive, target, anchor, occupants) {\n  // set a flag to let any transitions know that this instance is currently rendering\n  ractive.rendering = true;\n\n  var promise = runloop.start();\n  runloop.scheduleTask(function () { return hooks.render.fire(ractive); }, true);\n\n  if (ractive.fragment.rendered) {\n    throw new Error(\n      'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first'\n    );\n  }\n\n  if (ractive.destroyed) {\n    ractive.destroyed = false;\n    ractive.fragment = createFragment$1(ractive).bind(ractive.viewmodel);\n  }\n\n  anchor = getElement(anchor) || ractive.anchor;\n\n  ractive.el = ractive.target = target;\n  ractive.anchor = anchor;\n\n  // ensure encapsulated CSS is up-to-date\n  if (ractive.cssId) { applyCSS(); }\n\n  if (target) {\n    (target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(ractive);\n\n    if (anchor) {\n      var docFrag = doc.createDocumentFragment();\n      ractive.fragment.render(docFrag);\n      target.insertBefore(docFrag, anchor);\n    } else {\n      ractive.fragment.render(target, occupants);\n    }\n  }\n\n  runloop.end();\n  ractive.rendering = false;\n\n  return promise.then(function () {\n    if (ractive.torndown) { return; }\n\n    hooks.complete.fire(ractive);\n  });\n}\n\nfunction Ractive$render(target, anchor) {\n  if (this.torndown) {\n    warnIfDebug('ractive.render() was called on a Ractive instance that was already torn down');\n    return Promise.resolve();\n  }\n\n  target = getElement(target) || this.el;\n\n  if (!this.append && target) {\n    // Teardown any existing instances *before* trying to set up the new one -\n    // avoids certain weird bugs\n    var others = target.__ractive_instances__;\n    if (others) { others.forEach(teardown); }\n\n    // make sure we are the only occupants\n    if (!this.enhance) {\n      target.innerHTML = ''; // TODO is this quicker than removeChild? Initial research inconclusive\n    }\n  }\n\n  var occupants = this.enhance ? toArray(target.childNodes) : null;\n  var promise = render$1(this, target, anchor, occupants);\n\n  if (occupants) {\n    while (occupants.length) { target.removeChild(occupants.pop()); }\n  }\n\n  return promise;\n}\n\nvar shouldRerender = ['template', 'partials', 'components', 'decorators', 'events'];\n\nfunction Ractive$reset(data) {\n  data = data || {};\n\n  if (!isObjectType(data)) {\n    throw new Error('The reset method takes either no arguments, or an object containing new data');\n  }\n\n  // TEMP need to tidy this up\n  data = dataConfigurator.init(this.constructor, this, { data: data });\n\n  var promise = runloop.start();\n\n  // If the root object is wrapped, try and use the wrapper's reset value\n  var wrapper = this.viewmodel.wrapper;\n  if (wrapper && wrapper.reset) {\n    if (wrapper.reset(data) === false) {\n      // reset was rejected, we need to replace the object\n      this.viewmodel.set(data);\n    }\n  } else {\n    this.viewmodel.set(data);\n  }\n\n  // reset config items and track if need to rerender\n  var changes = config.reset(this);\n  var rerender;\n\n  var i = changes.length;\n  while (i--) {\n    if (shouldRerender.indexOf(changes[i]) > -1) {\n      rerender = true;\n      break;\n    }\n  }\n\n  if (rerender) {\n    hooks.unrender.fire(this);\n    this.fragment.resetTemplate(this.template);\n    hooks.render.fire(this);\n    hooks.complete.fire(this);\n  }\n\n  runloop.end();\n\n  hooks.reset.fire(this, data);\n\n  return promise;\n}\n\nfunction collect$1(source, name, attr, dest) {\n  source.forEach(function (item) {\n    // queue to rerender if the item is a partial and the current name matches\n    if (item.type === PARTIAL && (item.refName === name || item.name === name)) {\n      item.inAttribute = attr;\n      dest.push(item);\n      return; // go no further\n    }\n\n    // if it has a fragment, process its items\n    if (item.fragment) {\n      collect$1(item.fragment.iterations || item.fragment.items, name, attr, dest);\n    } else if (isArray(item.items)) {\n      // or if it is itself a fragment, process its items\n      collect$1(item.items, name, attr, dest);\n    } else if (item.type === COMPONENT && item.instance) {\n      // or if it is a component, step in and process its items\n      // ...unless the partial is shadowed\n      if (item.instance.partials[name]) { return; }\n      collect$1(item.instance.fragment.items, name, attr, dest);\n    }\n\n    // if the item is an element, process its attributes too\n    if (item.type === ELEMENT) {\n      if (isArray(item.attributes)) {\n        collect$1(item.attributes, name, true, dest);\n      }\n    }\n  });\n}\n\nfunction resetPartial(name, partial) {\n  var collection = [];\n  collect$1(this.fragment.items, name, false, collection);\n\n  var promise = runloop.start();\n\n  this.partials[name] = partial;\n  collection.forEach(handleChange);\n\n  runloop.end();\n\n  return promise;\n}\n\n// TODO should resetTemplate be asynchronous? i.e. should it be a case\n// of outro, update template, intro? I reckon probably not, since that\n// could be achieved with unrender-resetTemplate-render. Also, it should\n// conceptually be similar to resetPartial, which couldn't be async\n\nfunction Ractive$resetTemplate(template) {\n  templateConfigurator.init(null, this, { template: template });\n\n  var transitionsEnabled = this.transitionsEnabled;\n  this.transitionsEnabled = false;\n\n  // Is this is a component, we need to set the `shouldDestroy`\n  // flag, otherwise it will assume by default that a parent node\n  // will be detached, and therefore it doesn't need to bother\n  // detaching its own nodes\n  var component = this.component;\n  if (component) { component.shouldDestroy = true; }\n  this.unrender();\n  if (component) { component.shouldDestroy = false; }\n\n  var promise = runloop.start();\n\n  // remove existing fragment and create new one\n  this.fragment.unbind().unrender(true);\n\n  this.fragment = new Fragment({\n    template: this.template,\n    root: this,\n    owner: this\n  });\n\n  var docFrag = createDocumentFragment();\n  this.fragment.bind(this.viewmodel).render(docFrag);\n\n  // if this is a component, its el may not be valid, so find a\n  // target based on the component container\n  if (component && !component.external) {\n    this.fragment.findParentNode().insertBefore(docFrag, component.findNextNode());\n  } else {\n    this.el.insertBefore(docFrag, this.anchor);\n  }\n\n  runloop.end();\n\n  this.transitionsEnabled = transitionsEnabled;\n\n  return promise;\n}\n\nvar reverse = makeArrayMethod('reverse').path;\n\nfunction Ractive$set(keypath, value, options) {\n  var ractive = this;\n\n  var opts = isObjectType(keypath) ? value : options;\n\n  return set(build(ractive, keypath, value, opts && opts.isolated), opts);\n}\n\nvar shift = makeArrayMethod('shift').path;\n\nvar sort = makeArrayMethod('sort').path;\n\nvar splice = makeArrayMethod('splice').path;\n\nfunction Ractive$subtract(keypath, d, options) {\n  var num = isNumber(d) ? -d : -1;\n  var opts = isObjectType(d) ? d : options;\n  return add(this, keypath, num, opts);\n}\n\nfunction Ractive$toggle(keypath, options) {\n  if (!isString(keypath)) {\n    throw new TypeError(badArguments);\n  }\n\n  return set(\n    gather(this, keypath, null, options && options.isolated).map(function (m) { return [m, !m.get()]; }),\n    options\n  );\n}\n\nfunction Ractive$toCSS() {\n  var cssIds = [this.cssId ].concat( this.findAllComponents().map(function (c) { return c.cssId; }));\n  var uniqueCssIds = keys(cssIds.reduce(function (ids, id) { return (ids[id] = true, ids); }, {}));\n  return getCSS(uniqueCssIds);\n}\n\nfunction Ractive$toHTML() {\n  return this.fragment.toString(true);\n}\n\nfunction toText() {\n  return this.fragment.toString(false);\n}\n\nfunction Ractive$transition(name, node, params) {\n  if (node instanceof HTMLElement) {\n    // good to go\n  } else if (isObject(node)) {\n    // omitted, use event node\n    params = node;\n  }\n\n  // if we allow query selector, then it won't work\n  // simple params like \"fast\"\n\n  // else if ( typeof node === 'string' ) {\n  // \t// query selector\n  // \tnode = this.find( node )\n  // }\n\n  node = node || this.event.node;\n\n  if (!node || !node._ractive) {\n    fatal((\"No node was supplied for transition \" + name));\n  }\n\n  params = params || {};\n  var owner = node._ractive.proxy;\n  var transition = new Transition({ owner: owner, up: owner.up, name: name, params: params });\n  transition.bind();\n\n  var promise = runloop.start();\n  runloop.registerTransition(transition);\n  runloop.end();\n\n  promise.then(function () { return transition.unbind(); });\n  return promise;\n}\n\nfunction unlink(here) {\n  var promise = runloop.start();\n  this.viewmodel.joinAll(splitKeypath(here), { lastLink: false }).unlink();\n  runloop.end();\n  return promise;\n}\n\nfunction Ractive$unrender() {\n  if (!this.fragment.rendered) {\n    warnIfDebug('ractive.unrender() was called on a Ractive instance that was not rendered');\n    return Promise.resolve();\n  }\n\n  this.unrendering = true;\n  var promise = runloop.start();\n\n  hooks.unrendering.fire(this);\n\n  // If this is a component, and the component isn't marked for destruction,\n  // don't detach nodes from the DOM unnecessarily\n  var shouldDestroy =\n    !this.component ||\n    (this.component.anchor || {}).shouldDestroy ||\n    this.component.shouldDestroy ||\n    this.shouldDestroy;\n  this.fragment.unrender(shouldDestroy);\n  if (shouldDestroy) { this.destroyed = true; }\n\n  removeFromArray(this.el.__ractive_instances__, this);\n\n  hooks.unrender.fire(this);\n\n  runloop.end();\n  this.unrendering = false;\n\n  return promise;\n}\n\nvar unshift = makeArrayMethod('unshift').path;\n\nfunction Ractive$updateModel(keypath, cascade) {\n  var promise = runloop.start();\n\n  if (!keypath) {\n    this.viewmodel.updateFromBindings(true);\n  } else {\n    this.viewmodel.joinAll(splitKeypath(keypath)).updateFromBindings(cascade !== false);\n  }\n\n  runloop.end();\n\n  return promise;\n}\n\nfunction use() {\n  var this$1 = this;\n  var plugins = [], len = arguments.length;\n  while ( len-- ) plugins[ len ] = arguments[ len ];\n\n  plugins.forEach(function (p) {\n    p({\n      proto: this$1,\n      Ractive: this$1.constructor.Ractive,\n      instance: this$1\n    });\n  });\n  return this;\n}\n\nvar proto$9 = {\n  add: Ractive$add,\n  animate: Ractive$animate,\n  attachChild: attachChild,\n  compute: Ractive$compute,\n  detach: Ractive$detach,\n  detachChild: detachChild,\n  find: Ractive$find,\n  findAll: Ractive$findAll,\n  findAllComponents: Ractive$findAllComponents,\n  findComponent: Ractive$findComponent,\n  findContainer: Ractive$findContainer,\n  findParent: Ractive$findParent,\n  fire: Ractive$fire,\n  get: Ractive$get,\n  getLocalContext: getLocalContext,\n  getContext: getContext$2,\n  insert: Ractive$insert,\n  link: link,\n  observe: observe,\n  observeOnce: observeOnce,\n  off: Ractive$off,\n  on: Ractive$on,\n  once: Ractive$once,\n  pop: pop,\n  push: push,\n  readLink: readLink,\n  render: Ractive$render,\n  reset: Ractive$reset,\n  resetPartial: resetPartial,\n  resetTemplate: Ractive$resetTemplate,\n  reverse: reverse,\n  set: Ractive$set,\n  shift: shift,\n  sort: sort,\n  splice: splice,\n  subtract: Ractive$subtract,\n  teardown: Ractive$teardown,\n  toggle: Ractive$toggle,\n  toCSS: Ractive$toCSS,\n  toCss: Ractive$toCSS,\n  toHTML: Ractive$toHTML,\n  toHtml: Ractive$toHTML,\n  toText: toText,\n  transition: Ractive$transition,\n  unlink: unlink,\n  unrender: Ractive$unrender,\n  unshift: unshift,\n  update: Ractive$update,\n  updateModel: Ractive$updateModel,\n  use: use\n};\n\nfunction isInstance(object) {\n  return object && object instanceof this;\n}\n\nfunction styleGet(keypath, opts) {\n  return this._cssModel.joinAll(splitKeypath(keypath)).get(true, opts);\n}\n\nvar styles = [];\n\nfunction addStyle(id, css) {\n  if (styles.find(function (s) { return s.id === id; }))\n    { throw new Error((\"Extra styles with the id '\" + id + \"' have already been added.\")); }\n  styles.push({ id: id, css: css });\n\n  if (!this.css) {\n    Object.defineProperty(this, 'css', { configurable: false, writable: false, value: buildCSS });\n  }\n\n  if (!this._cssDef) {\n    Object.defineProperty(this, '_cssDef', {\n      configurable: true,\n      writable: false,\n      value: {\n        transform: false,\n        id: 'Ractive.addStyle'\n      }\n    });\n\n    addCSS(this._cssDef);\n  }\n\n  recomputeCSS(this);\n  applyCSS(true);\n}\n\nfunction buildCSS(data) {\n  return styles\n    .map(function (s) { return \"\\n/* ---- extra style \" + (s.id) + \" */\\n\" + (isFunction(s.css) ? s.css(data) : s.css); })\n    .join('');\n}\n\nfunction hasStyle(id) {\n  return !!styles.find(function (s) { return s.id === id; });\n}\n\nfunction sharedSet(keypath, value, options) {\n  var opts = isObjectType(keypath) ? value : options;\n  var model = SharedModel$1;\n\n  return set(build({ viewmodel: model }, keypath, value, true), opts);\n}\n\nfunction sharedGet(keypath, opts) {\n  return SharedModel$1.joinAll(splitKeypath(keypath)).get(true, opts);\n}\n\nfunction use$1() {\n  var this$1 = this;\n  var plugins = [], len = arguments.length;\n  while ( len-- ) plugins[ len ] = arguments[ len ];\n\n  plugins.forEach(function (p) {\n    isFunction(p) &&\n      p({\n        proto: this$1.prototype,\n        Ractive: this$1.Ractive,\n        instance: this$1\n      });\n  });\n  return this;\n}\n\nvar callsSuper = /super\\s*\\(|\\.call\\s*\\(\\s*this/;\n\nfunction extend() {\n  var options = [], len = arguments.length;\n  while ( len-- ) options[ len ] = arguments[ len ];\n\n  if (!options.length) {\n    return extendOne(this);\n  } else {\n    return options.reduce(extendOne, this);\n  }\n}\n\nfunction extendWith(Class, options) {\n  if ( options === void 0 ) options = {};\n\n  return extendOne(this, options, Class);\n}\n\nfunction extendOne(Parent, options, Target) {\n  if ( options === void 0 ) options = {};\n\n  var proto;\n  var Child = isFunction(Target) && Target;\n\n  if (options.prototype instanceof Ractive) {\n    throw new Error(\"Ractive no longer supports multiple inheritance.\");\n  }\n\n  if (Child) {\n    if (!(Child.prototype instanceof Parent)) {\n      throw new Error(\n        \"Only classes that inherit the appropriate prototype may be used with extend\"\n      );\n    }\n    if (!callsSuper.test(Child.toString())) {\n      throw new Error(\"Only classes that call super in their constructor may be used with extend\");\n    }\n\n    proto = Child.prototype;\n  } else {\n    Child = function(options) {\n      if (!(this instanceof Child)) { return new Child(options); }\n      if (options && options.component === true) { return; }\n\n      construct(this, options || {});\n      initialise(this, options || {}, {});\n    };\n\n    proto = create(Parent.prototype);\n    proto.constructor = Child;\n\n    Child.prototype = proto;\n  }\n\n  // Static properties\n  defineProperties(Child, {\n    // alias prototype as defaults\n    defaults: { value: proto },\n\n    extend: { value: extend, writable: true, configurable: true },\n    extendWith: { value: extendWith, writable: true, configurable: true },\n    extensions: { value: [] },\n    use: { value: use$1 },\n\n    isInstance: { value: isInstance },\n\n    Parent: { value: Parent },\n    Ractive: { value: Ractive },\n\n    styleGet: { value: styleGet.bind(Child), configurable: true },\n    styleSet: { value: setCSSData.bind(Child), configurable: true }\n  });\n\n  // extend configuration\n  config.extend(Parent, proto, options, Child);\n\n  // store event and observer registries on the constructor when extending\n  Child._on = (Parent._on || []).concat(toPairs(options.on));\n  Child._observe = (Parent._observe || []).concat(toPairs(options.observe));\n\n  Parent.extensions.push(Child);\n\n  // attribute defs are not inherited, but they need to be stored\n  if (options.attributes) {\n    var attrs;\n\n    // allow an array of optional props or an object with arrays for optional and required props\n    if (isArray(options.attributes)) {\n      attrs = { optional: options.attributes, required: [] };\n    } else {\n      attrs = options.attributes;\n    }\n\n    // make sure the requisite keys actually store arrays\n    if (!isArray(attrs.required)) { attrs.required = []; }\n    if (!isArray(attrs.optional)) { attrs.optional = []; }\n\n    Child.attributes = attrs;\n  }\n\n  dataConfigurator.extend(Parent, proto, options, Child);\n\n  defineProperty(Child, 'helpers', { writable: true, value: proto.helpers });\n\n  if (isArray(options.use)) { Child.use.apply(Child, options.use); }\n\n  return Child;\n}\n\ndefineProperties(Ractive, {\n  sharedGet: { value: sharedGet },\n  sharedSet: { value: sharedSet },\n  styleGet: { configurable: true, value: styleGet.bind(Ractive) },\n  styleSet: { configurable: true, value: setCSSData.bind(Ractive) },\n  addCSS: { configurable: false, value: addStyle.bind(Ractive) },\n  hasCSS: { configurable: false, value: hasStyle.bind(Ractive) }\n});\n\nfunction macro(fn, opts) {\n  if (!isFunction(fn)) { throw new Error(\"The macro must be a function\"); }\n\n  assign(fn, opts);\n\n  defineProperties(fn, {\n    extensions: { value: [] },\n    _cssIds: { value: [] },\n    cssData: { value: assign(create(this.cssData), fn.cssData || {}) },\n\n    styleGet: { value: styleGet.bind(fn) },\n    styleSet: { value: setCSSData.bind(fn) }\n  });\n\n  defineProperty(fn, '_cssModel', { value: new CSSModel(fn) });\n\n  if (fn.css) { initCSS(fn, fn, fn); }\n\n  this.extensions.push(fn);\n\n  return fn;\n}\n\nfunction findPlugin(name, type, instance) {\n  return findInViewHierarchy(type, instance, name);\n}\n\nfunction Ractive(options) {\n  if (!(this instanceof Ractive)) { return new Ractive(options); }\n  if (options && options.component) { return; }\n\n  construct(this, options || {});\n  initialise(this, options || {}, {});\n}\n\n// check to see if we're being asked to force Ractive as a global for some weird environments\nif (win && !win.Ractive) {\n  var opts$1 = '';\n  var script =\n    document.currentScript ||\n    /* istanbul ignore next */ document.querySelector('script[data-ractive-options]');\n\n  if (script) { opts$1 = script.getAttribute('data-ractive-options') || ''; }\n\n  /* istanbul ignore next */\n  if (~opts$1.indexOf('ForceGlobal')) { win.Ractive = Ractive; }\n} else if (win) {\n  warn(\"Ractive already appears to be loaded while loading 1.4.0-edge.\");\n}\n\nassign(Ractive.prototype, proto$9, defaults);\nRactive.prototype.constructor = Ractive;\n\n// alias prototype as `defaults`\nRactive.defaults = Ractive.prototype;\n\n// share defaults with the parser\nshared.defaults = Ractive.defaults;\nshared.Ractive = Ractive;\n\n// static properties\ndefineProperties(Ractive, {\n  // debug flag\n  DEBUG: { writable: true, value: true },\n  DEBUG_PROMISES: { writable: true, value: true },\n\n  // static methods:\n  extend: { value: extend },\n  extendWith: { value: extendWith },\n  escapeKey: { value: escapeKey },\n  evalObjectString: { value: parseJSON },\n  findPlugin: { value: findPlugin },\n  getContext: { value: getContext$1 },\n  getCSS: { value: getCSS },\n  isInstance: { value: isInstance },\n  joinKeys: { value: joinKeys },\n  macro: { value: macro },\n  normaliseKeypath: { value: normalise },\n  parse: { value: parse },\n  splitKeypath: { value: splitKeypath$1 },\n  // sharedSet and styleSet are in _extend because circular refs\n  unescapeKey: { value: unescapeKey },\n  use: { value: use$1 },\n\n  // support\n  enhance: { writable: true, value: false },\n  svg: { value: svg },\n  tick: {\n    get: function get() {\n      return batch && batch.promise;\n    }\n  },\n\n  // version\n  VERSION: { value: '1.4.0-edge' },\n\n  // plugins\n  adaptors: { writable: true, value: {} },\n  components: { writable: true, value: {} },\n  decorators: { writable: true, value: {} },\n  easing: { writable: true, value: easing },\n  events: { writable: true, value: {} },\n  extensions: { value: [] },\n  helpers: { writable: true, value: defaults.helpers },\n  interpolators: { writable: true, value: interpolators },\n  partials: { writable: true, value: {} },\n  transitions: { writable: true, value: {} },\n\n  // CSS variables\n  cssData: { configurable: true, value: {} },\n  perComponentStyleElements: { get: splitTag, set: splitTag },\n\n  // access to @shared without an instance\n  sharedData: { value: data },\n\n  // for getting the source Ractive lib from a constructor\n  Ractive: { value: Ractive },\n\n  // to allow extending contexts\n  Context: { value: extern.Context.prototype }\n});\n\n// cssData must already be in place\ndefineProperty(Ractive, '_cssModel', {\n  configurable: true,\n  value: new CSSModel(Ractive)\n});\n\ndefineProperty(Ractive.prototype, 'rendered', {\n  get: function get() {\n    return this.fragment && this.fragment.rendered;\n  }\n});\n\nreturn Ractive;\n\n})));\n//# sourceMappingURL=ractive.js.map\n\n//# sourceURL=webpack://GruntjsTest/./frontend/js/ractive.js?")},"./frontend/js/ractive.min.js":function(module,__unused_webpack_exports,__webpack_require__){eval('!(function (t, e) {\n   true\n    ? (module.exports = e())\n    : 0;\n})(this, function () {\n  "use strict";\n  function t(t, e) {\n    return Object.prototype.hasOwnProperty.call(t, e);\n  }\n  function e(e) {\n    for (var n = [], i = arguments.length - 1; i-- > 0; )\n      n[i] = arguments[i + 1];\n    for (var r = 0; r < n.length; r++) {\n      var s = n[r];\n      for (var a in s) a in e || !t(s, a) || (e[a] = s[a]);\n    }\n    return e;\n  }\n  function n(e) {\n    void 0 === e && (e = {});\n    var n = [];\n    for (var i in e) t(e, i) && n.push([i, e[i]]);\n    return n;\n  }\n  function i(t, e) {\n    return null === t && null === e ? !0 : o(t) || o(e) ? !1 : t === e;\n  }\n  function r(t) {\n    return !isNaN(parseFloat(t)) && isFinite(t);\n  }\n  function s(t) {\n    return t && "[object Object]" === Wa.call(t);\n  }\n  function a(t) {\n    return !(!t || (!o(t) && !u(t)));\n  }\n  function o(t) {\n    return "object" == typeof t;\n  }\n  function u(t) {\n    return "function" == typeof t;\n  }\n  function h(t) {\n    return "string" == typeof t;\n  }\n  function l(t) {\n    return "number" == typeof t;\n  }\n  function c(t) {\n    return void 0 === t;\n  }\n  function f() {}\n  function d(t, e) {\n    return t.replace(/%s/g, function () {\n      return e.shift();\n    });\n  }\n  function p(t) {\n    for (var e = [], n = arguments.length - 1; n-- > 0; )\n      e[n] = arguments[n + 1];\n    throw ((t = d(t, e)), new Error(t));\n  }\n  function m() {\n    Fa.DEBUG && fo.apply(null, arguments);\n  }\n  function v(t) {\n    for (var e = [], n = arguments.length - 1; n-- > 0; )\n      e[n] = arguments[n + 1];\n    (t = d(t, e)), po(t, e);\n  }\n  function g(t) {\n    for (var e = [], n = arguments.length - 1; n-- > 0; )\n      e[n] = arguments[n + 1];\n    (t = d(t, e)), yo[t] || ((yo[t] = !0), po(t, e));\n  }\n  function y() {\n    Fa.DEBUG && v.apply(null, arguments);\n  }\n  function b() {\n    Fa.DEBUG && g.apply(null, arguments);\n  }\n  function w(t, e, n) {\n    var i = x(t, e, n);\n    return i ? i[t][n] : null;\n  }\n  function x(t, e, n) {\n    for (; e; ) {\n      if (n in e[t]) return e;\n      if (e.isolated) return null;\n      e = e.parent;\n    }\n  }\n  function k(t, e, n, i) {\n    if (t === e) return null;\n    if (i) {\n      var r = w("interpolators", n, i);\n      if (r) return r(t, e) || null;\n      p(_o(i, "interpolator"));\n    }\n    return Eo.number(t, e) || Eo.array(t, e) || Eo.object(t, e) || null;\n  }\n  function _(t) {\n    return h(t) ? t.replace(Co, "\\\\$&") : t;\n  }\n  function E(t) {\n    return t ? t.replace(So, ".$1") : "";\n  }\n  function S(t) {\n    var e,\n      n = [];\n    for (t = E(t); (e = Ao.exec(t)); ) {\n      var i = e.index + e[1].length;\n      n.push(t.substr(0, i)), (t = t.substr(i + 1));\n    }\n    return n.push(t), n;\n  }\n  function A(t) {\n    return h(t) ? t.replace(Oo, "$1$2") : t;\n  }\n  function C(t, e) {\n    var n = t.indexOf(e);\n    -1 === n && t.push(e);\n  }\n  function O(t, e) {\n    for (var n = 0, i = t.length; i > n; n++) if (t[n] == e) return !0;\n    return !1;\n  }\n  function N(t, e) {\n    var n;\n    if (!Ga(t) || !Ga(e)) return !1;\n    if (t.length !== e.length) return !1;\n    for (n = t.length; n--; ) if (t[n] !== e[n]) return !1;\n    return !0;\n  }\n  function j(t) {\n    return h(t) ? [t] : c(t) ? [] : t;\n  }\n  function T(t) {\n    return t[t.length - 1];\n  }\n  function V(t, e) {\n    if (t) {\n      var n = t.indexOf(e);\n      -1 !== n && t.splice(n, 1);\n    }\n  }\n  function P() {\n    for (var t = [], e = arguments.length; e--; ) t[e] = arguments[e];\n    for (var n = t.concat.apply([], t), i = n.length; i--; ) {\n      var r = n.indexOf(n[i]);\n      ~r && i > r && n.splice(i, 1);\n    }\n    return n;\n  }\n  function M(t) {\n    for (var e = [], n = t.length; n--; ) e[n] = t[n];\n    return e;\n  }\n  function I(t, e) {\n    for (var n = t.length, i = 0; n > i; i++) {\n      var r = e(t[i]);\n      if (r) return r;\n    }\n  }\n  function R(t, e, n) {\n    var i = t,\n      r = e;\n    n && ((i = i.map(n)), (r = r.map(n)));\n    var s = i.length,\n      a = {},\n      o = 0,\n      u = i.map(function (t) {\n        var e,\n          n = o;\n        do {\n          if (((e = r.indexOf(t, n)), -1 === e)) return -1;\n          n = e + 1;\n        } while (a[e] === !0 && s > n);\n        return e === o && (o += 1), (a[e] = !0), e;\n      }),\n      h = (u.oldLen = i.length);\n    if (((u.newLen = r.length), h === u.newLen)) {\n      var l = 0;\n      for (l; h > l && u[l] === l; l++);\n      l === h && (u.same = !0);\n    }\n    return u;\n  }\n  function B(t, e) {\n    if (!/this/.test(t.toString())) return t;\n    var n = No.call(t, e);\n    for (var i in t) n[i] = t[i];\n    return n;\n  }\n  function K(t, e, n) {\n    return n && u(e) && t.parent && t.parent.isRoot\n      ? (t.boundValue ||\n          (t.boundValue = B(e._r_unbound || e, t.parent.ractive)),\n        t.boundValue)\n      : e;\n  }\n  function L(t) {\n    t.updateFromBindings(!0);\n  }\n  function D(t) {\n    for (var e = t.length; e--; )\n      if (t[e].bound) {\n        var n = t[e].owner;\n        if (n) {\n          var i = "checked" === n.name ? n.node.checked : n.node.value;\n          return { value: i };\n        }\n      }\n  }\n  function F(t) {\n    if (t) {\n      var e = jo[t];\n      jo[t] = [];\n      for (var n = e.length; n--; ) e[n]();\n      var i = To[t];\n      for (To[t] = [], n = i.length; n--; ) i[n].model.register(i[n].item);\n    } else F("early"), F("mark");\n  }\n  function z(t, e, n, i) {\n    t.shuffling = !0;\n    for (var r = e.length; r--; ) {\n      var s = e[r];\n      r !== s &&\n        r in t.childByKey &&\n        t.childByKey[r].rebind(~s ? t.joinKey(s) : void 0, t.childByKey[r], !i);\n    }\n    var a = t.source().length !== t.source().value.length;\n    for (\n      t.links.forEach(function (t) {\n        return t.shuffle(e);\n      }),\n        n || F("early"),\n        r = t.deps.length;\n      r--;\n\n    )\n      t.deps[r].shuffle && t.deps[r].shuffle(e);\n    t[n ? "marked" : "mark"](),\n      n || F("mark"),\n      a && t.notifyUpstream(),\n      (t.shuffling = !1);\n  }\n  function U(t, e) {\n    e !== t.dataModel &&\n      (e && e.viewmodel && e.viewmodel.isRoot && t.childByKey.data\n        ? (t.childByKey.data.link(e.viewmodel, "data"), (t.dataModel = e))\n        : t.dataModel && (t.childByKey.data.unlink(), (t.dataModel = !0)));\n  }\n  function $() {\n    Ro.push((Io = []));\n  }\n  function q() {\n    var t = Ro.pop();\n    return (Io = Ro[Ro.length - 1]), t;\n  }\n  function H(t) {\n    Io && C(Io, t);\n  }\n  function Z(t) {\n    t.bind();\n  }\n  function W(t) {\n    t.cancel();\n  }\n  function G(t) {\n    t.destroyed();\n  }\n  function Q(t) {\n    t.handleChange();\n  }\n  function Y(t) {\n    t.mark();\n  }\n  function J(t) {\n    t.mark(!0);\n  }\n  function X(t) {\n    t.marked();\n  }\n  function tt(t) {\n    t.markedAll();\n  }\n  function et(t) {\n    t.render();\n  }\n  function nt(t) {\n    t.shuffled();\n  }\n  function it(t) {\n    t.teardown();\n  }\n  function rt(t) {\n    t.unbind();\n  }\n  function st(t) {\n    t.unrender();\n  }\n  function at(t) {\n    t.update();\n  }\n  function ot(t) {\n    return t.toString();\n  }\n  function ut(t) {\n    return t.toString(!0);\n  }\n  function ht(t, e, n, i) {\n    var r = t.r || t;\n    if (!r || !h(r)) return e;\n    if ("." === r || "@" === r[0] || (e || n).isKey || (e || n).isKeypath)\n      return e;\n    var s = r.split("/"),\n      a = S(s[s.length - 1]),\n      o = a[a.length - 1],\n      u = e || n;\n    u && 1 === a.length && o !== u.key && i && (a = lt(o, i) || a);\n    for (var l = a.length, c = !0, f = !1; u && l--; )\n      u.shuffling && (f = !0), a[l] != u.key && (c = !1), (u = u.parent);\n    return !e && c && f ? n : e && !c && f ? n : e;\n  }\n  function lt(t, e) {\n    for (; e; ) {\n      var n = e.aliases;\n      if (n && n[t]) {\n        for (\n          var i = (e.owner.iterations ? e.owner : e).owner.template.z, r = 0;\n          r < i.length;\n          r++\n        )\n          if (i[r].n === t) {\n            var s = i[r].x;\n            if (!s.r) return !1;\n            var a = s.r.split("/");\n            return S(a[a.length - 1]);\n          }\n        return;\n      }\n      e = e.componentParent || e.parent;\n    }\n  }\n  function ct(t, e) {\n    void 0 === e && (e = 0);\n    for (var n = new Array(e); e--; ) n[e] = "_" + e;\n    return new Function(\n      [],\n      "return function (" + n.join(",") + "){return(" + t + ");};"\n    )();\n  }\n  function ft(t, e) {\n    return Lo[t] ? Lo[t] : (Lo[t] = Be(t, e));\n  }\n  function dt(t) {\n    if (t) {\n      var e = t.e;\n      e &&\n        Za(e).forEach(function (t) {\n          Lo[t] || (Lo[t] = e[t]);\n        });\n    }\n  }\n  function pt(t) {\n    if (!t.matchString("=")) return null;\n    var e = t.pos;\n    t.sp();\n    var n = t.matchPattern(Du);\n    if (!n) return (t.pos = e), null;\n    if (!t.matchPattern(Fu)) return null;\n    var i = t.matchPattern(Du);\n    return i\n      ? (t.sp(), t.matchString("=") ? [n, i] : ((t.pos = e), null))\n      : ((t.pos = e), null);\n  }\n  function mt(t) {\n    var e;\n    return (e = t.matchPattern(zu)) ? { t: mu, v: e } : null;\n  }\n  function vt(t) {\n    return t.replace(Uu, "\\\\$&");\n  }\n  function gt(t, e) {\n    return t.search(\n      $u[e.join()] || ($u[e.join()] = new RegExp(e.map(vt).join("|")))\n    );\n  }\n  function yt(t) {\n    return t.replace(Gu, function (t, e) {\n      var n;\n      return (\n        (n =\n          "#" !== e[0]\n            ? Zu[e]\n            : "x" === e[1]\n            ? parseInt(e.substring(2), 16)\n            : parseInt(e.substring(1), 10)),\n        n ? Yu(wt(n)) : t\n      );\n    });\n  }\n  function bt(t) {\n    return t.replace(th, "&amp;").replace(Ju, "&lt;").replace(Xu, "&gt;");\n  }\n  function wt(t) {\n    return t\n      ? 10 === t\n        ? 32\n        : 128 > t\n        ? t\n        : 159 >= t\n        ? Wu[t - 128]\n        : 55296 > t\n        ? t\n        : 57343 >= t\n        ? eh\n        : 65535 >= t\n        ? t\n        : Qu\n        ? t >= 65536 && 131071 >= t\n          ? t\n          : t >= 131072 && 196607 >= t\n          ? t\n          : eh\n        : eh\n      : eh;\n  }\n  function xt(t) {\n    var e;\n    return (e = t.matchPattern(rh)) ? { t: lu, v: e } : null;\n  }\n  function kt(t) {\n    var e = t.remaining();\n    return "true" === e.substr(0, 4)\n      ? ((t.pos += 4), { t: pu, v: "true" })\n      : "false" === e.substr(0, 5)\n      ? ((t.pos += 5), { t: pu, v: "false" })\n      : null;\n  }\n  function _t(t) {\n    return function (e) {\n      for (var n, i = \'"\', r = !1; !r; )\n        (n = e.matchPattern(sh) || e.matchPattern(ah) || e.matchString(t)),\n          n\n            ? (i += \'"\' === n ? \'\\\\"\' : "\\\\\'" === n ? "\'" : n)\n            : ((n = e.matchPattern(oh)),\n              n\n                ? (i +=\n                    "\\\\u" + ("000" + n.charCodeAt(1).toString(16)).slice(-4))\n                : (r = !0));\n      return (i += \'"\'), JSON.parse(i);\n    };\n  }\n  function Et(t) {\n    var e = t.pos,\n      n = t.matchString("\'") || t.matchString(\'"\');\n    if (n) {\n      var i = ("\'" === n ? uh : hh)(t);\n      return t.matchString(n) ? { t: cu, v: i } : ((t.pos = e), null);\n    }\n    return null;\n  }\n  function St(t) {\n    return JSON.parse(\'"\' + t.replace(ch, At) + \'"\');\n  }\n  function At(t) {\n    switch (t) {\n      case "\\n":\n        return "\\\\n";\n      case "\\r":\n        return "\\\\r";\n      case "\t":\n        return "\\\\t";\n      case "\\b":\n        return "\\\\b";\n      case "\\f":\n        return "\\\\f";\n    }\n  }\n  function Ct(t) {\n    if (!t.matchString("`")) return null;\n    for (var e, n = "", i = !1, r = []; !i; )\n      if (\n        (e =\n          t.matchPattern(lh) ||\n          t.matchPattern(ah) ||\n          t.matchString("$") ||\n          t.matchString(\'"\'))\n      )\n        if (\'"\' === e) n += \'\\\\"\';\n        else if ("\\\\`" === e) n += "`";\n        else if ("$" === e)\n          if (t.matchString("{")) {\n            r.push({ t: cu, v: St(n) }), (n = ""), t.sp();\n            var s = Dt(t);\n            s || t.error("Expected valid expression"),\n              r.push({ t: ku, x: s }),\n              t.sp(),\n              t.matchString("}") ||\n                t.error("Expected closing \'}\' after interpolated expression");\n          } else n += "$";\n        else n += e;\n      else\n        (e = t.matchPattern(oh)),\n          e\n            ? (n += "\\\\u" + ("000" + e.charCodeAt(1).toString(16)).slice(-4))\n            : (i = !0);\n    if (\n      (n.length && r.push({ t: cu, v: St(n) }),\n      t.matchString("`") || t.error("Expected closing \'`\'"),\n      r.length)\n    ) {\n      if (1 === r.length) return r[0];\n      for (var a, o = r.pop(); (a = r.pop()); )\n        o = { t: Eu, s: "+", o: [a, o] };\n      return { t: ku, x: o };\n    }\n    return { t: cu, v: "" };\n  }\n  function Ot(t) {\n    var e;\n    return (e = Et(t))\n      ? vh.test(e.v)\n        ? e.v\n        : \'"\' + e.v.replace(/"/g, \'\\\\"\') + \'"\'\n      : (e = xt(t))\n      ? e.v\n      : (e = t.matchPattern(fh))\n      ? e\n      : null;\n  }\n  function Nt(t) {\n    var e,\n      n = t.pos;\n    t.sp();\n    var i = "\'" !== t.nextChar() && \'"\' !== t.nextChar();\n    i && (e = t.matchPattern(dh));\n    var r = e ? Dt(t) : Ot(t);\n    if (null === r) return (t.pos = n), null;\n    if ((t.sp(), i && ("," === t.nextChar() || "}" === t.nextChar()))) {\n      e ||\n        fh.test(r) ||\n        t.error("Expected a valid reference, but found \'" + r + "\' instead.");\n      var s = { t: gu, k: r, v: { t: yu, n: r } };\n      return e && (s.p = !0), s;\n    }\n    if (!t.matchString(":")) return (t.pos = n), null;\n    t.sp();\n    var a = Dt(t);\n    return null === a ? ((t.pos = n), null) : { t: gu, k: r, v: a };\n  }\n  function jt(t) {\n    var e = t.pos,\n      n = Nt(t);\n    if (null === n) return null;\n    var i = [n];\n    if (t.matchString(",")) {\n      var r = jt(t);\n      return r ? i.concat(r) : ((t.pos = e), null);\n    }\n    return i;\n  }\n  function Tt(t) {\n    var e = t.pos;\n    if ((t.sp(), !t.matchString("{"))) return (t.pos = e), null;\n    var n = jt(t);\n    return t.sp(), t.matchString("}") ? { t: du, m: n } : ((t.pos = e), null);\n  }\n  function Vt(t) {\n    var e = t.pos;\n    if ((t.sp(), !t.matchString("["))) return (t.pos = e), null;\n    var n = Ft(t, !0);\n    return t.matchString("]") ? { t: fu, m: n } : ((t.pos = e), null);\n  }\n  function Pt(t) {\n    return xt(t) || kt(t) || Et(t) || Ct(t) || Tt(t) || Vt(t) || mt(t);\n  }\n  function Mt(t) {\n    var e,\n      n,\n      i,\n      r,\n      s,\n      a = t.pos;\n    (e = t.matchPattern(bh) || ""),\n      (n = (!e && t.relaxedNames && t.matchPattern(mh)) || t.matchPattern(ph));\n    var o = e.length + ((n && n.length) || 0);\n    if (\n      ("@." === e && ((e = "@"), (n = n ? "this." + n : "this")),\n      !n && e && ((n = e), (e = "")),\n      !n)\n    )\n      return null;\n    if ("@" === e)\n      if (wh.test(n))\n        if ((n.indexOf("event") && n.indexOf("node")) || t.inEvent) {\n          if (!n.indexOf("context"))\n            return (\n              (t.pos = t.pos - (n.length - 7)),\n              { t: ku, x: { t: yu, n: "@context" } }\n            );\n        } else\n          t.error(\n            "@event and @node are only valid references within an event directive"\n          );\n      else t.error("Unrecognized special reference @" + n);\n    if (!e && !t.relaxedNames && yh.test(n)) return (t.pos = a), null;\n    if (!e && gh.test(n))\n      return (i = gh.exec(n)[0]), (t.pos = a + i.length), { t: vu, v: i };\n    if (((r = (e || "") + E(n)), t.matchString("(")))\n      if (((s = r.lastIndexOf(".")), -1 !== s && "]" !== n[n.length - 1]))\n        if (0 === s) (r = "."), (t.pos = a);\n        else {\n          var u = r.length;\n          (r = r.substr(0, s)), (t.pos = a + (o - (u - s)));\n        }\n      else t.pos -= 1;\n    return { t: yu, n: r.replace(/^this\\./, "./").replace(/^this$/, ".") };\n  }\n  function It(t) {\n    if (!t.matchString("(")) return null;\n    t.sp();\n    var e = Dt(t);\n    return (\n      e || t.error(nh),\n      t.sp(),\n      t.matchString(")") || t.error(ih),\n      { t: ku, x: e }\n    );\n  }\n  function Rt(t) {\n    return Pt(t) || Mt(t) || It(t);\n  }\n  function Bt(t) {\n    if ((t.strictRefinement || t.sp(), t.matchString("."))) {\n      t.sp();\n      var e = t.matchPattern(fh);\n      if (e) return { t: bu, n: e };\n      t.error("Expected a property name");\n    }\n    if (t.matchString("[")) {\n      t.sp();\n      var n = Dt(t);\n      return (\n        n || t.error(nh),\n        t.sp(),\n        t.matchString("]") || t.error("Expected \']\'"),\n        { t: bu, x: n }\n      );\n    }\n    return null;\n  }\n  function Kt(t) {\n    var e = Rt(t);\n    if (!e) return null;\n    for (; e; ) {\n      var n = Bt(t);\n      if (n) e = { t: wu, x: e, r: n };\n      else {\n        if (!t.matchString("(")) break;\n        t.sp();\n        var i = Ft(t, !0);\n        t.sp(),\n          t.matchString(")") || t.error(ih),\n          (e = { t: Su, x: e }),\n          i && (e.o = i);\n      }\n    }\n    return e;\n  }\n  function Lt(t) {\n    var e = Sh(t);\n    if (!e) return null;\n    var n = t.pos;\n    if ((t.sp(), !t.matchString("?"))) return (t.pos = n), e;\n    t.sp();\n    var i = Dt(t);\n    i || t.error(nh),\n      t.sp(),\n      t.matchString(":") || t.error(\'Expected ":"\'),\n      t.sp();\n    var r = Dt(t);\n    return r || t.error(nh), { t: _u, o: [e, i, r] };\n  }\n  function Dt(t) {\n    if (t.allowExpressions === !1) {\n      var e = Mt(t);\n      return t.sp(), e;\n    }\n    return Lt(t);\n  }\n  function Ft(t, e) {\n    var n,\n      i = [],\n      r = t.pos;\n    do {\n      t.sp(), e && (n = t.matchPattern(dh));\n      var s = Dt(t);\n      if (null === s && i.length) t.error(nh);\n      else if (null === s) return (t.pos = r), null;\n      n && (s.p = !0), i.push(s), t.sp();\n    } while (t.matchString(","));\n    return i;\n  }\n  function zt(t, e) {\n    var n = t.pos,\n      i = Dt(t);\n    if (!i) {\n      var r = t.matchPattern(/^(\\w+)/);\n      return r ? { t: yu, n: r } : null;\n    }\n    for (var s = 0; s < e.length; s += 1)\n      if (t.remaining().substr(0, e[s].length) === e[s]) return i;\n    return (t.pos = n), Mt(t);\n  }\n  function Ut(t) {\n    function e(t) {\n      for (var e = [], n = a - 1; n >= 0; n--) e.push("x$" + n);\n      return e.length\n        ? "(function(){var " + e.join(",") + ";return(" + t + ");})()"\n        : t;\n    }\n    function n(t) {\n      if (h(t)) return t;\n      switch (t.t) {\n        case pu:\n        case vu:\n        case lu:\n        case mu:\n          return t.v;\n        case cu:\n          return JSON.stringify(String(t.v));\n        case fu:\n          return t.m && $t(t.m)\n            ? "[].concat(" + r(t.m, "[", "]", n) + ")"\n            : "[" + (t.m ? t.m.map(n).join(",") : "") + "]";\n        case du:\n          return t.m && $t(t.m)\n            ? "Object.assign({}," + r(t.m, "{", "}", i) + ")"\n            : "{" +\n                (t.m\n                  ? t.m\n                      .map(function (t) {\n                        return t.k + ":" + n(t.v);\n                      })\n                      .join(",")\n                  : "") +\n                "}";\n        case xu:\n          return ("typeof" === t.s ? "typeof " : t.s) + n(t.o);\n        case Eu:\n          return (\n            n(t.o[0]) +\n            ("in" === t.s.substr(0, 2) ? " " + t.s + " " : t.s) +\n            n(t.o[1])\n          );\n        case Su:\n          if (t.o && $t(t.o)) {\n            var e = a++;\n            return (\n              "(x$" +\n              e +\n              "=" +\n              n(t.x) +\n              ").apply(x$" +\n              e +\n              "," +\n              n({ t: fu, m: t.o }) +\n              ")"\n            );\n          }\n          return n(t.x) + "(" + (t.o ? t.o.map(n).join(",") : "") + ")";\n        case ku:\n          return "(" + n(t.x) + ")";\n        case wu:\n          return n(t.x) + n(t.r);\n        case bu:\n          return t.n ? "." + t.n : "[" + n(t.x) + "]";\n        case _u:\n          return n(t.o[0]) + "?" + n(t.o[1]) + ":" + n(t.o[2]);\n        case yu:\n          return "_" + s.indexOf(t.n);\n        default:\n          throw new Error("Expected legal JavaScript");\n      }\n    }\n    function i(t) {\n      return t.p ? n(t.k) : t.k + ":" + n(t.v);\n    }\n    function r(t, e, n, i) {\n      var r = t.reduce(\n        function (t, r) {\n          return (\n            r.p\n              ? (t.str +=\n                  "" + (t.open ? n + "," : t.str.length ? "," : "") + i(r))\n              : (t.str +=\n                  "" + (t.str.length ? (t.open ? "," : "," + e) : e) + i(r)),\n            (t.open = !r.p),\n            t\n          );\n        },\n        { open: !1, str: "" }\n      );\n      return r.open && (r.str += n), r.str;\n    }\n    var s,\n      a = 0;\n    qt(t, (s = []));\n    var o = n(t);\n    return { r: s, s: e(o) };\n  }\n  function $t(t) {\n    for (var e = 0; e < t.length; e++) if (t[e].p) return !0;\n    return !1;\n  }\n  function qt(t, e) {\n    t.t === yu && h(t.n) && (~e.indexOf(t.n) || e.unshift(t.n));\n    var n = t.o || t.m;\n    if (n)\n      if (s(n)) qt(n, e);\n      else for (var i = n.length; i--; ) qt(n[i], e);\n    t.k && t.t === gu && !h(t.k) && qt(t.k, e),\n      t.x && qt(t.x, e),\n      t.r && qt(t.r, e),\n      t.v && qt(t.v, e);\n  }\n  function Ht(t, e) {\n    var n;\n    if (t) {\n      for (; t.t === ku && t.x; ) t = t.x;\n      if (t.t === yu) {\n        var i = t.n;\n        ~i.indexOf("@context") ? (e.x = Ut(t)) : (e.r = t.n);\n      } else (n = Zt(t)) ? (e.rx = n) : (e.x = Ut(t));\n      return e;\n    }\n  }\n  function Zt(t) {\n    for (var e, n = []; t.t === wu && t.r.t === bu; )\n      (e = t.r),\n        e.x\n          ? e.x.t === yu\n            ? n.unshift(e.x)\n            : n.unshift(Ut(e.x))\n          : n.unshift(e.n),\n        (t = t.x);\n    return t.t !== yu ? null : { r: t.n, m: n };\n  }\n  function Wt(t) {\n    for (var e = [], n = 0, i = 0; i < t.length; i++)\n      "-" === t[i] &&\n        "\\\\" !== t[i - 1] &&\n        (e.push(t.substring(n, i).replace(Bh, "")), (n = i + 1));\n    return e.push(t.substring(n).replace(Bh, "")), e;\n  }\n  function Gt(t) {\n    var e, n, i, r;\n    if ((t.sp(), (e = t.matchPattern(Ah)), !e)) return null;\n    for (i = e.length, n = 0; n < t.tags.length; n++)\n      ~(r = e.indexOf(t.tags[n].open)) && i > r && (i = r);\n    return i < e.length && ((t.pos -= e.length - i), (e = e.substr(0, i)), !e)\n      ? null\n      : { n: e };\n  }\n  function Qt(t) {\n    var e = t.pos;\n    if (\n      (/[=\\/>\\s]/.test(t.nextChar()) ||\n        t.error("Expected `=`, `/`, `>` or whitespace"),\n      t.sp(),\n      !t.matchString("="))\n    )\n      return (t.pos = e), null;\n    t.sp();\n    var n = t.pos,\n      i = t.sectionDepth,\n      r = Xt(t, "\'") || Xt(t, \'"\') || Jt(t);\n    return (\n      null === r && t.error("Expected valid attribute value"),\n      t.sectionDepth !== i &&\n        ((t.pos = n),\n        t.error(\n          "An attribute value must contain as many opening section tags as closing section tags"\n        )),\n      r.length ? (1 === r.length && h(r[0]) ? yt(r[0]) : r) : ""\n    );\n  }\n  function Yt(t) {\n    var e,\n      n,\n      i = t.pos;\n    if (((e = t.matchPattern(Mh)), !e)) return null;\n    var r = e,\n      s = t.tags.map(function (t) {\n        return t.open;\n      });\n    return (\n      -1 !== (n = gt(r, s)) && ((e = e.substr(0, n)), (t.pos = i + e.length)), e\n    );\n  }\n  function Jt(t) {\n    t.inAttribute = !0;\n    for (var e = [], n = re(t) || Yt(t); n; ) e.push(n), (n = re(t) || Yt(t));\n    return e.length ? ((t.inAttribute = !1), e) : null;\n  }\n  function Xt(t, e) {\n    var n = t.pos;\n    if (!t.matchString(e)) return null;\n    t.inAttribute = e;\n    for (var i = [], r = re(t) || te(t, e); null !== r; )\n      i.push(r), (r = re(t) || te(t, e));\n    return t.matchString(e) ? ((t.inAttribute = !1), i) : ((t.pos = n), null);\n  }\n  function te(t, e) {\n    var n = t.remaining(),\n      i = t.tags.map(function (t) {\n        return t.open;\n      });\n    i.push(e);\n    var r = gt(n, i);\n    return (\n      -1 === r && t.error("Quoted attribute value must have a closing quote"),\n      r ? ((t.pos += r), n.substr(0, r)) : null\n    );\n  }\n  function ee(t) {\n    var e,\n      n,\n      i = Gt(t, !1);\n    if (!i) return null;\n    if ((n = Ph[i.n]))\n      (i.t = n.t),\n        n.v && (i.v = n.v),\n        delete i.n,\n        t.sp(),\n        "=" === t.nextChar() && (i.f = Qt(t));\n    else if ((e = jh.exec(i.n))) (i.n = e[1]), (i.t = Ru), ie(t, i);\n    else if ((e = Th.exec(i.n)))\n      (i.n = e[1]),\n        (i.t = Bu),\n        ie(t, i),\n        (i.v = "in-out" === e[2] ? "t0" : "in" === e[2] ? "t1" : "t2");\n    else if ((e = Oh.exec(i.n)))\n      (i.n = Wt(e[1])),\n        (i.t = Iu),\n        t.matchString("(") &&\n          ((i.a = Ut({ t: fu, m: Ft(t) })),\n          t.matchString(")") || t.error("Expected closing \')\'")),\n        (t.inEvent = !0),\n        ne(t, i)\n          ? Nh.test(i.f) &&\n            ((t.pos -= i.f.length),\n            t.error(\n              "Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, complete, detach, insert, destruct, attachchild, detachchild)"\n            ))\n          : ie(t, i, !0),\n        (t.inEvent = !1);\n    else if ((e = Vh.exec(i.n))) {\n      var r = "bind" === e[2];\n      (i.n = r ? e[3] : e[1]),\n        (i.t = nu),\n        ie(t, i, !1, !0),\n        !i.f && r && (i.f = [{ t: Ho, r: e[3] }]);\n    } else {\n      t.sp();\n      var s = "=" === t.nextChar() ? Qt(t) : null;\n      if (\n        ((i.f = null != s ? s : i.f), t.sanitizeEventAttributes && Ch.test(i.n))\n      )\n        return { exclude: !0 };\n      (i.f = i.f || ("" === i.f ? "" : 0)), (i.t = nu);\n    }\n    return i;\n  }\n  function ne(t, e) {\n    var n = t.pos;\n    t.matchString("=") || t.error("Missing required directive arguments");\n    var i = t.matchString("\'") || t.matchString(\'"\');\n    t.sp();\n    var r = t.matchPattern(Ih);\n    if (void 0 !== r)\n      if (i) {\n        if ((t.sp(), t.matchString(i))) return (e.f = r) || !0;\n        t.pos = n;\n      } else {\n        if (t.matchPattern(Rh)) return (e.f = r) || !0;\n        t.pos = n;\n      }\n    else t.pos = n;\n  }\n  function ie(t, e, n, i) {\n    if (\n      (void 0 === n && (n = !1),\n      void 0 === i && (i = !1),\n      t.sp(),\n      !t.matchString("="))\n    )\n      return void (n && t.error("Missing required directive arguments"));\n    t.sp();\n    var r = t.matchString(\'"\') || t.matchString("\'"),\n      s = t.spreadArgs;\n    (t.spreadArgs = !0), (t.inUnquotedAttribute = !r);\n    var a = i ? zt(t, [r || " ", "/", ">"]) : { m: Ft(t), t: fu };\n    if (\n      ((t.inUnquotedAttribute = !1),\n      (t.spreadArgs = s),\n      r &&\n        (t.sp(),\n        t.matchString(r) !== r &&\n          t.error("Expected matching quote \'" + r + "\'")),\n      i)\n    ) {\n      var o = { t: Ho };\n      Ht(a, o), (e.f = [o]);\n    } else e.f = Ut(a);\n  }\n  function re(t) {\n    var e, n;\n    if (t.interpolate[t.inside] === !1) return null;\n    for (n = 0; n < t.tags.length; n += 1) if ((e = se(t, t.tags[n]))) return e;\n    return t.inTag && !t.inAttribute && (e = ee(t)) ? (t.sp(), e) : void 0;\n  }\n  function se(t, e) {\n    var n,\n      i,\n      r,\n      s = t.pos;\n    if (t.matchString("\\\\" + e.open)) {\n      if (0 === s || "\\\\" !== t.str[s - 1]) return e.open;\n    } else if (!t.matchString(e.open)) return null;\n    if ((n = pt(t)))\n      return t.matchString(e.close)\n        ? ((e.open = n[0]), (e.close = n[1]), t.sortMustacheTags(), Kh)\n        : null;\n    if ((t.sp(), t.matchString("/"))) {\n      t.pos -= 1;\n      var a = t.pos;\n      if (mt(t)) t.pos = a;\n      else {\n        if (((t.pos = a - e.close.length), t.inAttribute))\n          return (t.pos = s), null;\n        t.error("Attempted to close a section that wasn\'t open");\n      }\n    }\n    for (r = 0; r < e.readers.length; r += 1)\n      if (((i = e.readers[r]), (n = i(t, e))))\n        return (\n          e.isStatic && (n.s = 1),\n          t.includeLinePositions && (n.q = t.getLinePos(s)),\n          n\n        );\n    return (t.pos = s), null;\n  }\n  function ae(t, e) {\n    var n = Dt(t);\n    if (!n) return null;\n    t.matchString(e.close) ||\n      t.error("Expected closing delimiter \'" + e.close + "\'");\n    var i = { t: Zo };\n    return Ht(n, i), i;\n  }\n  function oe(t, e) {\n    if (!t.matchString("&")) return null;\n    t.sp();\n    var n = Dt(t);\n    if (!n) return null;\n    t.matchString(e.close) ||\n      t.error("Expected closing delimiter \'" + e.close + "\'");\n    var i = { t: Zo };\n    return Ht(n, i), i;\n  }\n  function ue(t) {\n    var e,\n      n = [],\n      i = t.pos;\n    if ((t.sp(), (e = he(t)))) {\n      for (e.x = Ht(e.x, {}), n.push(e), t.sp(); t.matchString(","); )\n        (e = he(t)),\n          e || t.error("Expected another alias."),\n          (e.x = Ht(e.x, {})),\n          n.push(e),\n          t.sp();\n      return n;\n    }\n    return (t.pos = i), null;\n  }\n  function he(t) {\n    var e = t.pos;\n    t.sp();\n    var n = Dt(t, []);\n    if (!n) return (t.pos = e), null;\n    t.sp(), t.matchPattern(Dh), t.sp();\n    var i = t.matchPattern(Lh);\n    return i ? { n: i, x: n } : ((t.pos = e), null);\n  }\n  function le(t, e) {\n    var n,\n      i = t.matchString(">") || t.matchString("yield"),\n      r = { t: ">" === i ? Jo : su };\n    if (!i) return null;\n    if ((t.sp(), ">" === i || !(n = t.matchString("with")))) {\n      t.relaxedNames = t.strictRefinement = !0;\n      var s = Dt(t);\n      if (((t.relaxedNames = t.strictRefinement = !1), !s && ">" === i))\n        return null;\n      s && (Ht(s, r), t.sp(), ">" !== i && (n = t.matchString("with")));\n    }\n    if ((t.sp(), n || ">" === i)) {\n      if (((n = ue(t)), n && n.length)) r.z = n;\n      else {\n        var a = Dt(t);\n        a && ((r.c = {}), Ht(a, r.c)),\n          t.matchString(",") && ((n = ue(t)), n && n.length && (r.z = n));\n      }\n      ">" === i ||\n        r.c ||\n        r.z ||\n        t.error("Expected a context or one or more aliases");\n    }\n    return (\n      t.sp(),\n      t.matchString(e.close) ||\n        t.error("Expected closing delimiter \'" + e.close + "\'"),\n      r\n    );\n  }\n  function ce(t, e) {\n    if (!t.matchString("!")) return null;\n    var n = t.remaining().indexOf(e.close);\n    return -1 !== n ? ((t.pos += n + e.close.length), { t: Xo }) : void 0;\n  }\n  function fe(t, e) {\n    var n,\n      i,\n      r = t.pos;\n    try {\n      n = zt(t, [e.close]);\n    } catch (s) {\n      i = s;\n    }\n    if (!n) {\n      if ("!" === t.str.charAt(r)) return (t.pos = r), null;\n      if (i) throw i;\n    }\n    if (\n      !t.matchString(e.close) &&\n      (t.error("Expected closing delimiter \'" + e.close + "\' after reference"),\n      !n)\n    ) {\n      if ("!" === t.nextChar()) return null;\n      t.error("Expected expression or legal reference");\n    }\n    var a = { t: Ho };\n    return Ht(n, a), a;\n  }\n  function de(t, e) {\n    var n = t.pos;\n    if (!t.matchString(e.open)) return null;\n    if ((t.sp(), !t.matchString("/"))) return (t.pos = n), null;\n    t.sp();\n    var i = t.remaining(),\n      r = i.indexOf(e.close);\n    if (-1 !== r) {\n      var s = { t: Qo, r: i.substr(0, r).split(" ")[0] };\n      return (\n        (t.pos += r),\n        t.matchString(e.close) ||\n          t.error("Expected closing delimiter \'" + e.close + "\'"),\n        s\n      );\n    }\n    return (t.pos = n), null;\n  }\n  function pe(t, e, n) {\n    var i = t.pos;\n    if (!t.matchString(e.open)) return null;\n    if (!t.matchPattern(Fh[n])) return (t.pos = i), null;\n    var r = { t: zh[n] };\n    if ("elseif" === n) r.x = Dt(t);\n    else if ("catch" === n || "then" === n) {\n      var s = t.matchPattern(fh);\n      s && (r.n = s);\n    }\n    return (\n      t.matchString(e.close) ||\n        t.error("Expected closing delimiter \'" + e.close + "\'"),\n      r\n    );\n  }\n  function me(t, e) {\n    var n,\n      i,\n      r,\n      s,\n      a,\n      o,\n      u,\n      h,\n      l,\n      c,\n      f,\n      d,\n      p,\n      m = !1,\n      v = t.pos;\n    if (t.matchString("^")) {\n      if (t.matchString("^/")) return (t.pos = v), null;\n      i = { t: Wo, f: [], n: Cu };\n    } else {\n      if (!t.matchString("#")) return null;\n      (i = { t: Wo, f: [] }),\n        t.matchString("partial") &&\n          ((t.pos = v - t.standardDelimiters[0].length),\n          t.error(\n            "Partial definitions can only be at the top level of the template, or immediately inside components"\n          )),\n        (o = t.matchString("await"))\n          ? ((c = o), (i.t = hu))\n          : (o = t.matchPattern(Hh)) && ((c = o), (i.n = Uh[o]));\n    }\n    if ((t.sp(), "with" === o)) {\n      var g = ue(t);\n      g && ((m = !0), (i.z = g), (i.t = uu));\n    } else if ("each" === o) {\n      var y = he(t);\n      y && ((i.z = [{ n: y.n, x: { r: "." } }]), (n = y.x));\n    }\n    if (!m) {\n      if (\n        (n || (n = Dt(t)),\n        n || t.error("Expected expression"),\n        "each" === o && t.matchString(","))\n      ) {\n        var b = ue(t);\n        b && (i.z && b.unshift(i.z[0]), (i.z = b));\n      }\n      if (("each" !== o && o) || !(l = t.matchPattern($h)))\n        "await" === o &&\n          t.matchString("then") &&\n          (t.sp(), (f = !0), (p = t.matchPattern(fh)), p || (p = !0));\n      else {\n        var w;\n        (w = t.matchPattern(qh)) ? (i.i = l + "," + w) : (i.i = l);\n      }\n      !o && n.n && (c = n.n);\n    }\n    t.sp(),\n      t.matchString("-") && (i.w = 1),\n      t.matchString(e.close) ||\n        t.error("Expected closing delimiter \'" + e.close + "\'"),\n      (t.sectionDepth += 1),\n      (s = i.f);\n    var x;\n    do\n      if (((x = t.pos), (r = de(t, e))))\n        c &&\n          r.r !== c &&\n          (o\n            ? ((t.pos = x), t.error("Expected " + e.open + "/" + c + e.close))\n            : r.r &&\n              t.warn(\n                "Expected " +\n                  e.open +\n                  "/" +\n                  c +\n                  e.close +\n                  " but found " +\n                  e.open +\n                  "/" +\n                  r.r +\n                  e.close\n              )),\n          (t.sectionDepth -= 1),\n          (h = !0);\n      else if (\n        !m &&\n        ((r = pe(t, e, "elseif")) ||\n          (r = pe(t, e, "else")) ||\n          ("await" === o &&\n            ((r = pe(t, e, "then")) || (r = pe(t, e, "catch")))))\n      ) {\n        if (\n          (i.n === Cu && t.error("{{else}} not allowed in {{#unless}}"),\n          a &&\n            (r.t === Tu\n              ? t.error(\n                  "there can only be one {{else}} block, at the end of a section"\n                )\n              : r.t === Vu && t.error("illegal {{elseif...}} after {{else}}")),\n          !u && (p || !f) && !d)\n        )\n          if ("await" === o) {\n            var k = { f: s };\n            (i.f = [k]), p ? ((k.t = Pu), p !== !0 && (k.n = p)) : (k.t = Wo);\n          } else u = [];\n        var _ = { t: Wo, f: (s = []) };\n        r.t === Tu\n          ? ("await" === o\n              ? (i.f.push(_), (_.t = Tu))\n              : ((_.n = Cu), u.push(_)),\n            (a = !0))\n          : r.t === Vu\n          ? ((_.n = Au), Ht(r.x, _), u.push(_))\n          : r.t === Pu\n          ? (a &&\n              t.error("{{then}} block must appear before any {{else}} block"),\n            d &&\n              t.error("{{then}} block must appear before any {{catch}} block"),\n            f && t.error("there can only be one {{then}} block per {{#await}}"),\n            (_.t = Pu),\n            (f = !0),\n            r.n && (_.n = r.n),\n            i.f.push(_))\n          : r.t === Mu &&\n            (a &&\n              t.error("{{catch}} block must appear before any {{else}} block"),\n            d &&\n              t.error("there can only be one {{catch}} block per {{#await}}"),\n            (_.t = Mu),\n            (d = !0),\n            (_.n = r.n),\n            i.f.push(_));\n      } else {\n        if (((r = t.read(vl)), !r)) break;\n        s.push(r);\n      }\n    while (!h);\n    if (\n      (u && (i.l = u), m || Ht(n, i), "await" === o && (p || !f) && !d && !a)\n    ) {\n      var E = { f: i.f };\n      (i.f = [E]), p ? ((E.t = Pu), p !== !0 && (E.n = p)) : (E.t = Wo);\n    }\n    return i.f.length || delete i.f, i;\n  }\n  function ve(t) {\n    var e = t.pos;\n    if (t.textOnlyMode || !t.matchString(Zh)) return null;\n    var n = t.remaining(),\n      i = n.indexOf(Wh);\n    -1 === i &&\n      t.error("Illegal HTML - expected closing comment sequence (\'--\x3e\')");\n    var r = n.substr(0, i);\n    t.pos += i + 3;\n    var s = { t: Xo, c: r };\n    return t.includeLinePositions && (s.q = t.getLinePos(e)), s;\n  }\n  function ge(t, e) {\n    var n, i, r, s, a;\n    for (n = 1; n < t.length; n += 1)\n      (i = t[n]),\n        (r = t[n - 1]),\n        (s = t[n - 2]),\n        h(i) &&\n          ye(r) &&\n          h(s) &&\n          Qh.test(s) &&\n          Gh.test(i) &&\n          ((t[n - 2] = s.replace(Qh, "\\n")), (t[n] = i.replace(Gh, ""))),\n        e ||\n          (be(i) &&\n            h(r) &&\n            Qh.test(r) &&\n            h(i.f[0]) &&\n            Gh.test(i.f[0]) &&\n            ((t[n - 1] = r.replace(Qh, "\\n")),\n            (i.f[0] = i.f[0].replace(Gh, ""))),\n          h(i) &&\n            be(r) &&\n            ((a = T(r.f)),\n            h(a) &&\n              Qh.test(a) &&\n              Gh.test(i) &&\n              ((r.f[r.f.length - 1] = a.replace(Qh, "\\n")),\n              (t[n] = i.replace(Gh, "")))));\n    return t;\n  }\n  function ye(t) {\n    return t.t === Xo || t.t === tu;\n  }\n  function be(t) {\n    return (t.t === Wo || t.t === Go) && t.f;\n  }\n  function we(t, e, n) {\n    var i;\n    e &&\n      ((i = t[0]),\n      h(i) && ((i = i.replace(e, "")), i ? (t[0] = i) : t.shift())),\n      n &&\n        ((i = T(t)),\n        h(i) && ((i = i.replace(n, "")), i ? (t[t.length - 1] = i) : t.pop()));\n  }\n  function xe(t, e, n, i, r, s, a) {\n    if (!h(t)) {\n      var o, u, l, c, f, d, p;\n      for (ge(t, a), o = t.length; o--; )\n        (u = t[o]),\n          u.exclude ? t.splice(o, 1) : e && u.t === Xo && t.splice(o, 1);\n      for (we(t, i ? Jh : null, r ? Xh : null), o = t.length; o--; ) {\n        if (((u = t[o]), (d = p = !1), u.w)) {\n          var m = t[o - 1],\n            v = !0;\n          if (("string" == typeof m && (t[o - 1] = m.replace(nl, "$1")), u.f)) {\n            "string" == typeof u.f[0] && (u.f[0] = u.f[0].replace(il, ""));\n            var g = u.f.length - 1;\n            "string" == typeof u.f[g] &&\n              (u.f[g] = u.f[g].replace(nl, function (t, e) {\n                return (v = e), e || "";\n              }));\n          }\n          var y = t[o + 1];\n          v && "string" == typeof y && (t[o + 1] = y.replace(il, ""));\n        }\n        if (u.f) {\n          var b = u.t === Yo && (s[u.e.toLowerCase()] || s[u.e]);\n          (f = n || b),\n            !n && b && we(u.f, tl, el),\n            f ||\n              ((l = t[o - 1]),\n              (c = t[o + 1]),\n              (!l || (h(l) && Xh.test(l))) && (d = !0),\n              (!c || (h(c) && Jh.test(c))) && (p = !0)),\n            xe(u.f, e, f, d, p, s);\n        }\n        u.l &&\n          (u.w &&\n            u.l.forEach(function (t) {\n              return (t.w = 1);\n            }),\n          xe(u.l, e, n, d, p, s),\n          u.l.forEach(function (t) {\n            return (t.l = 1);\n          }),\n          u.l.unshift(o + 1, 0),\n          t.splice.apply(t, u.l),\n          delete u.l),\n          u.m && (xe(u.m, e, n, d, p, s), u.m.length < 1 && delete u.m),\n          delete u.w;\n      }\n      for (o = t.length; o--; )\n        h(t[o]) &&\n          (h(t[o + 1]) && ((t[o] = t[o] + t[o + 1]), t.splice(o + 1, 1)),\n          n || (t[o] = t[o].replace(Yh, " ")),\n          "" === t[o] && t.splice(o, 1));\n    }\n  }\n  function ke(t) {\n    var e,\n      n = t.pos;\n    return t.matchString("</")\n      ? (e = t.matchPattern(rl))\n        ? t.inside && e !== t.inside\n          ? ((t.pos = n), null)\n          : { t: iu, e: e }\n        : ((t.pos -= 2), void t.error("Illegal closing tag"))\n      : null;\n  }\n  function _e(t) {\n    return t.replace(/([A-Z])/g, function (t, e) {\n      return "-" + e.toLowerCase();\n    });\n  }\n  function Ee(t) {\n    var e,\n      n,\n      i,\n      r,\n      s,\n      a,\n      o,\n      u,\n      l,\n      c,\n      f,\n      d = t.pos;\n    if (t.inside || t.inAttribute || t.textOnlyMode) return null;\n    if (!t.matchString("<")) return null;\n    if ("/" === t.nextChar()) return null;\n    var p = {};\n    if ((t.includeLinePositions && (p.q = t.getLinePos(d)), t.matchString("!")))\n      return (\n        (p.t = ou),\n        t.matchPattern(/^doctype/i) || t.error("Expected DOCTYPE declaration"),\n        (p.a = t.matchPattern(/^(.+?)>/)),\n        p\n      );\n    if ((f = t.matchString("#")))\n      t.sp(), (p.t = eu), (p.n = t.matchPattern(al));\n    else if (((p.t = Yo), (p.e = t.matchPattern(sl)), !p.e)) return null;\n    for (\n      ol.test(t.nextChar()) || t.error("Illegal tag name"),\n        t.sp(),\n        t.inTag = !0;\n      (e = re(t));\n\n    )\n      e !== !1 && (p.m || (p.m = []), p.m.push(e)), t.sp();\n    if (\n      ((t.inTag = !1),\n      t.sp(),\n      t.matchString("/") && (n = !0),\n      !t.matchString(">"))\n    )\n      return null;\n    var m = (p.e || p.n).toLowerCase(),\n      v = t.preserveWhitespace;\n    if (!n && (f || !Hu[p.e.toLowerCase()])) {\n      f || (t.elementStack.push(m), m in t.interpolate && (t.inside = m)),\n        (i = []),\n        (r = $a(null));\n      do {\n        if (((u = t.pos), (l = t.remaining()), !l)) {\n          if ("script" === t.inside) {\n            o = !0;\n            break;\n          }\n          t.error(\n            "Missing end " +\n              (t.elementStack.length > 1 ? "tags" : "tag") +\n              " (" +\n              t.elementStack\n                .reverse()\n                .map(function (t) {\n                  return "</" + t + ">";\n                })\n                .join("") +\n              ")"\n          );\n        }\n        if (f || Se(m, l))\n          if (!f && (c = ke(t))) {\n            o = !0;\n            var g = c.e.toLowerCase();\n            if (g !== m && ((t.pos = u), !~t.elementStack.indexOf(g))) {\n              var y = "Unexpected closing tag";\n              Hu[g.toLowerCase()] &&\n                (y +=\n                  " (<" +\n                  g +\n                  "> is a void element - it cannot contain children)"),\n                t.error(y);\n            }\n          } else if (f && Ae(t, p.n)) o = !0;\n          else {\n            var b = {\n              open: t.standardDelimiters[0],\n              close: t.standardDelimiters[1],\n            };\n            de(t, b) || Ce(t, b)\n              ? ((o = !0), (t.pos = u))\n              : (a = t.read(gl))\n              ? (r[a.n] &&\n                  ((t.pos = u), t.error("Duplicate partial definition")),\n                xe(a.f, t.stripComments, v, !v, !v, t.whiteSpaceElements),\n                (r[a.n] = a.f),\n                (s = !0))\n              : (a = t.read(vl))\n              ? i.push(a)\n              : (o = !0);\n          }\n        else o = !0;\n      } while (!o);\n      i.length && (p.f = i), s && (p.p = r), t.elementStack.pop();\n    }\n    if (\n      ((t.inside = null),\n      t.sanitizeElements && -1 !== t.sanitizeElements.indexOf(m))\n    )\n      return hl;\n    if (\n      p.m &&\n      "input" !== m &&\n      "select" !== m &&\n      "textarea" !== m &&\n      "option" !== m\n    ) {\n      for (var w, x, k, _, E, S = p.m, A = 0; A < S.length; )\n        (E = S[A]),\n          E.t === nu\n            ? 0 !== E.n.indexOf("class-") || E.f\n              ? 0 === E.n.indexOf("style-") && h(E.f)\n                ? ((x || (x = [])).push(_e(E.n.slice(6)) + ": " + E.f + ";"),\n                  S.splice(A, 1))\n                : "class" === E.n && h(E.f)\n                ? ((w || (w = [])).push(E.f), S.splice(A, 1))\n                : "style" === E.n && h(E.f)\n                ? ((x || (x = [])).push(E.f + (ul.test(E.f) ? "" : ";")),\n                  S.splice(A, 1))\n                : "class" === E.n\n                ? ((k = E), A++)\n                : "style" === E.n\n                ? ((_ = E), A++)\n                : !~E.n.indexOf(":") &&\n                  "value" !== E.n &&\n                  "contenteditable" !== E.n &&\n                  h(E.f)\n                ? ((E.g = 1), A++)\n                : A++\n              : ((w || (w = [])).push(E.n.slice(6)), S.splice(A, 1))\n            : A++;\n      w\n        ? k && h(k.f)\n          ? (k.f += " " + w.join(" "))\n          : S.unshift({ t: nu, n: "class", f: w.join(" "), g: 1 })\n        : k && h(k.f) && (k.g = 1),\n        x\n          ? _ && h(_.f)\n            ? (_.f += "; " + x.join(" "))\n            : S.unshift({ t: nu, n: "style", f: x.join(" "), g: 1 })\n          : _ && h(_.f) && (_.g = 1);\n    }\n    return p;\n  }\n  function Se(t, e) {\n    var n = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec(e),\n      i = ll[t];\n    return n && i ? !~i.indexOf(n[1].toLowerCase()) : !0;\n  }\n  function Ae(t, e) {\n    var n = t.pos;\n    return t.matchString("</")\n      ? (t.matchString("#"),\n        t.sp(),\n        t.matchString(e)\n          ? (t.sp(), t.matchString(">") ? !0 : ((t.pos = n), null))\n          : ((t.pos = n), null))\n      : null;\n  }\n  function Ce(t, e) {\n    var n = t.pos;\n    if (t.matchString(e.open))\n      return t.matchPattern(cl) ? !0 : void (t.pos = n);\n  }\n  function Oe(t) {\n    var e,\n      n,\n      i,\n      r = t.remaining();\n    return (\n      t.textOnlyMode\n        ? ((n = t.tags.map(function (t) {\n            return t.open;\n          })),\n          (n = n.concat(\n            t.tags.map(function (t) {\n              return "\\\\" + t.open;\n            })\n          )),\n          (e = gt(r, n)))\n        : ((i = t.inside ? "</" + t.inside : "<"),\n          t.inside && !t.interpolate[t.inside]\n            ? (e = r.indexOf(i))\n            : ((n = t.tags.map(function (t) {\n                return t.open;\n              })),\n              (n = n.concat(\n                t.tags.map(function (t) {\n                  return "\\\\" + t.open;\n                })\n              )),\n              t.inAttribute === !0\n                ? n.push(\'"\', "\'", "=", "<", ">", "`")\n                : t.inAttribute\n                ? n.push(t.inAttribute)\n                : n.push(i),\n              (e = gt(r, n)))),\n      e\n        ? (-1 === e && (e = r.length),\n          (t.pos += e),\n          (t.inside && "textarea" !== t.inside) || t.textOnlyMode\n            ? r.substr(0, e)\n            : yt(r.substr(0, e)))\n        : null\n    );\n  }\n  function Ne(t) {\n    var e,\n      n,\n      i = t.pos,\n      r = t.standardDelimiters;\n    if (!t.matchString(r[0])) return null;\n    if (!t.matchPattern(fl)) return (t.pos = i), null;\n    var s = t.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\\-\\/]*/);\n    s || t.error("expected legal partial name"),\n      t.sp(),\n      t.matchString(r[1]) ||\n        t.error("Expected closing delimiter \'" + r[1] + "\'");\n    var a = [],\n      o = r[0],\n      u = r[1];\n    do\n      (e = de(t, { open: o, close: u }))\n        ? ("partial" !== e.r && t.error("Expected " + o + "/partial" + u),\n          (n = !0))\n        : ((e = t.read(vl)),\n          e || t.error("Expected " + o + "/partial" + u),\n          a.push(e));\n    while (!n);\n    return { t: au, n: s, f: a };\n  }\n  function je(t) {\n    for (\n      var e = [], n = $a(null), i = !1, r = t.preserveWhitespace;\n      t.pos < t.str.length;\n\n    ) {\n      var s = t.pos,\n        a = void 0,\n        o = void 0;\n      (o = t.read(gl))\n        ? (n[o.n] && ((t.pos = s), t.error("Duplicated partial definition")),\n          xe(o.f, t.stripComments, r, !r, !r, t.whiteSpaceElements),\n          (n[o.n] = o.f),\n          (i = !0))\n        : (a = t.read(vl))\n        ? e.push(a)\n        : t.error("Unexpected template content");\n    }\n    var u = { v: Do, t: e };\n    return i && (u.p = n), u;\n  }\n  function Te(t, e) {\n    Za(t).forEach(function (n) {\n      if (Ve(n, t)) return Pe(t, e);\n      var i = t[n];\n      Me(i) && Te(i, e);\n    });\n  }\n  function Ve(t, e) {\n    return "s" === t && Ga(e.r);\n  }\n  function Pe(t, e) {\n    var n = t.s,\n      i = t.r;\n    e[n] || (e[n] = ct(n, i.length));\n  }\n  function Me(t) {\n    return Ga(t) || s(t);\n  }\n  function Ie(t, e) {\n    return new wl(t, e || {}).result;\n  }\n  function Re(t, e, n) {\n    t || p("Missing Ractive.parse - cannot parse " + e + ". " + n);\n  }\n  function Be(t, e) {\n    return Re(ct, "new expression function", kl), ct(t, e);\n  }\n  function Ke(t, e) {\n    Re(Ie, \'compution string "${str}"\', _l);\n    var n = Ie(t, { expression: !0 });\n    return function () {\n      return n.e.apply(\n        e,\n        n.r.map(function (t) {\n          return e.get(t);\n        })\n      );\n    };\n  }\n  function Le(t, e, n) {\n    var i, r, s, a, l;\n    return (\n      u(n) && ((i = B(n, t)), (s = n.toString()), (a = !0)),\n      h(n) && ((i = Ke(n, t)), (s = n)),\n      o(n) &&\n        (h(n.get)\n          ? ((i = Ke(n.get, t)), (s = n.get))\n          : u(n.get)\n          ? ((i = B(n.get, t)), (s = n.get.toString()), (a = !0))\n          : p("`%s` computation must have a `get()` method", e),\n        u(n.set) && ((r = B(n.set, t)), (l = n.set.toString()))),\n      {\n        getter: i,\n        setter: r,\n        getterString: s,\n        setterString: l,\n        getterUseStack: a,\n      }\n    );\n  }\n  function De(t) {\n    !t.started ||\n      t.outros.length ||\n      t.outroChildren ||\n      (t.outrosComplete ||\n        ((t.outrosComplete = !0),\n        t.parent && t.parent.decrementOutros(t),\n        Fe(t) && t.detachNodes()),\n      t.intros.length ||\n        t.totalChildren ||\n        (u(t.callback) && t.callback(),\n        t.parent &&\n          !t.notifiedTotal &&\n          ((t.notifiedTotal = !0), t.parent.decrementTotal())));\n  }\n  function Fe(t) {\n    return !t || (t.outrosComplete && Fe(t.parent));\n  }\n  function ze(t) {\n    var e = t.detachQueue,\n      n = Ue(t);\n    if (n.length) {\n      var i,\n        r,\n        s = e.length,\n        a = 0,\n        o = (t.detachQueue = []);\n      t: for (; s--; ) {\n        for (i = e[s].node, a = n.length; a--; )\n          if (\n            ((r = n[a].element.node), r === i || r.contains(i) || i.contains(r))\n          ) {\n            o.push(e[s]);\n            continue t;\n          }\n        e[s].detach();\n      }\n    } else t.detachNodes();\n  }\n  function Ue(t, e) {\n    var n = e;\n    if (n) {\n      for (var i = t.children.length; i--; ) n = Ue(t.children[i], n);\n      return t.outros.length && (n = n.concat(t.outros)), n;\n    }\n    n = [];\n    for (var r = t; r.parent; ) r = r.parent;\n    return Ue(r, n);\n  }\n  function $e(t) {\n    t.dispatch();\n  }\n  function qe() {\n    var t = Ol.immediateObservers;\n    (Ol.immediateObservers = []), t.forEach($e);\n    var e,\n      n = Ol.fragments.length;\n    for (t = Ol.fragments, Ol.fragments = []; n--; ) (e = t[n]), e.update();\n    Ol.transitionManager.ready(),\n      (t = Ol.deferredObservers),\n      (Ol.deferredObservers = []),\n      t.forEach($e);\n    var i = Ol.tasks;\n    for (Ol.tasks = [], n = 0; n < i.length; n += 1) i[n]();\n    return Ol.fragments.length ||\n      Ol.immediateObservers.length ||\n      Ol.deferredObservers.length ||\n      Ol.tasks.length\n      ? qe()\n      : void 0;\n  }\n  function He() {\n    Nl.start();\n    var t,\n      e,\n      n = performance.now();\n    for (t = 0; t < jl.length; t += 1)\n      (e = jl[t]), e.tick(n) || jl.splice(t--, 1);\n    Nl.end(), jl.length ? requestAnimationFrame(He) : (Tl = !1);\n  }\n  function Ze(e, n) {\n    var i = {};\n    if (!n) return e;\n    n += ".";\n    for (var r in e) t(e, r) && (i[n + r] = e[r]);\n    return i;\n  }\n  function We(t) {\n    var e;\n    return (\n      Ml[t] ||\n        ((e = t ? t + "." : ""),\n        (Ml[t] = function (n, i) {\n          var r;\n          return h(n)\n            ? ((r = {}), (r[e + n] = i), r)\n            : o(n)\n            ? e\n              ? Ze(n, t)\n              : n\n            : void 0;\n        })),\n      Ml[t]\n    );\n  }\n  function Ge(t) {\n    for (var e = [], n = 0; n < t.length; n++)\n      e[n] = (t.childByKey[n] || {}).value;\n    return e;\n  }\n  function Qe(t) {\n    for (var e = t; e && !e.context && !e.aliases; ) e = e.parent;\n    return e;\n  }\n  function Ye(e, n) {\n    var i = e;\n    if ("." === n) return e.findContext();\n    if ("~" === n[0]) return e.ractive.viewmodel.joinAll(S(n.slice(2)));\n    if ("." === n[0] || "^" === n[0]) {\n      for (var r = e, s = n.split("/"), a = "^^" === s[0]; r && !r.context; )\n        r = Je(r);\n      for (var o = r && r.context; r && "^^" === s[0]; ) {\n        for (\n          s.shift(), r = r.isIteration ? r.parent.parent : Je(r);\n          r && !r.context;\n\n        )\n          r = Je(r);\n        o = r && r.context;\n      }\n      if (!o && a)\n        throw new Error(\n          "Invalid context parent reference (\'" +\n            n +\n            "\'). There is not context at that level."\n        );\n      for (; "." === s[0] || ".." === s[0]; ) {\n        var h = s.shift();\n        ".." === h && (o = o.parent);\n      }\n      return (\n        (n = s.join("/")), "." === n[0] && (n = n.slice(1)), o.joinAll(S(n))\n      );\n    }\n    var l = S(n);\n    if (l.length) {\n      var c = l.shift();\n      if ("@" === c[0]) {\n        if ("@this" === c || "@" === c)\n          return e.ractive.viewmodel.getRactiveModel().joinAll(l);\n        if ("@index" === c || "@key" === c) {\n          l.length && en(c);\n          var f = Xe(e);\n          return f && f["get" + ("i" === c[1] ? "Index" : "Key")]();\n        }\n        if ("@last" === c) {\n          var d = Xe(e);\n          return d && d.parent.getLast();\n        }\n        if ("@global" === c) return Dl.joinAll(l);\n        if ("@shared" === c) return Ll.joinAll(l);\n        if ("@keypath" === c || "@rootpath" === c) {\n          for (\n            var p = "r" === n[1] ? e.ractive.root : null, m = e;\n            m &&\n            (!m.context ||\n              (m.isRoot && m.ractive.component && (p || !m.ractive.isolated)));\n\n          )\n            m = m.isRoot ? m.componentParent : m.parent;\n          return m.getKeypath(p);\n        }\n        if ("@context" === c)\n          return new Kl(e.getContext(), "context").joinAll(l);\n        if ("@local" === c) return e.getContext()._data.joinAll(l);\n        if ("@style" === c) return e.ractive.constructor._cssModel.joinAll(l);\n        if ("@helpers" === c)\n          return e.ractive.viewmodel.getHelpers().joinAll(l);\n        if ("@macro" === c) {\n          var v = tn(e);\n          return v ? new Kl(v, "macro").joinAll(l) : void 0;\n        }\n        throw new Error("Invalid special reference \'" + c + "\'");\n      }\n      if (c && !l.length) {\n        var g = e.ractive.viewmodel.getHelpers();\n        if (g.has(c)) return g.joinKey(c);\n      }\n      var b = Qe(e);\n      b = b && b.context ? b.context : e.findContext();\n      for (var w, x = !1, k = e.ractive.warnAboutAmbiguity, _ = 0; e; ) {\n        if (\n          (e.isIteration &&\n            (c === e.parent.keyRef\n              ? (w = e.getKey())\n              : c === e.parent.indexRef && (w = e.getIndex()),\n            w && l.length && en(c)),\n          !w && e.aliases && t(e.aliases, c) && (w = e.aliases[c]),\n          !w &&\n            e.context &&\n            e.context.has(c) &&\n            ((w = e.context.joinKey(c)),\n            x\n              ? k &&\n                y(\n                  "\'" +\n                    n +\n                    "\' resolved but is ambiguous and will create a mapping to a parent component."\n                )\n              : k && _ && y("\'" + n + "\' resolved but is ambiguous.")),\n          w)\n        )\n          return (\n            x &&\n              (w = i.ractive.viewmodel.createLink(c, w, c, { implicit: !0 })),\n            l.length > 0 && u(w.joinAll) && (w = w.joinAll(l)),\n            w\n          );\n        e.context && !e.aliases && (_ = 1),\n          e.ractive.isolated ||\n          (e.owner && e.owner.containerFragment) ||\n          !(e.componentParent || (!e.parent && e.ractive.component))\n            ? (e = e.parent)\n            : ((e = e.componentParent || e.ractive.component.up), (x = !0));\n      }\n      var E = i.ractive;\n      return E.resolveInstanceMembers && "data" !== c && c in E\n        ? E.viewmodel.getRactiveModel().joinKey(c).joinAll(l)\n        : (k && y("\'" + n + "\' is ambiguous and did not resolve."),\n          b.joinKey(c).joinAll(l));\n    }\n  }\n  function Je(t) {\n    return (\n      t &&\n      ((!t.ractive.isolated &&\n        !(t.owner && t.owner.containerFragment) &&\n        (t.componentParent || (!t.parent && t.ractive.component))) ||\n        t.parent)\n    );\n  }\n  function Xe(t) {\n    for (var e, n = t; !n.isIteration && (e = Je(n)); ) n = e;\n    return n.isIteration && n;\n  }\n  function tn(t) {\n    for (var e = t; e; ) {\n      if (e.owner.handle) return e.owner.handle;\n      e = Je(e);\n    }\n  }\n  function en(t) {\n    throw new Error(\n      "An index or key reference (" + t + ") cannot have child properties"\n    );\n  }\n  function nn(t) {\n    for (var e = [], n = arguments.length - 1; n-- > 0; )\n      e[n] = arguments[n + 1];\n    var i = t.fragment || t._fakeFragment || (t._fakeFragment = new zl(t));\n    return i.getContext.apply(i, e);\n  }\n  function rn() {\n    for (var t = [], e = arguments.length; e--; ) t[e] = arguments[e];\n    return (\n      this.ctx || (this.ctx = new Fl.Context(this)),\n      t.unshift($a(this.ctx)),\n      Ua.apply(null, t)\n    );\n  }\n  function sn(t) {\n    for (var e = t; e && !e.context; ) e = e.parent;\n    return e ? e : t && t.ractive.fragment;\n  }\n  function an(t, e) {\n    var n = $l,\n      i = e && e.deep,\n      r = e && e.shuffle,\n      s = Nl.start();\n    e && "keep" in e && ($l = e.keep);\n    for (var a = t.length; a--; ) {\n      var o = t[a][0],\n        u = t[a][1],\n        h = t[a][2];\n      if (!o)\n        throw (\n          (Nl.end(), new Error("Failed to set invalid keypath \'" + h + "\'"))\n        );\n      if (i) hn(o, u);\n      else if (r) {\n        var l = u,\n          f = o.get();\n        if ((l || (l = f), c(f))) o.set(l);\n        else {\n          if (!Ga(f) || !Ga(l))\n            throw (\n              (Nl.end(),\n              new Error("You cannot merge an array with a non-array"))\n            );\n          var d = ln(r);\n          o.merge(l, d);\n        }\n      } else o.set(u);\n    }\n    return (\n      Nl.end(),\n      ($l = n),\n      1 === t.length\n        ? s.then(function () {\n            return t[0][1];\n          })\n        : s\n    );\n  }\n  function on(t, e, n, i) {\n    if (!n && ("." === e[0] || "^" === e[1]))\n      return (\n        y(\n          "Attempted to set a relative keypath from a non-relative context. You can use a context object to set relative keypaths."\n        ),\n        []\n      );\n    var r = S(e),\n      s = n || t.viewmodel;\n    return ql.test(e)\n      ? s.findMatches(r)\n      : s === t.viewmodel\n      ? !t.component || t.isolated || s.has(r[0]) || "@" === e[0] || !e[0] || i\n        ? [s.joinAll(r)]\n        : [Ye(t.fragment || new zl(t), e)]\n      : [s.joinAll(r)];\n  }\n  function un(e, n, i, r) {\n    var a = [];\n    if (s(n)) {\n      var o = function (i) {\n        t(n, i) &&\n          a.push.apply(\n            a,\n            on(e, i, null, r).map(function (t) {\n              return [t, n[i], i];\n            })\n          );\n      };\n      for (var u in n) o(u);\n    } else\n      a.push.apply(\n        a,\n        on(e, n, null, r).map(function (t) {\n          return [t, i, n];\n        })\n      );\n    return a;\n  }\n  function hn(e, n) {\n    var i = e.get(!1, Hl);\n    if (null == i || !o(n)) return e.set(n);\n    if (!o(i)) return e.set(n);\n    for (var r in n) t(n, r) && hn(e.joinKey(r), n[r]);\n  }\n  function ln(t) {\n    if (t === !0) return null;\n    if (u(t)) return t;\n    if (h(t))\n      return (\n        Zl[t] ||\n        (Zl[t] = function (e) {\n          return e[t];\n        })\n      );\n    throw new Error(\n      "If supplied, options.compare must be a string, function, or true"\n    );\n  }\n  function cn(t, e, n, i) {\n    if (!h(e) || !r(n)) throw new Error("Bad arguments");\n    var s = un(t, e, n, i && i.isolated);\n    return an(\n      s.map(function (t) {\n        var e = t[0],\n          n = t[1],\n          i = e.get();\n        if (!r(n) || !r(i)) throw new Error(Wl);\n        return [e, i + n];\n      })\n    );\n  }\n  function fn(t, e, n) {\n    var i = l(e) ? e : 1,\n      r = o(e) ? e : n;\n    return cn(this, t, i, r);\n  }\n  function dn(t) {\n    var e = Promise.resolve(t);\n    return qa(e, "stop", { value: f }), e;\n  }\n  function pn(t, e) {\n    t = t || {};\n    var n;\n    return (\n      t.easing && (n = u(t.easing) ? t.easing : e.easing[t.easing]),\n      {\n        easing: n || Gl,\n        duration: "duration" in t ? t.duration : 400,\n        complete: t.complete || f,\n        step: t.step || f,\n        interpolator: t.interpolator,\n      }\n    );\n  }\n  function mn(t, e, n, r) {\n    r = pn(r, t);\n    var s = e.get();\n    if (i(s, n)) return r.complete(r.to), dn(n);\n    var a = k(s, n, t, r.interpolator);\n    return a ? e.animate(s, n, r, a) : (Nl.start(), e.set(n), Nl.end(), dn(n));\n  }\n  function vn(t, e, n) {\n    if (o(t)) {\n      var i = Za(t);\n      throw new Error(\n        "ractive.animate(...) no longer supports objects. Instead of ractive.animate({\\n  " +\n          i\n            .map(function (e) {\n              return "\'" + e + "\': " + t[e];\n            })\n            .join("\\n  ") +\n          "\\n}, {...}), do\\n\\n" +\n          i\n            .map(function (e) {\n              return "ractive.animate(\'" + e + "\', " + t[e] + ", {...});";\n            })\n            .join("\\n") +\n          "\\n"\n      );\n    }\n    return mn(this, this.viewmodel.joinAll(S(t)), e, n);\n  }\n  function gn(t, e) {\n    t.event && t._eventQueue.push(t.event), (t.event = e);\n  }\n  function yn(t) {\n    t._eventQueue.length ? (t.event = t._eventQueue.pop()) : (t.event = null);\n  }\n  function bn(t, e) {\n    var n = e ? Ql : Yl;\n    if (n[t]) return n[t];\n    var i = t.split("."),\n      r = [],\n      s = !1;\n    e && (i.unshift("this"), (s = !0));\n    for (var a = Math.pow(2, i.length) - (e ? 1 : 0), o = 0; a > o; o++) {\n      for (var u = [], h = 0; h < i.length; h++)\n        u.push(1 & (o >> h) ? "*" : i[h]);\n      r.unshift(u.join("."));\n    }\n    return (\n      s &&\n        (i.length > 2 ? r.push.apply(r, bn(t, !1)) : (r.push("*"), r.push(t))),\n      (n[t] = r),\n      r\n    );\n  }\n  function wn(t, e, n, i) {\n    if ((void 0 === i && (i = []), e)) {\n      (n.name = e), i.unshift(n);\n      var r = t._nsSubs ? bn(e, !0) : ["*", e];\n      return xn(t, r, n, i, !0);\n    }\n  }\n  function xn(t, e, n, i, r) {\n    void 0 === r && (r = !1);\n    var s = !0;\n    if (r || t._nsSubs) {\n      gn(t, n);\n      for (var a = e.length; a--; )\n        e[a] in t._subs && (s = kn(t, t._subs[e[a]], n, i) && s);\n      yn(t);\n    }\n    if (t.parent && s) {\n      if (r && t.component) {\n        var o = t.component.name + "." + e[e.length - 1];\n        (e = bn(o, !1)), n && !n.component && (n.component = t);\n      }\n      s = xn(t.parent, e, n, i);\n    }\n    return s;\n  }\n  function kn(t, e, n, i) {\n    var r = null,\n      s = !1;\n    e = e.slice();\n    for (var a = 0, o = e.length; o > a; a += 1)\n      e[a].off || e[a].handler.apply(t, i) !== !1 || (s = !0);\n    return (\n      n &&\n        s &&\n        (r = n.event) &&\n        (r.preventDefault && r.preventDefault(),\n        r.stopPropagation && r.stopPropagation()),\n      !s\n    );\n  }\n  function _n(t, e) {\n    return t[e._guid] || (t[e._guid] = []);\n  }\n  function En(t, e) {\n    var n = _n(t.queue, e);\n    for (t.hook.fire(e); n.length; ) En(t, n.shift());\n    delete t.queue[e._guid];\n  }\n  function Sn(t, e) {\n    void 0 === e && (e = null);\n    var n = [];\n    return An(t, e, n, t.ractive), n;\n  }\n  function An(t, e, n, i) {\n    if (t.isAnchor) (e && t.name !== e) || n.push(t);\n    else if (t.items)\n      t.items.forEach(function (t) {\n        return An(t, e, n, i);\n      });\n    else if (t.iterations)\n      t.iterations.forEach(function (t) {\n        return An(t, e, n, i);\n      });\n    else if (!t.fragment || (t.component && t.fragment.ractive !== i)) {\n      if (t.instance && t.instance.fragment) {\n        var r = [];\n        An(t.instance.fragment, e, r, i),\n          r.forEach(function (t) {\n            return t.ractive === i && n.push(t);\n          });\n      }\n    } else An(t.fragment, e, n, i);\n  }\n  function Cn(t, e) {\n    void 0 === e && (e = null);\n    var n = Sn(t.fragment, e),\n      i = {},\n      r = t._children.byName;\n    n.forEach(function (t) {\n      var e = t.name;\n      e in i || (i[e] = 0);\n      var n = i[e],\n        s = (r[e] || [])[n];\n      s &&\n        s.lastBound !== t &&\n        (s.lastBound && s.lastBound.removeChild(s), t.addChild(s)),\n        i[e]++;\n    });\n  }\n  function On(t) {\n    t.instance.fragment.rendered &&\n      ((t.shouldDestroy = !0), t.instance.unrender()),\n      (t.instance.el = null);\n  }\n  function Nn(t, e) {\n    void 0 === e && (e = {});\n    var n,\n      i = this._children;\n    if (t.parent && t.parent !== this)\n      throw new Error(\n        "Instance " +\n          t._guid +\n          " is already attached to a different instance " +\n          t.parent._guid +\n          ". Please detach it from the other instance using detachChild first."\n      );\n    if (t.parent)\n      throw new Error(\n        "Instance " + t._guid + " is already attached to this instance."\n      );\n    var r = {\n      instance: t,\n      ractive: this,\n      name: e.name || t.constructor.name || "Ractive",\n      target: e.target || !1,\n      bubble: jn,\n      findNextNode: Tn,\n    };\n    if (((r.nameOption = e.name), r.target)) {\n      var s;\n      (s = i.byName[r.target]) ||\n        ((s = []), this.set("@this.children.byName." + r.target, s)),\n        (n = e.prepend ? 0 : void 0 !== e.insertAt ? e.insertAt : s.length);\n    } else (r.up = this.fragment), (r.external = !0);\n    (t.parent = this), (t.root = this.root), (t.component = r), i.push(r);\n    var a = Nl.start(),\n      o = t.viewmodel.getRactiveModel();\n    return (\n      o\n        .joinKey("parent", { lastLink: !1 })\n        .link(this.viewmodel.getRactiveModel()),\n      o\n        .joinKey("root", { lastLink: !1 })\n        .link(this.root.viewmodel.getRactiveModel()),\n      ec.attachchild.fire(t),\n      r.target\n        ? (On(r),\n          this.splice("@this.children.byName." + r.target, n, 0, r),\n          Cn(this, r.target))\n        : t.isolated || t.viewmodel.attached(this.fragment),\n      Nl.end(),\n      (a.ractive = t),\n      a.then(function () {\n        return t;\n      })\n    );\n  }\n  function jn() {\n    Nl.addFragment(this.instance.fragment);\n  }\n  function Tn() {\n    return this.anchor ? this.anchor.findNextNode() : void 0;\n  }\n  function Vn(t, e) {\n    (this.computed[t] = e),\n      (h(e) || u(e)) && (e = this.computed[t] = { get: e });\n    var n = S(t);\n    if (!~t.indexOf("*")) {\n      var i = n.pop();\n      return this.viewmodel.joinAll(n).compute(i, e);\n    }\n    e.pattern = new RegExp(\n      "^" +\n        n\n          .map(function (t) {\n            return t\n              .replace(/\\*\\*/g, "(.+)")\n              .replace(/\\*/g, "((?:\\\\\\\\.|[^\\\\.])+)");\n          })\n          .join("\\\\.") +\n        "$"\n    );\n  }\n  function Pn(t, e) {\n    var n = Nl.start(),\n      i = Vn.call(this, t, e);\n    if (i) {\n      var r = S(t);\n      1 !== r.length || i.isReadonly || i.set(this.viewmodel.value[r[0]]);\n      var s = r.reduce(function (t, e) {\n        return t && t.childByKey[e];\n      }, this.viewmodel);\n      s &&\n        (s.rebind(i, s, !1),\n        s.parent && delete s.parent.childByKey[s.key],\n        F());\n    }\n    return Nl.end(), n;\n  }\n  function Mn() {\n    return this.isDetached\n      ? this.el\n      : (this.el && V(this.el.__ractive_instances__, this),\n        (this.el = this.fragment.detach()),\n        (this.isDetached = !0),\n        ec.detach.fire(this),\n        this.el);\n  }\n  function In(t) {\n    for (var e, n, i = this._children, r = i.length; r--; )\n      if (i[r].instance === t) {\n        (n = r), (e = i[r]);\n        break;\n      }\n    if (!e || t.parent !== this)\n      throw new Error(\n        "Instance " + t._guid + " is not attached to this instance."\n      );\n    var s = Nl.start();\n    e.anchor && e.anchor.removeChild(e),\n      t.isolated || t.viewmodel.detached(),\n      i.splice(n, 1),\n      e.target &&\n        (this.splice(\n          "@this.children.byName." + e.target,\n          i.byName[e.target].indexOf(e),\n          1\n        ),\n        Cn(this, e.target));\n    var a = t.viewmodel.getRactiveModel();\n    return (\n      a.joinKey("parent", { lastLink: !1 }).unlink(),\n      a.joinKey("root", { lastLink: !1 }).link(a),\n      (t.root = t),\n      (t.parent = null),\n      (t.component = null),\n      ec.detachchild.fire(t),\n      Nl.end(),\n      (s.ractive = t),\n      s.then(function () {\n        return t;\n      })\n    );\n  }\n  function Rn(t, e) {\n    var n = this;\n    if ((void 0 === e && (e = {}), !this.rendered))\n      throw new Error(\n        "Cannot call ractive.find(\'" +\n          t +\n          "\') unless instance is rendered to the DOM"\n      );\n    var i = this.fragment.find(t, e);\n    if (i) return i;\n    if (e.remote)\n      for (var r = 0; r < this._children.length; r++)\n        if (\n          n._children[r].instance.fragment.rendered &&\n          (i = n._children[r].instance.find(t, e))\n        )\n          return i;\n  }\n  function Bn(t, e) {\n    if ((void 0 === e && (e = {}), !this.rendered))\n      throw new Error(\n        "Cannot call ractive.findAll(\'" +\n          t +\n          "\', ...) unless instance is rendered to the DOM"\n      );\n    return (\n      Ga(e.result) || (e.result = []),\n      this.fragment.findAll(t, e),\n      e.remote &&\n        this._children.forEach(function (n) {\n          !n.target &&\n            n.instance.fragment &&\n            n.instance.fragment.rendered &&\n            n.instance.findAll(t, e);\n        }),\n      e.result\n    );\n  }\n  function Kn(t, e) {\n    return (\n      !e && o(t) && ((e = t), (t = "")),\n      (e = e || {}),\n      Ga(e.result) || (e.result = []),\n      this.fragment.findAllComponents(t, e),\n      e.remote &&\n        this._children.forEach(function (n) {\n          !n.target &&\n            n.instance.fragment &&\n            n.instance.fragment.rendered &&\n            ((t && n.name !== t) || e.result.push(n.instance),\n            n.instance.findAllComponents(t, e));\n        }),\n      e.result\n    );\n  }\n  function Ln(t, e) {\n    var n = this;\n    void 0 === e && (e = {}), o(t) && ((e = t), (t = ""));\n    var i = this.fragment.findComponent(t, e);\n    if (i) return i;\n    if (e.remote) {\n      if (!t && this._children.length) return this._children[0].instance;\n      for (var r = 0; r < this._children.length; r++)\n        if (!n._children[r].target) {\n          if (n._children[r].name === t) return n._children[r].instance;\n          if ((i = n._children[r].instance.findComponent(t, e))) return i;\n        }\n    }\n  }\n  function Dn(t) {\n    return this.container\n      ? this.container.component && this.container.component.name === t\n        ? this.container\n        : this.container.findContainer(t)\n      : null;\n  }\n  function Fn(t) {\n    return this.parent\n      ? this.parent.component && this.parent.component.name === t\n        ? this.parent\n        : this.parent.findParent(t)\n      : null;\n  }\n  function zn(t, e, n) {\n    for (\n      void 0 === e && (e = !0);\n      t &&\n      (t.type !== Yo || (n && t.name !== n)) &&\n      (!e || (t.type !== ru && t.type !== eu));\n\n    )\n      t = t.owner\n        ? t.owner\n        : t.component || t["yield"]\n        ? t.containerFragment || t.component.up\n        : t.parent\n        ? t.parent\n        : t.up\n        ? t.up\n        : void 0;\n    return t;\n  }\n  function Un(t, e, n) {\n    var i = [],\n      r = $n(t, e, n);\n    if (!r) return null;\n    var s = r.length - 2 - r[1],\n      a = Math.min(t, r[0]),\n      o = a + r[1];\n    i.startIndex = a;\n    var u;\n    for (u = 0; a > u; u += 1) i.push(u);\n    for (; o > u; u += 1) i.push(-1);\n    for (; t > u; u += 1) i.push(u + s);\n    return 0 !== s ? (i.touchedFrom = r[0]) : (i.touchedFrom = t), i;\n  }\n  function $n(t, e, n) {\n    switch (e) {\n      case "splice":\n        for (\n          void 0 !== n[0] && n[0] < 0 && (n[0] = t + Math.max(n[0], -t)),\n            c(n[0]) && (n[0] = 0);\n          n.length < 2;\n\n        )\n          n.push(t - n[0]);\n        return (\n          l(n[1]) || (n[1] = t - n[0]), (n[1] = Math.min(n[1], t - n[0])), n\n        );\n      case "sort":\n      case "reverse":\n        return null;\n      case "pop":\n        return t ? [t - 1, 1] : [0, 0];\n      case "push":\n        return [t, 0].concat(n);\n      case "shift":\n        return [0, t ? 1 : 0];\n      case "unshift":\n        return [0, 0].concat(n);\n    }\n  }\n  function qn(t) {\n    function e(t) {\n      for (var e = [], i = arguments.length - 1; i-- > 0; )\n        e[i] = arguments[i + 1];\n      return n(this.viewmodel.joinAll(S(t)), e);\n    }\n    function n(e, n) {\n      var i = e.get();\n      if (!Ga(i)) {\n        if (c(i)) {\n          i = [];\n          var r = nc[t].apply(i, n),\n            s = Nl.start().then(function () {\n              return r;\n            });\n          return e.set(i), Nl.end(), s;\n        }\n        throw new Error(\n          "shuffle array method " +\n            t +\n            " called on non-array at " +\n            e.getKeypath()\n        );\n      }\n      var a = Un(i.length, t, n),\n        o = nc[t].apply(i, n),\n        u = Nl.start().then(function () {\n          return o;\n        });\n      return (\n        (u.result = o),\n        a ? (e.shuffle ? e.shuffle(a) : e.mark()) : e.set(o),\n        Nl.end(),\n        u\n      );\n    }\n    return { path: e, model: n };\n  }\n  function Hn(t, e, n) {\n    e.parent && e.parent.wrapper && e.parent.adapt();\n    var i = Nl.start();\n    return (\n      e.mark(n && n.force),\n      e.notifyUpstream(),\n      Nl.end(),\n      ec.update.fire(t, e),\n      i\n    );\n  }\n  function Zn(t, e) {\n    var n, i;\n    return (\n      h(t) ? ((i = S(t)), (n = e)) : (n = t),\n      Hn(this, i ? this.viewmodel.joinAll(i) : this.viewmodel, n)\n    );\n  }\n  function Wn(e, n, i) {\n    var r = [];\n    if (s(n)) for (var a in n) t(n, a) && r.push([Gn(e, a).model, n[a]]);\n    else r.push([Gn(e, n).model, i]);\n    return r;\n  }\n  function Gn(t, e) {\n    var n = t.fragment;\n    return h(e)\n      ? { model: Ye(n, e), instance: n.ractive }\n      : { model: n.findContext(), instance: e };\n  }\n  function Qn(t, e) {\n    return (\n      t.events &&\n      t.events.find &&\n      t.events.find(function (t) {\n        return ~t.template.n.indexOf(e);\n      })\n    );\n  }\n  function Yn(t) {\n    for (var e = [], n = arguments.length - 1; n-- > 0; )\n      e[n] = arguments[n + 1];\n    var i;\n    if (e[0] instanceof fc) {\n      var r = e.shift();\n      (i = $a(r)), Ua(i, r);\n    } else i = !o(e[0]) || (null !== e[0] && e[0].constructor !== Object) ? fc.forRactive(this) : fc.forRactive(this, e.shift());\n    return wn(this, t, i, e);\n  }\n  function Jn(t, e) {\n    if (!h(t)) return this.viewmodel.get(!0, t);\n    var n,\n      i = S(t),\n      r = i[0];\n    return (\n      this.viewmodel.has(r) ||\n        (this.component &&\n          !this.isolated &&\n          (n = Ye(this.fragment || new zl(this), r))),\n      (n = this.viewmodel.joinAll(i)),\n      n.get(!0, e)\n    );\n  }\n  function Xn() {\n    return lc.f ? lc.f.getContext() : void 0;\n  }\n  function ti(t) {\n    h(t) && Ec && (t = Ec.call(document, t));\n    var e;\n    if (t) {\n      if (t._ractive) return t._ractive.proxy.getContext();\n      if (!(e = t.__ractive_instances__)) return ti(t.parentNode);\n      if (1 === e.length) return nn(e[0]);\n    }\n  }\n  function ei(t, e) {\n    return t ? (h(t) && (t = this.find(t, e)), ti(t)) : nn(this);\n  }\n  function ni(t) {\n    return Vc ? t : { is: t };\n  }\n  function ii() {\n    return Ja.createDocumentFragment();\n  }\n  function ri(t) {\n    var e;\n    if (t && "boolean" != typeof t) {\n      if (!Ya || !Ja || !t) return null;\n      if (t.nodeType) return t;\n      if (h(t)) {\n        if (((e = Ja.getElementById(t)), !e && Ja.querySelector))\n          try {\n            e = Ja.querySelector(t);\n          } catch (n) {}\n        if (e && e.nodeType) return e;\n      }\n      return t[0] && t[0].nodeType ? t[0] : null;\n    }\n  }\n  function si(t) {\n    return (\n      t &&\n        "unknown" != typeof t.parentNode &&\n        t.parentNode &&\n        t.parentNode.removeChild(t),\n      t\n    );\n  }\n  function ai(t) {\n    return null == t || (l(t) && isNaN(t)) || !t.toString ? "" : "" + t;\n  }\n  function oi(t) {\n    return ai(t)\n      .replace(/&/g, "&amp;")\n      .replace(/"/g, "&quot;")\n      .replace(/\'/g, "&#39;");\n  }\n  function ui(t, e) {\n    if (!this.fragment.rendered)\n      throw new Error(\n        "The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`."\n      );\n    if (((t = ri(t)), (e = ri(e) || null), !t))\n      throw new Error("You must specify a valid target to insert into");\n    t.insertBefore(this.detach(), e),\n      (this.el = t),\n      (t.__ractive_instances__ || (t.__ractive_instances__ = [])).push(this),\n      (this.isDetached = !1),\n      hi(this);\n  }\n  function hi(t) {\n    ec.insert.fire(t),\n      t.findAllComponents("*").forEach(function (t) {\n        hi(t.instance);\n      });\n  }\n  function li(t, e, n) {\n    var i,\n      r = (n && (n.ractive || n.instance)) || this,\n      s = S(t);\n    !r.viewmodel.has(s[0]) &&\n      r.component &&\n      ((i = Ye(r.component.up, s[0])), (i = i.joinAll(s.slice(1))));\n    var a = i || r.viewmodel.joinAll(s),\n      o = this.viewmodel.joinAll(S(e), { lastLink: !1 });\n    if (ci(a, o) || ci(o, a))\n      throw new Error("A keypath cannot be linked to itself.");\n    var u = Nl.start();\n    return o.link(a, (n && n.keypath) || t), Nl.end(), u;\n  }\n  function ci(t, e) {\n    for (var n = e; n; ) {\n      if (n === t || n.owner === t) return !0;\n      n = n.target || n.parent;\n    }\n  }\n  function fi(t, e) {\n    var n = e && t.model ? t.model.get() : t.newValue;\n    try {\n      t.oldValue = t.oldFn\n        ? t.oldFn.call(t.oldContext, void 0, n, t.keypath)\n        : n;\n    } catch (i) {\n      y(\n        "Failed to execute observer oldValue callback for \'" +\n          this.keypath +\n          "\': " +\n          (i.message || i)\n      ),\n        (t.oldValue = n);\n    }\n  }\n  function di() {\n    for (var t = [], e = arguments.length; e--; ) t[e] = arguments[e];\n    return t.map(_).join(".");\n  }\n  function pi(t) {\n    return S(t).map(A);\n  }\n  function mi(t, e, n) {\n    var i = t.oldValues;\n    t.oldFn\n      ? (n || (t.oldValues = {}),\n        Za(e).forEach(function (n) {\n          var r = [i[n], e[n], n],\n            s = t.pattern.exec(n);\n          s && r.push.apply(r, s.slice(1)),\n            (t.oldValues[n] = t.oldFn.apply(t.oldContext, r));\n        }))\n      : n\n      ? Za(e).forEach(function (t) {\n          return (i[t] = e[t]);\n        })\n      : (t.oldValues = e);\n  }\n  function vi() {\n    return -1;\n  }\n  function gi(t, e, n) {\n    var i,\n      r,\n      a = this,\n      o = [];\n    s(t)\n      ? ((i = t), (r = e || {}))\n      : u(t)\n      ? ((i = { "": t }), (r = e || {}))\n      : ((i = {}), (i[t] = e), (r = n || {}));\n    var h = !1;\n    return (\n      Za(i).forEach(function (t) {\n        var e = i[t],\n          n = function () {\n            for (var t = [], n = arguments.length; n--; ) t[n] = arguments[n];\n            return h ? void 0 : e.apply(this, t);\n          },\n          s = t.split(" ");\n        s.length > 1 &&\n          (s = s.filter(function (t) {\n            return t;\n          })),\n          s.forEach(function (t) {\n            r.keypath = t;\n            var e = yi(a, t, n, r);\n            e && o.push(e);\n          });\n      }),\n      this._observers.push.apply(this._observers, o),\n      {\n        cancel: function () {\n          return o.forEach(function (t) {\n            return t.cancel();\n          });\n        },\n        isSilenced: function () {\n          return h;\n        },\n        silence: function () {\n          return (h = !0);\n        },\n        resume: function () {\n          return (h = !1);\n        },\n      }\n    );\n  }\n  function yi(t, e, n, i) {\n    var r = S(e),\n      s = r.indexOf("*");\n    ~s || (s = r.indexOf("**")), (i.fragment = i.fragment || t.fragment);\n    var a;\n    if (\n      (i.fragment\n        ? ~r[0].indexOf(".*")\n          ? ((a = i.fragment.findContext()), (s = 0), (r[0] = r[0].slice(1)))\n          : (a = 0 === s ? i.fragment.findContext() : Ye(i.fragment, r[0]))\n        : (a = t.viewmodel.joinKey(r[0])),\n      a || (a = t.viewmodel.joinKey(r[0])),\n      ~s)\n    ) {\n      var o = r.indexOf("**");\n      return ~o && (o + 1 !== r.length || ~r.indexOf("*"))\n        ? void b(\n            "Recursive observers may only specify a single \'**\' at the end of the path."\n          )\n        : ((a = a.joinAll(r.slice(1, s))), new Rc(t, a, r.slice(s), n, i));\n    }\n    return (\n      (a = a.joinAll(r.slice(1))),\n      i.array ? new Kc(t, a, n, i) : new Pc(t, a, n, i)\n    );\n  }\n  function bi(t, e, n) {\n    return s(t) || u(t)\n      ? ((n = Ua(e || {}, Dc)), this.observe(t, n))\n      : ((n = Ua(n || {}, Dc)), this.observe(t, e, n));\n  }\n  function wi(t, e) {\n    var n = this;\n    if (t) {\n      var i = t.split(" ").map(Fc).filter(zc);\n      i.forEach(function (t) {\n        var i = n._subs[t];\n        if (i && e) {\n          var r = i.find(function (t) {\n            return t.callback === e;\n          });\n          r && (V(i, r), (r.off = !0), t.indexOf(".") && n._nsSubs--);\n        } else i && (t.indexOf(".") && (n._nsSubs -= i.length), (i.length = 0));\n      });\n    } else this._subs = {};\n    return this;\n  }\n  function xi(e, n) {\n    var i = this,\n      r = o(e) ? e : {};\n    h(e) && (r[e] = n);\n    var s = !1,\n      a = [],\n      u = function (e) {\n        var n = r[e],\n          o = function () {\n            for (var t = [], e = arguments.length; e--; ) t[e] = arguments[e];\n            return s ? void 0 : n.apply(this, t);\n          },\n          u = { callback: n, handler: o };\n        if (t(r, e)) {\n          var h = e.split(" ").map(Fc).filter(zc);\n          h.forEach(function (t) {\n            (i._subs[t] || (i._subs[t] = [])).push(u),\n              t.indexOf(".") && i._nsSubs++,\n              a.push([t, u]);\n          });\n        }\n      };\n    for (var l in r) u(l);\n    return {\n      cancel: function () {\n        return a.forEach(function (t) {\n          return i.off(t[0], t[1].callback);\n        });\n      },\n      isSilenced: function () {\n        return s;\n      },\n      silence: function () {\n        return (s = !0);\n      },\n      resume: function () {\n        return (s = !1);\n      },\n    };\n  }\n  function ki(t, e) {\n    var n = this.on(t, function () {\n      e.apply(this, arguments), n.cancel();\n    });\n    return n;\n  }\n  function _i(t, e) {\n    void 0 === e && (e = {});\n    var n = S(t);\n    if (this.viewmodel.has(n[0])) {\n      var i = this.viewmodel.joinAll(n);\n      if (!i.isLink) return;\n      for (; (i = i.target) && e.canonical !== !1 && i.isLink; );\n      if (i) return { ractive: i.root.ractive, keypath: i.getKeypath() };\n    }\n  }\n  function Ei(t) {\n    return void 0 === t ? Qc : (Qc = t);\n  }\n  function Si(t) {\n    Hc.push(t), (Zc = !0);\n  }\n  function Ai(t) {\n    var e = ji();\n    e &&\n      (t || Zc) &&\n      (Qc\n        ? Hc.forEach(function (t) {\n            var e = Oi(t.id);\n            if (e) {\n              var n = Ci(t.id);\n              Gc\n                ? e.styleSheet.cssText !== n && (e.styleSheet.cssText = n)\n                : e.innerHTML !== n && (e.innerHTML = n);\n            }\n          })\n        : Gc\n        ? (e.styleSheet.cssText = Ci(null))\n        : (e.innerHTML = Ci(null)),\n      (Zc = !1));\n  }\n  function Ci(t) {\n    t && !Ga(t) && (t = [t]);\n    var e = t\n      ? Hc.filter(function (e) {\n          return ~t.indexOf(e.id);\n        })\n      : Hc;\n    return (\n      e.forEach(function (t) {\n        return (t.applied = !0);\n      }),\n      e.reduce(function (t, e) {\n        return "" + (t ? t + "\\n\\n/* {" + e.id + "} */\\n" + e.styles : "");\n      }, qc)\n    );\n  }\n  function Oi(t) {\n    return Ja && (Ja.querySelector(\'[data-ractive-css="\' + t + \'"]\') || Ni(t));\n  }\n  function Ni(t) {\n    if (Ja) {\n      var e = Ja.createElement("style");\n      return (\n        (e.type = "text/css"),\n        e.setAttribute("data-ractive-css", t || ""),\n        Ja.getElementsByTagName("head")[0].appendChild(e),\n        null === Gc && (Gc = !!e.styleSheet),\n        e\n      );\n    }\n  }\n  function ji() {\n    return Wc || (Wc = Ni()), Wc;\n  }\n  function Ti(t, e, n) {\n    void 0 === n && (n = []);\n    var i = [],\n      r = function (t) {\n        return t.replace(tf, function (t, e) {\n          return i[e];\n        });\n      };\n    return (\n      (t = t\n        .replace(Xc, function (t) {\n          return "\\x00" + (i.push(t) - 1);\n        })\n        .replace(Jc, "")),\n      n.forEach(function (e) {\n        t = t.replace(e, function (t) {\n          return "\\x00" + (i.push(t) - 1);\n        });\n      }),\n      e(t, r)\n    );\n  }\n  function Vi(t) {\n    return t.trim();\n  }\n  function Pi(t) {\n    return t.str;\n  }\n  function Mi(t, e) {\n    for (var n, i = []; (n = af.exec(t)); )\n      i.push({ str: n[0], base: n[1], modifiers: n[2] });\n    for (var r = i.map(Pi), s = [], a = i.length; a--; ) {\n      var o = r.slice(),\n        u = i[a];\n      o[a] = u.base + e + u.modifiers || "";\n      var h = r.slice();\n      (h[a] = e + " " + h[a]), s.push(o.join(" "), h.join(" "));\n    }\n    return s.join(", ");\n  }\n  function Ii(t, e) {\n    var n,\n      i = \'[data-ractive-css~="{\' + e + \'}"]\';\n    return (n = uf.test(t)\n      ? t.replace(uf, i)\n      : Ti(\n          t,\n          function (t, e) {\n            return (\n              (t = t\n                .replace(nf, "$&")\n                .replace(ef, function (t, e) {\n                  if (of.test(e)) return t;\n                  var n = e.split(",").map(Vi),\n                    r =\n                      n\n                        .map(function (t) {\n                          return Mi(t, i);\n                        })\n                        .join(", ") + " ";\n                  return t.replace(e, r);\n                })\n                .replace(rf, "")),\n              e(t)\n            );\n          },\n          [sf]\n        ));\n  }\n  function Ri() {\n    return Math.floor(65536 * (1 + Math.random()))\n      .toString(16)\n      .substring(1);\n  }\n  function Bi() {\n    return (\n      Ri() +\n      Ri() +\n      "-" +\n      Ri() +\n      "-" +\n      Ri() +\n      "-" +\n      Ri() +\n      "-" +\n      Ri() +\n      Ri() +\n      Ri()\n    );\n  }\n  function Ki(t, e, n) {\n    var i = o(t) ? e : n,\n      r = this._cssModel;\n    r.locked = !0;\n    var s = an(un({ viewmodel: r }, t, e, !0), i);\n    r.locked = !1;\n    var a = Nl.start();\n    return (\n      this.extensions.forEach(function (t) {\n        var e = t._cssModel;\n        e.mark(), e.downstreamChanged("", 1);\n      }),\n      Nl.end(),\n      Li(this, !i || i.apply !== !1),\n      s.then(function () {\n        return a;\n      })\n    );\n  }\n  function Li(t, e) {\n    var n = Di(t),\n      i = t.extensions\n        .map(function (t) {\n          return Li(t, !1);\n        })\n        .reduce(function (t, e) {\n          return e || t;\n        }, !1);\n    if (e && (n || i)) {\n      var r = t._cssDef;\n      (!r || (r && r.applied)) && Ai(!0);\n    }\n    return n || i;\n  }\n  function Di(t) {\n    var e = t.css;\n    if (u(e)) {\n      var n = t._cssDef,\n        i = zi(t, e),\n        r = n.transform ? Ii(i, n.id) : i;\n      if (n.styles !== r) return (n.styles = r), !0;\n    }\n  }\n  function Fi(t) {\n    for (var e = t, n = []; e; )\n      e.prototype.cssId && n.push(e.prototype.cssId), (e = e.Parent);\n    return n;\n  }\n  function zi(t, e) {\n    if (h(e)) return e;\n    var n = t.cssData,\n      i = t._cssModel,\n      r = function (t) {\n        return i.joinAll(S(t)).get();\n      };\n    r.__proto__ = n;\n    var s = e.call(t, r);\n    return h(s) ? s : "";\n  }\n  function Ui(t, e, n) {\n    var i =\n        t.css === !0\n          ? ""\n          : h(t.css) && !lf.test(t.css)\n          ? ri(t.css) || t.css\n          : t.css,\n      r = i,\n      s = t.cssId || Bi();\n    o(i)\n      ? ((i = "textContent" in i ? i.textContent : i.innerHTML), (r = i))\n      : u(i) && ((r = i), (i = zi(e, i)));\n    var a = {\n      transform: "noCSSTransform" in t ? !t.noCSSTransform : !t.noCssTransform,\n    };\n    qa(e, "_cssDef", { configurable: !0, value: a }),\n      qa(e, "css", {\n        get: function () {\n          return r;\n        },\n        set: function (t) {\n          r = t;\n          var n = zi(e, r),\n            i = a.styles;\n          (a.styles = a.transform ? Ii(n, s) : n),\n            a.applied && i !== a.styles && Ai(!0);\n        },\n      }),\n      (a.styles = a.transform ? Ii(i, s) : i),\n      (a.id = n.cssId = s),\n      e._cssIds.push(s),\n      Si(e._cssDef);\n  }\n  function $i(t) {\n    t &&\n      t.constructor !== Object &&\n      (u(t) ||\n        (o(t)\n          ? y(\n              "If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged"\n            )\n          : p(\n              "data option must be an object or a function, `" +\n                t +\n                "` is not valid"\n            )));\n  }\n  function qi() {\n    return {};\n  }\n  function Hi(t, e) {\n    $i(e);\n    var n = u(t);\n    e || n || (e = qi);\n    var i = u(e);\n    return n || i\n      ? function () {\n          var r = i ? Zi(e, this) : e,\n            s = n ? Zi(t, this) : t;\n          return Wi(r, s);\n        }\n      : Wi(e, t);\n  }\n  function Zi(t, e) {\n    var n = t.call(e);\n    if (n)\n      return (\n        o(n) || p("Data function must return an object"),\n        n.constructor !== Object &&\n          b(\n            "Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged"\n          ),\n        n\n      );\n  }\n  function Wi(t, e) {\n    if (t && e) {\n      for (var n in e) n in t || (t[n] = e[n]);\n      return t;\n    }\n    return t || e;\n  }\n  function Gi(t) {\n    var e = t._config.template;\n    if (e && e.fn) {\n      var n = Qi(t, e.fn);\n      return n !== e.result ? ((e.result = n), n) : void 0;\n    }\n  }\n  function Qi(t, e) {\n    return e.call(t, {\n      fromId: El.fromId,\n      isParsed: El.isParsed,\n      parse: function (e, n) {\n        return void 0 === n && (n = El.getParseOptions(t)), El.parse(e, n);\n      },\n    });\n  }\n  function Yi(t, e) {\n    return h(t) ? (t = Ji(t, e)) : (Xi(t), dt(t)), t;\n  }\n  function Ji(t, e) {\n    return "#" === t[0] && (t = El.fromId(t)), El.parseFor(t, e);\n  }\n  function Xi(t) {\n    if (void 0 == t) throw new Error("The template cannot be " + t + ".");\n    if (!l(t.v))\n      throw new Error(\n        "The template parser was passed a non-string template, but the template doesn\'t have a version.  Make sure you\'re passing in the template you think you are."\n      );\n    if (t.v !== Do)\n      throw new Error(\n        "Mismatched template version (expected " +\n          Do +\n          ", got " +\n          t.v +\n          ") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app"\n      );\n  }\n  function tr(e, n, i) {\n    if (n) for (var r in n) (i || !t(e, r)) && (e[r] = n[r]);\n  }\n  function er(t, e, n) {\n    function i() {\n      var t = nr(i._parent, e),\n        r = "_super" in this,\n        s = this._super;\n      this._super = t;\n      var a = n.apply(this, arguments);\n      return r ? (this._super = s) : delete this._super, a;\n    }\n    return /_super/.test(n) ? ((i._parent = t), (i._method = n), i) : n;\n  }\n  function nr(t, e) {\n    if (e in t) {\n      var n = t[e];\n      return u(n)\n        ? n\n        : function () {\n            return n;\n          };\n    }\n    return f;\n  }\n  function ir(t, e, n) {\n    return (\n      "options." +\n      t +\n      " has been deprecated in favour of options." +\n      e +\n      "." +\n      (n\n        ? " You cannot specify both options, please use options." + e + "."\n        : "")\n    );\n  }\n  function rr(t, e, n) {\n    if (e in t) {\n      if (n in t) throw new Error(ir(e, n, !0));\n      y(ir(e, n)), (t[n] = t[e]);\n    }\n  }\n  function sr(t) {\n    rr(t, "beforeInit", "onconstruct"),\n      rr(t, "init", "onrender"),\n      rr(t, "complete", "oncomplete"),\n      rr(t, "eventDefinitions", "events"),\n      Ga(t.adaptors) && rr(t, "adaptors", "adapt");\n  }\n  function ar(e, n, i, r, s) {\n    sr(r);\n    for (var a in r)\n      if (t(kf, a)) {\n        var o = r[a];\n        "el" !== a && u(o)\n          ? y(\n              a +\n                " is a Ractive option that does not expect a function and will be ignored",\n              "init" === e ? i : null\n            )\n          : (i[a] = o);\n      }\n    if (i.append && i.enhance)\n      throw new Error("Cannot use append and enhance at the same time");\n    yf.forEach(function (t) {\n      t[e](n, i, r, s);\n    }),\n      Yc[e](n, i, r, s),\n      df[e](n, i, r, s),\n      cf[e](n, i, r, s),\n      or(n.prototype, i, r);\n  }\n  function or(e, n, i) {\n    for (var r in i)\n      if (!_f[r] && t(i, r)) {\n        var s = i[r];\n        u(s) &&\n          ((r in im ||\n            ("on" === r.slice(0, 2) && r.slice(2) in ec && r in n)) &&\n            !Sf.test(s.toString()) &&\n            y(\n              "Overriding Ractive prototype function \'" +\n                r +\n                "\' without calling the \'" +\n                Sf +\n                "\' method can be very dangerous."\n            ),\n          (s = er(e, r, s))),\n          (n[r] = s);\n      }\n  }\n  function ur(t) {\n    var e = {};\n    return (\n      t.forEach(function (t) {\n        return (e[t] = !0);\n      }),\n      e\n    );\n  }\n  function hr(t) {\n    return h(t)\n      ? Ti(t, function (t, e) {\n          return t\n            .split(";")\n            .filter(function (t) {\n              return !!t.trim();\n            })\n            .map(e)\n            .reduce(function (t, e) {\n              var n = e.indexOf(":"),\n                i = e.substr(0, n).trim();\n              return (t[i] = e.substr(n + 1).trim()), t;\n            }, {});\n        })\n      : {};\n  }\n  function lr(t) {\n    for (var e = t.split(Nf), n = e.length; n--; ) e[n] || e.splice(n, 1);\n    return e;\n  }\n  function cr(t) {\n    var e = t.element,\n      n = t.name;\n    if ("value" === n) {\n      if (\n        (t.interpolator && (t.interpolator.bound = !0),\n        "select" === e.name && "value" === n)\n      )\n        return e.getAttribute("multiple") ? fr : dr;\n      if ("textarea" === e.name) return gr;\n      if (null != e.getAttribute("contenteditable")) return pr;\n      if ("input" === e.name) {\n        var i = e.getAttribute("type");\n        if ("file" === i) return f;\n        if ("radio" === i && e.binding && "name" === e.binding.attribute.name)\n          return mr;\n        if (~jf.indexOf(i)) return gr;\n      }\n      return vr;\n    }\n    var r = e.node;\n    if (t.isTwoway && "name" === n) {\n      if ("radio" === r.type) return yr;\n      if ("checkbox" === r.type) return br;\n    }\n    if ("style" === n) return wr;\n    if (0 === n.indexOf("style-")) return xr;\n    if ("class" === n && (!r.namespaceURI || r.namespaceURI === Sc)) return kr;\n    if (0 === n.indexOf("class-")) return _r;\n    if (t.isBoolean) {\n      var s = e.getAttribute("type");\n      return (\n        !t.interpolator ||\n          "checked" !== n ||\n          ("checkbox" !== s && "radio" !== s) ||\n          (t.interpolator.bound = !0),\n        Er\n      );\n    }\n    return t.namespace && t.namespace !== t.node.namespaceURI ? Ar : Sr;\n  }\n  function fr(t) {\n    var e = this.getValue();\n    Ga(e) || (e = [e]);\n    var n = this.node.options,\n      i = n.length;\n    if (t) for (; i--; ) n[i].selected = !1;\n    else\n      for (; i--; ) {\n        var r = n[i],\n          s = r._ractive ? r._ractive.value : r.value;\n        r.selected = O(e, s);\n      }\n  }\n  function dr(t) {\n    var e = this.getValue();\n    if (!this.locked) {\n      this.node._ractive.value = e;\n      var n = this.node.options,\n        i = n.length,\n        r = !1;\n      if (t) for (; i--; ) n[i].selected = !1;\n      else\n        for (; i--; ) {\n          var s = n[i],\n            a = s._ractive ? s._ractive.value : s.value;\n          if ((s.disabled && s.selected && (r = !0), a == e))\n            return void (s.selected = !0);\n        }\n      r || (this.node.selectedIndex = -1);\n    }\n  }\n  function pr(t) {\n    var e = this.getValue();\n    this.locked ||\n      (t ? (this.node.innerHTML = "") : (this.node.innerHTML = c(e) ? "" : e));\n  }\n  function mr(t) {\n    var e = this.node,\n      n = e.checked,\n      i = this.getValue();\n    return t\n      ? (e.checked = !1)\n      : ((e.value = this.node._ractive.value = i),\n        (e.checked = this.element.compare(\n          i,\n          this.element.getAttribute("name")\n        )),\n        void (\n          n &&\n          !e.checked &&\n          this.element.binding &&\n          this.element.binding.rendered &&\n          this.element.binding.group.model.set(\n            this.element.binding.group.getValue()\n          )\n        ));\n  }\n  function vr(t) {\n    if (!this.locked)\n      if (t)\n        this.node.removeAttribute("value"),\n          (this.node.value = this.node._ractive.value = null);\n      else {\n        var e = this.getValue();\n        (this.node.value = this.node._ractive.value = e),\n          this.node.setAttribute("value", ai(e));\n      }\n  }\n  function gr(t) {\n    if (!this.locked)\n      if (t)\n        (this.node._ractive.value = ""), this.node.removeAttribute("value");\n      else {\n        var e = this.getValue();\n        this.node._ractive.value = e;\n        var n = ai(e);\n        this.node.value !== n && (this.node.value = n),\n          this.node.setAttribute("value", n);\n      }\n  }\n  function yr(t) {\n    t\n      ? (this.node.checked = !1)\n      : (this.node.checked = this.element.compare(\n          this.getValue(),\n          this.element.binding.getValue()\n        ));\n  }\n  function br(t) {\n    var e = this,\n      n = e.element,\n      i = e.node,\n      r = n.binding,\n      s = this.getValue(),\n      a = n.getAttribute("value");\n    if (Ga(s)) {\n      for (var o = s.length; o--; )\n        if (n.compare(a, s[o])) return void (r.isChecked = i.checked = !0);\n      r.isChecked = i.checked = !1;\n    } else r.isChecked = i.checked = n.compare(s, a);\n  }\n  function wr(t) {\n    for (\n      var e = t ? {} : hr(this.getValue() || ""),\n        n = this.node.style,\n        i = Za(e),\n        r = this.previous || [],\n        s = 0;\n      s < i.length;\n\n    ) {\n      if (i[s] in n) {\n        var a = e[i[s]].replace("!important", "");\n        n.setProperty(i[s], a, a.length !== e[i[s]].length ? "important" : "");\n      }\n      s++;\n    }\n    for (s = r.length; s--; )\n      !~i.indexOf(r[s]) && r[s] in n && n.setProperty(r[s], "", "");\n    this.previous = i;\n  }\n  function xr(t) {\n    if (\n      (this.style || (this.style = _e(this.name.substr(6))),\n      !t || this.node.style.getPropertyValue(this.style) === this.last)\n    ) {\n      var e = t ? "" : ai(this.getValue()),\n        n = e.replace("!important", "");\n      this.node.style.setProperty(\n        this.style,\n        n,\n        n.length !== e.length ? "important" : ""\n      ),\n        (this.last = this.node.style.getPropertyValue(this.style));\n    }\n  }\n  function kr(t) {\n    var e = t ? [] : lr(ai(this.getValue())),\n      n = this.node.className;\n    n = void 0 !== n.baseVal ? n.baseVal : n;\n    var i = lr(n),\n      r = this.previous || [],\n      s = e\n        .concat(\n          i.filter(function (t) {\n            return !~r.indexOf(t);\n          })\n        )\n        .join(" ");\n    s !== n &&\n      (h(this.node.className)\n        ? (this.node.className = s)\n        : (this.node.className.baseVal = s)),\n      (this.previous = e);\n  }\n  function _r(t) {\n    var e = this.name.substr(6),\n      n = this.node.className;\n    n = void 0 !== n.baseVal ? n.baseVal : n;\n    var i = lr(n),\n      r = t ? !1 : this.getValue();\n    this.inlineClass || (this.inlineClass = e),\n      r && !~i.indexOf(e)\n        ? i.push(e)\n        : !r && ~i.indexOf(e) && i.splice(i.indexOf(e), 1),\n      h(this.node.className)\n        ? (this.node.className = i.join(" "))\n        : (this.node.className.baseVal = i.join(" "));\n  }\n  function Er(t) {\n    if (!this.locked)\n      if (t)\n        this.useProperty && (this.node[this.propertyName] = !1),\n          this.node.removeAttribute(this.propertyName);\n      else if (this.useProperty) this.node[this.propertyName] = this.getValue();\n      else {\n        var e = this.getValue();\n        e\n          ? this.node.setAttribute(this.propertyName, h(e) ? e : "")\n          : this.node.removeAttribute(this.propertyName);\n      }\n  }\n  function Sr(t) {\n    t\n      ? this.node.getAttribute(this.name) === this.value &&\n        this.node.removeAttribute(this.name)\n      : ((this.value = ai(this.getString())),\n        this.node.setAttribute(this.name, this.value));\n  }\n  function Ar(t) {\n    t\n      ? this.value ===\n          this.node.getAttributeNS(\n            this.namespace,\n            this.name.slice(this.name.indexOf(":") + 1)\n          ) &&\n        this.node.removeAttributeNS(\n          this.namespace,\n          this.name.slice(this.name.indexOf(":") + 1)\n        )\n      : ((this.value = ai(this.getString())),\n        this.node.setAttributeNS(\n          this.namespace,\n          this.name.slice(this.name.indexOf(":") + 1),\n          this.value\n        ));\n  }\n  function Cr() {\n    return Pf;\n  }\n  function Or(t, e) {\n    if (If.test(t)) return [];\n    var n = e ? "svg" : "div";\n    return t\n      ? (Vf.innerHTML = "<" + n + " " + t + "></" + n + ">") &&\n          M(Vf.childNodes[0].attributes)\n      : [];\n  }\n  function Nr(t, e) {\n    for (var n = t.length; n--; ) if (t[n].name === e.name) return !1;\n    return !0;\n  }\n  function jr(t, e) {\n    for (var n = "xmlns:" + e; t; ) {\n      if (t.hasAttribute && t.hasAttribute(n)) return t.getAttribute(n);\n      t = t.parentNode;\n    }\n    return Tc[e];\n  }\n  function Tr() {\n    return Rf;\n  }\n  function Vr(t, e, n) {\n    0 === e\n      ? (t.value = !0)\n      : "true" === e\n      ? (t.value = !0)\n      : "false" === e || "0" === e\n      ? (t.value = !1)\n      : (t.value = e);\n    var i = t.element[t.flag];\n    return (\n      (t.element[t.flag] = t.value),\n      n &&\n        !t.element.attributes.binding &&\n        i !== t.value &&\n        t.element.recreateTwowayBinding(),\n      t.value\n    );\n  }\n  function Pr(t) {\n    Af.call(this, t);\n  }\n  function Mr() {\n    var t = this;\n    return this.torndown\n      ? (y(\n          "ractive.teardown() was called on a Ractive instance that was already torn down"\n        ),\n        Promise.resolve())\n      : ((this.shouldDestroy = !0),\n        Ir(this, function () {\n          return t.fragment.rendered ? t.unrender() : Promise.resolve();\n        }));\n  }\n  function Ir(t, e) {\n    (t.torndown = !0),\n      t.fragment.unbind(),\n      t._observers.slice().forEach(W),\n      t.el && t.el.__ractive_instances__ && V(t.el.__ractive_instances__, t);\n    var n = e();\n    return (\n      ec.teardown.fire(t),\n      n.then(function () {\n        ec.destruct.fire(t), t.viewmodel.teardown();\n      }),\n      n\n    );\n  }\n  function Rr(t, e) {\n    if (\n      ((t.applyValue = function (t) {\n        (this.parent.value[e] = t),\n          t && t.viewmodel\n            ? (this.link(t.viewmodel.getRactiveModel(), e),\n              this._link.markedAll())\n            : (this.link($a(Bo), e), this._link.markedAll());\n      }),\n      "root" === e)\n    ) {\n      var n = t.mark;\n      t.mark = function (t) {\n        this._marking ||\n          ((this._marking = !0), n.apply(this, t), (this._marking = !1));\n      };\n    }\n    return (\n      t.applyValue(t.parent.ractive[e], e),\n      (t._link.set = function (e) {\n        return t.applyValue(e);\n      }),\n      (t._link.applyValue = function (e) {\n        return t.applyValue(e);\n      }),\n      t._link\n    );\n  }\n  function Br(t, e) {\n    t._link && t._link.implicit && t._link.isDetached() && t.attach(e);\n    for (var n in t.childByKey)\n      if (t.value)\n        if (n in t.value) Br(t.childByKey[n], e);\n        else if (!t.childByKey[n]._link || t.childByKey[n]._link.isDetached()) {\n          var i = Ye(e, n);\n          i && t.childByKey[n].link(i, n, { implicit: !0 });\n        }\n  }\n  function Kr(t) {\n    t._link && t._link.implicit && t.unlink();\n    for (var e in t.childByKey) Kr(t.childByKey[e]);\n  }\n  function Lr(t, e, i) {\n    var r = (t.constructor["_" + i] || []).concat(n(e[i] || [])),\n      s = "on" === i ? "once" : i + "Once";\n    r.forEach(function (e) {\n      var n = e[0],\n        r = e[1];\n      u(r)\n        ? t[i](n, r)\n        : o(r) && u(r.handler) && t[r.once ? s : i](n, r.handler, $a(r));\n    });\n  }\n  function Dr(e, n) {\n    Fa.DEBUG && mo(),\n      zr(e),\n      Ur(e),\n      Lr(e, n, "on"),\n      !t(n, "delegate") &&\n        e.parent &&\n        e.parent.delegate !== e.delegate &&\n        (e.delegate = !1),\n      Ga(n.use) &&\n        e.use.apply(\n          e,\n          n.use.filter(function (t) {\n            return t.construct;\n          })\n        ),\n      ec.construct.fire(e, n),\n      n.onconstruct && n.onconstruct.call(e, nn(e), n);\n    for (var i = Uf.length; i--; ) {\n      var r = Uf[i];\n      e[r] = Ua($a(e.constructor[r] || null), n[r]);\n    }\n    for (i = $f.length; i--; ) {\n      var s = $f[i];\n      e[s] = Ua($a(e.constructor.prototype[s]), n[s]);\n    }\n    e._attributePartial &&\n      ((e.partials["extra-attributes"] = e._attributePartial),\n      delete e._attributePartial);\n    var a = new zf({\n      adapt: Fr(e, e.adapt, n),\n      data: ff.init(e.constructor, e, n),\n      ractive: e,\n    });\n    (e.adapt = a.adaptors), (e.viewmodel = a);\n    for (var o in e.computed) Vn.call(e, o, e.computed[o]);\n  }\n  function Fr(t, e, n) {\n    function i(e) {\n      return h(e) && ((e = w("adaptors", t, e)), e || p(_o(e, "adaptor"))), e;\n    }\n    e = e.map(i);\n    var r = j(n.adapt).map(i),\n      s = [e, r];\n    return (\n      t.parent && !t.isolated && s.push(t.parent.viewmodel.adaptors),\n      P.apply(null, s)\n    );\n  }\n  function zr(t) {\n    (t._guid = "r-" + qf++),\n      (t._subs = $a(null)),\n      (t._nsSubs = 0),\n      (t._config = {}),\n      (t.event = null),\n      (t._eventQueue = []),\n      (t._observers = []),\n      (t._children = []),\n      (t._children.byName = {}),\n      (t.children = t._children),\n      t.component || ((t.root = t), (t.parent = t.container = null));\n  }\n  function Ur(t) {\n    var e = t.component,\n      n = t.constructor.attributes;\n    if (n && e) {\n      var i = e.template,\n        r = i.m ? i.m.slice() : [],\n        s = r\n          .filter(function (t) {\n            return t.t === nu;\n          })\n          .map(function (t) {\n            return t.n;\n          });\n      n.required.forEach(function (t) {\n        ~s.indexOf(t) ||\n          y(\n            "Component \'" +\n              e.name +\n              "\' requires attribute \'" +\n              t +\n              "\' to be provided"\n          );\n      });\n      for (var a = n.optional.concat(n.required), o = [], u = r.length; u--; ) {\n        var h = r[u];\n        h.t !== nu || ~a.indexOf(h.n)\n          ? n.mapAll ||\n            (h.t !== Ru && h.t !== Bu && h.t !== Ku) ||\n            o.unshift(r.splice(u, 1)[0])\n          : n.mapAll\n          ? o.unshift({ t: nu, n: h.n, f: [{ t: Ho, r: "~/" + h.n }] })\n          : o.unshift(r.splice(u, 1)[0]);\n      }\n      o.length && (e.template = { t: i.t, e: i.e, f: i.f, m: r, p: i.p }),\n        (t._attributePartial = o);\n    }\n  }\n  function $r(t) {\n    this.item && this.removeChild(this.item);\n    var e = t.instance;\n    (t.anchor = this),\n      (t.up = this.up),\n      (t.name = t.nameOption || this.name),\n      (this.name = t.name),\n      e.isolated || e.viewmodel.attached(this.up),\n      this.rendered && Hr(this, t);\n  }\n  function qr(t) {\n    this.item === t && (Zr(this, t), (this.name = this.template.n));\n  }\n  function Hr(t, e) {\n    if (t.rendered) {\n      (e.shouldDestroy = !1),\n        (e.up = t.up),\n        (t.item = e),\n        (t.instance = e.instance);\n      var n = t.up.findNextNode(t);\n      e.instance.fragment.rendered && e.instance.unrender(),\n        (e.partials = e.instance.partials),\n        (e.instance.partials = Ua($a(e.partials), e.partials, t._partials)),\n        e.instance.fragment.unbind(!0),\n        (e.instance.fragment.componentParent = t.up),\n        e.instance.fragment.bind(e.instance.viewmodel),\n        t.attributes.forEach(Z),\n        t.eventHandlers.forEach(Z),\n        t.attributes.forEach(et),\n        t.eventHandlers.forEach(et);\n      var i = t.up.findParentNode();\n      ca(e.instance, i, i.contains(n) ? n : null, t.occupants),\n        e.lastBound !== t && (e.lastBound = t);\n    }\n  }\n  function Zr(t, e) {\n    t.rendered &&\n      ((e.shouldDestroy = !0),\n      e.instance.unrender(),\n      t.eventHandlers.forEach(st),\n      t.attributes.forEach(st),\n      t.eventHandlers.forEach(rt),\n      t.attributes.forEach(rt),\n      (e.instance.el = e.instance.anchor = null),\n      (e.instance.fragment.componentParent = null),\n      (e.up = null),\n      (e.anchor = null),\n      (t.item = null),\n      (t.instance = null));\n  }\n  function Wr() {\n    var t = Zf;\n    (Zf = []), t.forEach(Cn);\n  }\n  function Gr(t) {\n    t.deps.length || t.refs || t.links.length || t.teardown();\n  }\n  function Qr(t, e, n, i) {\n    void 0 === i && (i = {}),\n      e &&\n        e.f &&\n        e.f.s &&\n        (i.register\n          ? ((t.model = new Jf(n, e.f)), t.model.register(t))\n          : (t.fn = ft(e.f.s, e.f.r.length)));\n  }\n  function Yr(t, e, n, i) {\n    return (\n      void 0 === i && (i = {}),\n      e.f.r.map(function (t, e) {\n        var r;\n        return i.specialRef && (r = i.specialRef(t, e)) ? r : (r = Ye(n, t));\n      })\n    );\n  }\n  function Jr(t) {\n    t.model && t.model.unregister(t);\n  }\n  function Xr() {\n    this._ractive.binding.handleChange();\n  }\n  function ts(t, e, n) {\n    var i = t + "-bindingGroup";\n    return e[i] || (e[i] = new hd(i, e, n));\n  }\n  function es() {\n    var t = this,\n      e = this.bindings\n        .filter(function (t) {\n          return t.node && t.node.checked;\n        })\n        .map(function (t) {\n          return t.element.getAttribute("value");\n        }),\n      n = [];\n    return (\n      e.forEach(function (e) {\n        t.bindings[0].arrayContains(n, e) || n.push(e);\n      }),\n      n\n    );\n  }\n  function ns() {\n    Xr.call(this);\n    var t = this._ractive.binding.model.get();\n    this.value = void 0 == t ? "" : t;\n  }\n  function is(t) {\n    var e;\n    return function () {\n      var n = this;\n      e && clearTimeout(e),\n        (e = setTimeout(function () {\n          var t = n._ractive.binding;\n          t.rendered && Xr.call(n), (e = null);\n        }, t));\n    };\n  }\n  function rs(t) {\n    return t.selectedOptions\n      ? M(t.selectedOptions)\n      : t.options\n      ? M(t.options).filter(function (t) {\n          return t.selected;\n        })\n      : [];\n  }\n  function ss(t) {\n    return yd[t] || (yd[t] = []);\n  }\n  function as() {\n    var t = this.bindings.filter(function (t) {\n      return t.node.checked;\n    });\n    return t.length > 0 ? t[0].element.getAttribute("value") : void 0;\n  }\n  function os(t) {\n    return t && t.template.f && 1 === t.template.f.length && !t.template.f[0].s\n      ? t.template.f[0].t === Ho\n        ? !0\n        : (t.template.f[0].t === Zo &&\n            y("It is not possible create a binding using a triple mustache."),\n          !1)\n      : !1;\n  }\n  function us(t) {\n    var e = t.name,\n      n = t.attributeByName;\n    if (\n      "input" === e ||\n      "textarea" === e ||\n      "select" === e ||\n      n.contenteditable\n    ) {\n      var i = os(n.value),\n        r = os(n.contenteditable),\n        s = t.getAttribute("contenteditable");\n      if ((s || r) && i) return dd;\n      if ("input" === e) {\n        var a = t.getAttribute("type");\n        if ("radio" === a) {\n          var o = os(n.name),\n            u = os(n.checked);\n          return o && u\n            ? (y(\n                "A radio input can have two-way binding on its name attribute, or its checked attribute - not both",\n                { ractive: t.root }\n              ),\n              wd)\n            : o\n            ? wd\n            : u\n            ? bd\n            : null;\n        }\n        if ("checkbox" === a) {\n          var h = os(n.name),\n            l = os(n.checked);\n          return h && l ? ud : h ? fd : l ? ud : null;\n        }\n        return "file" === a && i\n          ? md\n          : "number" === a && i\n          ? gd\n          : "range" === a && i\n          ? gd\n          : i\n          ? pd\n          : null;\n      }\n      return "select" === e && i\n        ? t.getAttribute("multiple")\n          ? vd\n          : xd\n        : "textarea" === e && i\n        ? pd\n        : null;\n    }\n  }\n  function hs(t) {\n    var e = t.attributeByName.name;\n    return (\n      "radio" === t.getAttribute("type") &&\n      (e || {}).interpolator &&\n      t.getAttribute("value") === e.interpolator.model.get()\n    );\n  }\n  function ls(t) {\n    var e = t.toString();\n    return e ? " " + e : "";\n  }\n  function cs(t) {\n    var e = t.getAttribute("xmlns");\n    if (e) return e;\n    if ("svg" === t.name) return Cc;\n    var n = t.parent;\n    return n\n      ? "foreignobject" === n.name\n        ? Sc\n        : n.node.namespaceURI\n      : t.ractive.el.namespaceURI;\n  }\n  function fs() {\n    Ed = !0;\n  }\n  function ds() {\n    Sd = !0;\n  }\n  function ps() {\n    Ad = !0;\n  }\n  function ms(t) {\n    var e,\n      n = t.type,\n      i = t.currentTarget,\n      r = i._ractive && i._ractive.proxy,\n      s = t.target,\n      a = !0,\n      o = !1;\n    Ed = Sd = Ad = !1;\n    var u = t.stopPropagation,\n      h = t.stopImmediatePropagation,\n      l = t.preventDefault;\n    for (\n      t.stopPropagation = fs,\n        t.stopImmediatePropagation = ds,\n        t.preventDefault = ps;\n      a && s && s !== i;\n\n    ) {\n      var c = s._ractive && s._ractive.proxy;\n      if (\n        c &&\n        c.up.delegate === r &&\n        vs(t, s, i) &&\n        (e = c.listeners && c.listeners[n])\n      )\n        for (var f = e.length, d = 0; f > d; d++) {\n          if (((a = e[d].call(s, t) !== !1 && a), Sd)) {\n            a = !1;\n            break;\n          }\n          Ed && (a = !1), Ad && !o && ((o = !0), l.call(t));\n        }\n      s = s.parentNode || s.correspondingUseElement;\n    }\n    return (\n      a && (a = !Ed && !Sd),\n      Ed && u.call(t),\n      Sd && h.call(t),\n      (t.stopPropagation = u),\n      (t.stopImmediaitePropagation = h),\n      (t.preventDefault = l),\n      a\n    );\n  }\n  function vs(t, e, n) {\n    if (Cd && t instanceof Cd)\n      for (var i = e; i && i !== n; ) {\n        if (i.disabled) return !1;\n        i = i.parentNode || i.correspondingUseElement;\n      }\n    return !0;\n  }\n  function gs(t) {\n    var e,\n      n = this,\n      i = this._ractive.proxy;\n    if (i.listeners && (e = i.listeners[t.type]))\n      for (var r = e.length, s = 0; r > s; s++) e[s] && e[s].call(n, t);\n  }\n  function ys() {\n    var t = this._ractive.proxy;\n    Nl.start(), t.formBindings.forEach(bs), Nl.end();\n  }\n  function bs(t) {\n    t.model.set(t.resetValue);\n  }\n  function ws(t, e, n, i) {\n    if (n) {\n      var r = n[0];\n      if (r && 3 === r.nodeType) {\n        var s = r.nodeValue.indexOf(i);\n        n.shift(),\n          0 === s\n            ? r.nodeValue.length !== i.length &&\n              n.unshift(r.splitText(i.length))\n            : (r.nodeValue = i);\n      } else\n        (r = t.node = Ja.createTextNode(i)),\n          n[0] ? e.insertBefore(r, n[0]) : e.appendChild(r);\n      t.node = r;\n    } else t.node || (t.node = Ja.createTextNode(i)), e.appendChild(t.node);\n  }\n  function xs(t) {\n    t.base && t.base.unregister(t.proxy),\n      t.models &&\n        t.models.forEach(function (e) {\n          e.unregister && e.unregister(t);\n        });\n  }\n  function ks(t) {\n    var e,\n      n,\n      i = t.deps.length;\n    for (e = 0; i > e; e++)\n      (n = t.deps[e]),\n        n.pathChanged && n.pathChanged(),\n        n.fragment &&\n          n.fragment.pathModel &&\n          n.fragment.pathModel.applyValue(t.getKeypath());\n    for (i = t.children.length, e = 0; i > e; e++) ks(t.children[e]);\n  }\n  function _s(t, e) {\n    return e.r\n      ? Ye(t, e.r)\n      : e.x\n      ? new Jf(t, e.x)\n      : e.rx\n      ? new Dd(t, e.rx)\n      : void 0;\n  }\n  function Es(t) {\n    Ud.call(this, t);\n  }\n  function Ss(t) {\n    t.sp();\n    var e = Ot(t);\n    if (!e) return null;\n    var n = { key: e };\n    if ((t.sp(), !t.matchString(":"))) return null;\n    t.sp();\n    var i = t.read();\n    return i ? ((n.value = i.v), n) : null;\n  }\n  function As(t, e) {\n    var n = new Xd(t, { values: e });\n    return n.result;\n  }\n  function Cs(t) {\n    var e = t.template.f,\n      n = t.element.instance.viewmodel,\n      i = n.value;\n    if (1 === e.length && e[0].t === Ho) {\n      var r = _s(t.up, e[0]),\n        s = r.get(!1);\n      e[0].s\n        ? !o(s) || e[0].x\n          ? n.joinKey(S(t.name)).set(s)\n          : y(\n              "Cannot copy non-computed object value from static mapping \'" +\n                t.name +\n                "\'"\n            )\n        : ((t.model = r),\n          (t.link = n.createLink(t.name, r, e[0].r, { mapping: !0 })),\n          c(s) && !r.isReadonly && t.name in i && r.set(i[t.name])),\n        r !== t.model && r.unregister();\n    } else\n      (t.boundFragment = new Gp({ owner: t, template: e }).bind()),\n        (t.model = n.joinKey(S(t.name))),\n        t.model.set(t.boundFragment.valueOf()),\n        (t.boundFragment.bubble = function () {\n          Gp.prototype.bubble.call(t.boundFragment),\n            Nl.scheduleTask(function () {\n              t.boundFragment.update(), t.model.set(t.boundFragment.valueOf());\n            });\n        });\n  }\n  function Os(t, n, i) {\n    var r = Ns(t, n, i || {});\n    if (r) return r;\n    if ((r = El.fromId(n, { noThrow: !0 }))) {\n      var s = El.parseFor(r, t);\n      return s.p && e(t.partials, s.p), (t.partials[n] = s.t);\n    }\n  }\n  function Ns(e, n, i) {\n    var r = Vs(n, i.owner);\n    if (r) return r;\n    var s = x("partials", e, n);\n    if (s) {\n      r = s.partials[n];\n      var a;\n      if (u(r)) {\n        if (((a = r), a.styleSet)) return a;\n        (a = r.bind(s)), (a.isOwner = t(s.partials, n)), (r = a.call(e, El));\n      }\n      if (!r && "" !== r)\n        return void y(ko, n, "partial", "partial", { ractive: e });\n      if (!El.isParsed(r)) {\n        var o = El.parseFor(r, s);\n        o.p &&\n          y("Partials ({{>%s}}) cannot contain nested inline partials", n, {\n            ractive: e,\n          });\n        var h = a ? s : js(s, n);\n        h.partials[n] = r = o.t;\n      }\n      return a && (r._fn = a), r.v ? (dt(r), (s.partials[n] = r.t)) : r;\n    }\n  }\n  function js(e, n) {\n    return t(e.partials, n) ? e : Ts(e.constructor, n);\n  }\n  function Ts(e, n) {\n    return e ? (t(e.partials, n) ? e : Ts(e.Parent, n)) : void 0;\n  }\n  function Vs(e, n) {\n    if (n) {\n      if (n.template && n.template.p && !Ga(n.template.p) && t(n.template.p, e))\n        return n.template.p[e];\n      if (n.up && n.up.owner) return Vs(e, n.up.owner);\n    }\n  }\n  function Ps(t) {\n    Es.call(this, t);\n    var e = t.template;\n    e.t === su\n      ? (this.yielder = 1)\n      : e.t === Yo && ((this.type = Jo), (this.macro = t.macro));\n  }\n  function Ms(t, e) {\n    (t.partial = t.last = e), Is(t);\n    var n = { owner: t, template: t.partial };\n    t.yielder && (n.ractive = t.container.parent),\n      t.fn && (n.cssIds = t.fn._cssIds),\n      (t.fragment = new Gp(n));\n  }\n  function Is(t) {\n    t.template.c &&\n      ((t.partial = [{ t: Wo, n: Nu, f: t.partial }]),\n      Ua(t.partial[0], t.template.c),\n      t.yielder ? (t.partial[0].y = t) : (t.partial[0].z = t.template.z));\n  }\n  function Rs(t, e, n) {\n    var i = e;\n    return (\n      Ga(i)\n        ? (t.partial = i)\n        : i && o(i)\n        ? Ga(i.t)\n          ? (t.partial = i.t)\n          : h(i.template) &&\n            (t.partial = Ds(i.template, i.template, t.ractive).t)\n        : u(i) && i.styleSet\n        ? ((t.fn = i), t.fragment && (t.fragment.cssIds = i._cssIds))\n        : null != i &&\n          ((i = Os(t.ractive, "" + i, t.containerFragment || t.up)),\n          i\n            ? ((t.name = e),\n              i.styleSet\n                ? ((t.fn = i), t.fragment && (t.fragment.cssIds = i._cssIds))\n                : (t.partial = i))\n            : n\n            ? (t.partial = Ds("" + e, "" + e, t.ractive).t)\n            : (t.name = e)),\n      t.partial\n    );\n  }\n  function Bs(t) {\n    if ((Rs(this, t, !0), !this.initing)) {\n      if (\n        ((this.dirtyTemplate = !0),\n        (this.fnTemplate = this.partial),\n        !this.updating)\n      ) {\n        var e = Nl.start();\n        return this.bubble(), Nl.end(), e;\n      }\n      this.bubble(), Nl.promise();\n    }\n  }\n  function Ks(t, e) {\n    var n = this.fragment.aliases || (this.fragment.aliases = {});\n    e ? (n[e] = this._data.joinAll(S(t))) : (n[t] = this._data);\n  }\n  function Ls(e) {\n    var n = e.fn,\n      i = e.fragment,\n      r = (e.template = Ua({}, e.template)),\n      s = (e.handle = i.getContext({\n        proxy: e,\n        aliasLocal: Ks,\n        name: e.template.e || e.name,\n        attributes: {},\n        setTemplate: Bs.bind(e),\n        template: r,\n        macro: n,\n      }));\n    if (\n      (r.p || (r.p = {}),\n      (r.p = s.partials = Ua({}, r.p)),\n      t(r.p, "content") || (r.p.content = r.f || []),\n      Ga(n.attributes))\n    ) {\n      e._attrs = {};\n      var a = function () {\n        (this.dirty = !0), (e.dirtyAttrs = !0), e.bubble();\n      };\n      if (Ga(r.m)) {\n        var o = r.m;\n        (r.p[ip] = r.m =\n          o.filter(function (t) {\n            return !~n.attributes.indexOf(t.n);\n          })),\n          o\n            .filter(function (t) {\n              return ~n.attributes.indexOf(t.n);\n            })\n            .forEach(function (t) {\n              var n = new Gp({ template: t.f, owner: e });\n              (n.bubble = a), (n.findFirstNode = f), (e._attrs[t.n] = n);\n            });\n      } else r.p[ip] = [];\n    } else r.p[ip] = r.m;\n    e._attrs &&\n      (Za(e._attrs).forEach(function (t) {\n        e._attrs[t].bind();\n      }),\n      e.refreshAttrs()),\n      (e.initing = 1),\n      (e.proxy = n.call(e.ractive, s, s.attributes) || {}),\n      e.partial || (e.partial = []),\n      (e.fnTemplate = e.partial),\n      (e.initing = 0),\n      Is(e),\n      i.resetTemplate(e.partial);\n  }\n  function Ds(t, e, n) {\n    var i;\n    try {\n      i = El.parse(e, El.getParseOptions(n));\n    } catch (r) {\n      y("Could not parse partial from expression \'" + t + "\'\\n" + r.message);\n    }\n    return i || { t: [] };\n  }\n  function Fs(t) {\n    var e,\n      n,\n      i = t;\n    t: for (; i; ) {\n      for (n = 0; !n && i; ) {\n        if (\n          (i.owner.type === Yo && (n = i.owner),\n          i.owner.ractive && i.owner.ractive.delegate === !1)\n        )\n          break t;\n        i = i.parent || i.componentParent;\n      }\n      if (n.delegate === !1) break t;\n      for (e = n.delegate || n; i && !i.iterations; ) {\n        if (i.owner.ractive && i.owner.ractive.delegate === !1) break t;\n        i = i.parent || i.componentParent;\n      }\n    }\n    return e;\n  }\n  function zs(t, e, n, i) {\n    var r = t.context ? $s(t, e, n) : void 0;\n    (e.key = n),\n      (e.index = i),\n      (e.context = r),\n      t.source && (e.lastValue = r && r.get()),\n      e.idxModel && e.idxModel.applyValue(i),\n      e.keyModel && e.keyModel.applyValue(n),\n      e.pathModel &&\n        ((e.pathModel.context = r), e.pathModel.applyValue(r.getKeypath())),\n      e.rootModel &&\n        ((e.rootModel.context = r),\n        e.rootModel.applyValue(r.getKeypath(e.ractive.root)));\n    var s = e.aliases;\n    t.aliases &&\n      t.aliases.forEach(function (t) {\n        "." === t.x.r\n          ? (s[t.n] = r)\n          : "@index" === t.x.r\n          ? (s[t.n] = e.getIndex())\n          : "@key" === t.x.r\n          ? (s[t.n] = e.getKey())\n          : "@keypath" === t.x.r\n          ? (s[t.n] = e.getKeypath())\n          : "@rootpath" === t.x.r && (s[t.n] = e.getKeypath(!0));\n      });\n  }\n  function Us(t, e) {\n    var n = t.context.get() || [];\n    return e === !0\n      ? n.slice()\n      : n.map(function (t) {\n          return e.reduce(function (t, e) {\n            return t && t[e];\n          }, t);\n        });\n  }\n  function $s(t, e, n) {\n    if (t.source) {\n      var i,\n        r = t.source.model.get();\n      if (r.indexOf && ~(i = r.indexOf(t.context.joinKey(n).get())))\n        return t.source.model.joinKey(i);\n    }\n    return t.context.joinKey(n);\n  }\n  function qs(t) {\n    return !t || (Ga(t) && 0 === t.length) || (s(t) && 0 === Za(t).length);\n  }\n  function Hs(t, e) {\n    return e || Ga(t) ? Ou : a(t) ? ju : c(t) ? null : Au;\n  }\n  function Zs(t, e) {\n    var n = (t.containerFragment || t.up).findNextNode(t);\n    if (n) {\n      var i = ii();\n      e.render(i), n.parentNode.insertBefore(i, n);\n    } else e.render(t.up.findParentNode());\n  }\n  function Ws() {\n    pp = !Ja[mp];\n  }\n  function Gs() {\n    pp = !1;\n  }\n  function Qs() {\n    pp = !0;\n  }\n  function Ys(t) {\n    return t\n      ? (Ep.test(t) && (t = "-" + t),\n        t.replace(/[A-Z]/g, function (t) {\n          return "-" + t.toLowerCase();\n        }))\n      : "";\n  }\n  function Js(e, n, i) {\n    for (var r = n; r; ) {\n      if (t(r, e) && (c(i) || i ? r.rendering : r.unrendering)) return r[e];\n      r = r.component && r.component.ractive;\n    }\n    return n[e];\n  }\n  function Xs(t, e) {\n    var n = [];\n    if (null == t || "" === t) return n;\n    var i, r, s;\n    zp && (r = Up[e.tagName])\n      ? ((i = ta("DIV")),\n        (i.innerHTML = r[0] + t + r[1]),\n        (i = i.querySelector(".x")),\n        "SELECT" === i.tagName && (s = i.options[i.selectedIndex]))\n      : e.namespaceURI === Cc\n      ? ((i = ta("DIV")),\n        (i.innerHTML = \'<svg class="x">\' + t + "</svg>"),\n        (i = i.querySelector(".x")))\n      : "TEXTAREA" === e.tagName\n      ? ((i = mc("div")),\n        "undefined" != typeof i.textContent\n          ? (i.textContent = t)\n          : (i.innerHTML = t))\n      : ((i = ta(e.tagName)),\n        (i.innerHTML = t),\n        "SELECT" === i.tagName && (s = i.options[i.selectedIndex]));\n    for (var a; (a = i.firstChild); ) n.push(a), i.removeChild(a);\n    var o;\n    if ("SELECT" === e.tagName)\n      for (o = n.length; o--; ) n[o] !== s && (n[o].selected = !1);\n    return n;\n  }\n  function ta(t) {\n    return $p[t] || ($p[t] = mc(t));\n  }\n  function ea(e, n) {\n    var i,\n      r = x("components", e, n);\n    if (r && ((i = r.components[n]), i && !i.isInstance))\n      if (i["default"] && i["default"].isInstance) i = i["default"];\n      else if (!i.then && u(i)) {\n        var s = i.bind(r);\n        if (((s.isOwner = t(r.components, n)), (i = s()), !i))\n          return void y(ko, n, "component", "component", { ractive: e });\n        h(i) && (i = ea(e, i)), (i._fn = s), (r.components[n] = i);\n      }\n    return i;\n  }\n  function na(t, e) {\n    var n = e.template.p || {},\n      i = e.template.e,\n      r = Ua({}, e, {\n        template: { t: Yo, e: i },\n        macro: function (r) {\n          r.setTemplate(n["async-loading"] || []),\n            t.then(\n              function (t) {\n                (e.up.ractive.components[i] = t),\n                  n["async-loaded"]\n                    ? ((r.partials.component = [e.template]),\n                      r.setTemplate(n["async-loaded"]))\n                    : r.setTemplate([e.template]);\n              },\n              function (t) {\n                n["async-failed"]\n                  ? (r.aliasLocal("error", "error"),\n                    r.set("@local.error", t),\n                    r.setTemplate(n["async-failed"]))\n                  : r.setTemplate([]);\n              }\n            );\n        },\n      });\n    return new Ps(r);\n  }\n  function ia(t, e, n) {\n    var i = t.f.find(function (t) {\n      return t.t === e;\n    });\n    return i\n      ? i.n\n        ? [\n            {\n              t: 19,\n              n: 54,\n              f: i.f || [],\n              z: [{ n: i.n, x: { r: "__await." + n } }],\n            },\n          ]\n        : i.f || []\n      : [];\n  }\n  function ra(t) {\n    var e = t.template,\n      n = ia(e, Pu, "value"),\n      i = ia(e, Mu, "error"),\n      r = ia(e, Wo),\n      s = ia(e, Tu),\n      a = Ua({}, t, {\n        template: {\n          t: Yo,\n          m: [{ t: nu, n: "for", f: [{ t: Ho, r: e.r, rx: e.rx, x: e.x }] }],\n        },\n        macro: function (t, e) {\n          function a(e) {\n            e["for"] && u(e["for"].then)\n              ? (t.setTemplate(r),\n                e["for"].then(\n                  function (e) {\n                    t.set("@local.value", e), t.setTemplate(n);\n                  },\n                  function (e) {\n                    t.set("@local.error", e), t.setTemplate(i);\n                  }\n                ))\n              : c(e["for"])\n              ? t.setTemplate(s)\n              : (t.set("@local.value", e["for"]), t.setTemplate(n));\n          }\n          return t.aliasLocal("__await"), a(e), { update: a };\n        },\n      });\n    return (a.macro.attributes = ["for"]), new Ps(a);\n  }\n  function sa(t) {\n    if (h(t.template)) return new fp(t);\n    var e,\n      n,\n      i = t.template.t;\n    if (i === Yo) {\n      if (\n        ((n = t.template.e),\n        (e = x("partials", t.up.ractive, n)),\n        e && ((e = e.partials[n]), e.styleSet))\n      )\n        return (t.macro = e), new Ps(t);\n      if ((e = ea(t.up.ractive, n))) {\n        if (u(e.then)) return na(e, t);\n        if (u(e)) return new Hf(t, e);\n      }\n      return new (e = Wp[n.toLowerCase()] || _d)(t);\n    }\n    var r;\n    if (i === nu) {\n      var s = t.owner;\n      (!s || (s.type !== eu && s.type !== ru && s.type !== Yo)) &&\n        (s = zn(t.up)),\n        (t.element = s),\n        (r = s.type === ru || s.type === eu ? tp : Bf);\n    } else r = Zp[i];\n    if (!r) throw new Error("Unrecognised item type " + i);\n    return new r(t);\n  }\n  function aa(t, e, n, i) {\n    return (\n      void 0 === i && (i = 0),\n      t\n        .map(function (t) {\n          if (t.type === qo) return t.template;\n          if (t.fragment)\n            return t.fragment.iterations\n              ? t.fragment.iterations\n                  .map(function (t) {\n                    return aa(t.items, e, n, i);\n                  })\n                  .join("")\n              : aa(t.fragment.items, e, n, i);\n          var r = n + "-" + i++,\n            s = t.model || t.newModel;\n          return (\n            (e[r] = s ? (s.wrapper ? s.wrapperValue : s.get()) : void 0),\n            "${" + r + "}"\n          );\n        })\n        .join("")\n    );\n  }\n  function oa(t, e, n) {\n    void 0 === n && (n = {});\n    for (var i = 0; i < t.length; i++)\n      if (!n[t[i].n]) {\n        var r = _s(e, t[i].x);\n        (n[t[i].n] = r), r.reference();\n      }\n    return n;\n  }\n  function ua(t) {\n    var e,\n      n = sn(this);\n    if (t) {\n      if (this.rootModel) return this.rootModel;\n      (this.rootModel = new rp(\n        this.context.getKeypath(this.ractive.root),\n        this.context,\n        this.ractive.root\n      )),\n        (e = this.rootModel);\n    } else {\n      if (this.pathModel) return this.pathModel;\n      (this.pathModel = new rp(this.context.getKeypath(), this.context)),\n        (e = this.pathModel);\n    }\n    return n && n.context && n.getKeypath(t).registerChild(e), e;\n  }\n  function ha(t, e, n) {\n    var i = t.viewmodel.computed;\n    if (i)\n      for (var r in i)\n        r in t.viewmodel.value &&\n          i[r] &&\n          !i[r].isReadonly &&\n          i[r].set(t.viewmodel.value[r]);\n    bf.init(t.constructor, t, e),\n      Ga(e.use) &&\n        t.use.apply(\n          t,\n          e.use.filter(function (t) {\n            return !t.construct;\n          })\n        ),\n      ec.config.fire(t),\n      ec.init.begin(t);\n    var s = (t.fragment = la(t, n));\n    if ((s && s.bind(t.viewmodel), ec.init.end(t), Lr(t, e, "observe"), s)) {\n      var a = (t.el = t.target = ri(t.el || t.target));\n      if (a && !t.component) {\n        var o = t.render(a, t.append);\n        Fa.DEBUG_PROMISES &&\n          o["catch"](function (e) {\n            throw (\n              (b(\n                "Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;"\n              ),\n              y("An error happened during rendering", { ractive: t }),\n              m(e),\n              e)\n            );\n          });\n      }\n    }\n  }\n  function la(t, e) {\n    if ((void 0 === e && (e = {}), t.template)) {\n      var n = [].concat(t.constructor._cssIds || [], e.cssIds || []);\n      return new Gp({ owner: t, template: t.template, cssIds: n });\n    }\n  }\n  function ca(t, e, n, i) {\n    t.rendering = !0;\n    var r = Nl.start();\n    if (\n      (Nl.scheduleTask(function () {\n        return ec.render.fire(t);\n      }, !0),\n      t.fragment.rendered)\n    )\n      throw new Error(\n        "You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first"\n      );\n    if (\n      (t.destroyed &&\n        ((t.destroyed = !1), (t.fragment = la(t).bind(t.viewmodel))),\n      (n = ri(n) || t.anchor),\n      (t.el = t.target = e),\n      (t.anchor = n),\n      t.cssId && Ai(),\n      e)\n    )\n      if (\n        ((e.__ractive_instances__ || (e.__ractive_instances__ = [])).push(t), n)\n      ) {\n        var s = Ja.createDocumentFragment();\n        t.fragment.render(s), e.insertBefore(s, n);\n      } else t.fragment.render(e, i);\n    return (\n      Nl.end(),\n      (t.rendering = !1),\n      r.then(function () {\n        t.torndown || ec.complete.fire(t);\n      })\n    );\n  }\n  function fa(t, e) {\n    if (this.torndown)\n      return (\n        y(\n          "ractive.render() was called on a Ractive instance that was already torn down"\n        ),\n        Promise.resolve()\n      );\n    if (((t = ri(t) || this.el), !this.append && t)) {\n      var n = t.__ractive_instances__;\n      n && n.forEach(it), this.enhance || (t.innerHTML = "");\n    }\n    var i = this.enhance ? M(t.childNodes) : null,\n      r = ca(this, t, e, i);\n    if (i) for (; i.length; ) t.removeChild(i.pop());\n    return r;\n  }\n  function da(t) {\n    if (((t = t || {}), !o(t)))\n      throw new Error(\n        "The reset method takes either no arguments, or an object containing new data"\n      );\n    t = ff.init(this.constructor, this, { data: t });\n    var e = Nl.start(),\n      n = this.viewmodel.wrapper;\n    n && n.reset\n      ? n.reset(t) === !1 && this.viewmodel.set(t)\n      : this.viewmodel.set(t);\n    for (var i, r = bf.reset(this), s = r.length; s--; )\n      if (Yp.indexOf(r[s]) > -1) {\n        i = !0;\n        break;\n      }\n    return (\n      i &&\n        (ec.unrender.fire(this),\n        this.fragment.resetTemplate(this.template),\n        ec.render.fire(this),\n        ec.complete.fire(this)),\n      Nl.end(),\n      ec.reset.fire(this, t),\n      e\n    );\n  }\n  function pa(t, e, n, i) {\n    t.forEach(function (t) {\n      if (t.type === Jo && (t.refName === e || t.name === e))\n        return (t.inAttribute = n), void i.push(t);\n      if (t.fragment) pa(t.fragment.iterations || t.fragment.items, e, n, i);\n      else if (Ga(t.items)) pa(t.items, e, n, i);\n      else if (t.type === ru && t.instance) {\n        if (t.instance.partials[e]) return;\n        pa(t.instance.fragment.items, e, n, i);\n      }\n      t.type === Yo && Ga(t.attributes) && pa(t.attributes, e, !0, i);\n    });\n  }\n  function ma(t, e) {\n    var n = [];\n    pa(this.fragment.items, t, !1, n);\n    var i = Nl.start();\n    return (this.partials[t] = e), n.forEach(Q), Nl.end(), i;\n  }\n  function va(t) {\n    df.init(null, this, { template: t });\n    var e = this.transitionsEnabled;\n    this.transitionsEnabled = !1;\n    var n = this.component;\n    n && (n.shouldDestroy = !0), this.unrender(), n && (n.shouldDestroy = !1);\n    var i = Nl.start();\n    this.fragment.unbind().unrender(!0),\n      (this.fragment = new Gp({\n        template: this.template,\n        root: this,\n        owner: this,\n      }));\n    var r = ii();\n    return (\n      this.fragment.bind(this.viewmodel).render(r),\n      n && !n.external\n        ? this.fragment.findParentNode().insertBefore(r, n.findNextNode())\n        : this.el.insertBefore(r, this.anchor),\n      Nl.end(),\n      (this.transitionsEnabled = e),\n      i\n    );\n  }\n  function ga(t, e, n) {\n    var i = this,\n      r = o(t) ? e : n;\n    return an(un(i, t, e, r && r.isolated), r);\n  }\n  function ya(t, e, n) {\n    var i = l(e) ? -e : -1,\n      r = o(e) ? e : n;\n    return cn(this, t, i, r);\n  }\n  function ba(t, e) {\n    if (!h(t)) throw new TypeError(xo);\n    return an(\n      on(this, t, null, e && e.isolated).map(function (t) {\n        return [t, !t.get()];\n      }),\n      e\n    );\n  }\n  function wa() {\n    var t = [this.cssId].concat(\n        this.findAllComponents().map(function (t) {\n          return t.cssId;\n        })\n      ),\n      e = Za(\n        t.reduce(function (t, e) {\n          return (t[e] = !0), t;\n        }, {})\n      );\n    return Ci(e);\n  }\n  function xa() {\n    return this.fragment.toString(!0);\n  }\n  function ka() {\n    return this.fragment.toString(!1);\n  }\n  function _a(t, e, n) {\n    e instanceof HTMLElement || (s(e) && (n = e)),\n      (e = e || this.event.node),\n      (e && e._ractive) || p("No node was supplied for transition " + t),\n      (n = n || {});\n    var i = e._ractive.proxy,\n      r = new Lp({ owner: i, up: i.up, name: t, params: n });\n    r.bind();\n    var a = Nl.start();\n    return (\n      Nl.registerTransition(r),\n      Nl.end(),\n      a.then(function () {\n        return r.unbind();\n      }),\n      a\n    );\n  }\n  function Ea(t) {\n    var e = Nl.start();\n    return this.viewmodel.joinAll(S(t), { lastLink: !1 }).unlink(), Nl.end(), e;\n  }\n  function Sa() {\n    if (!this.fragment.rendered)\n      return (\n        y(\n          "ractive.unrender() was called on a Ractive instance that was not rendered"\n        ),\n        Promise.resolve()\n      );\n    this.unrendering = !0;\n    var t = Nl.start();\n    ec.unrendering.fire(this);\n    var e =\n      !this.component ||\n      (this.component.anchor || {}).shouldDestroy ||\n      this.component.shouldDestroy ||\n      this.shouldDestroy;\n    return (\n      this.fragment.unrender(e),\n      e && (this.destroyed = !0),\n      V(this.el.__ractive_instances__, this),\n      ec.unrender.fire(this),\n      Nl.end(),\n      (this.unrendering = !1),\n      t\n    );\n  }\n  function Aa(t, e) {\n    var n = Nl.start();\n    return (\n      t\n        ? this.viewmodel.joinAll(S(t)).updateFromBindings(e !== !1)\n        : this.viewmodel.updateFromBindings(!0),\n      Nl.end(),\n      n\n    );\n  }\n  function Ca() {\n    for (var t = this, e = [], n = arguments.length; n--; ) e[n] = arguments[n];\n    return (\n      e.forEach(function (e) {\n        e({ proto: t, Ractive: t.constructor.Ractive, instance: t });\n      }),\n      this\n    );\n  }\n  function Oa(t) {\n    return t && t instanceof this;\n  }\n  function Na(t, e) {\n    return this._cssModel.joinAll(S(t)).get(!0, e);\n  }\n  function ja(t, e) {\n    if (\n      rm.find(function (e) {\n        return e.id === t;\n      })\n    )\n      throw new Error(\n        "Extra styles with the id \'" + t + "\' have already been added."\n      );\n    rm.push({ id: t, css: e }),\n      this.css ||\n        Object.defineProperty(this, "css", {\n          configurable: !1,\n          writable: !1,\n          value: Ta,\n        }),\n      this._cssDef ||\n        (Object.defineProperty(this, "_cssDef", {\n          configurable: !0,\n          writable: !1,\n          value: { transform: !1, id: "Ractive.addStyle" },\n        }),\n        Si(this._cssDef)),\n      Di(this),\n      Ai(!0);\n  }\n  function Ta(t) {\n    return rm\n      .map(function (e) {\n        return (\n          "\\n/* ---- extra style " +\n          e.id +\n          " */\\n" +\n          (u(e.css) ? e.css(t) : e.css)\n        );\n      })\n      .join("");\n  }\n  function Va(t) {\n    return !!rm.find(function (e) {\n      return e.id === t;\n    });\n  }\n  function Pa(t, e, n) {\n    var i = o(t) ? e : n,\n      r = Ll;\n    return an(un({ viewmodel: r }, t, e, !0), i);\n  }\n  function Ma(t, e) {\n    return Ll.joinAll(S(t)).get(!0, e);\n  }\n  function Ia() {\n    for (var t = this, e = [], n = arguments.length; n--; ) e[n] = arguments[n];\n    return (\n      e.forEach(function (e) {\n        u(e) && e({ proto: t.prototype, Ractive: t.Ractive, instance: t });\n      }),\n      this\n    );\n  }\n  function Ra() {\n    for (var t = [], e = arguments.length; e--; ) t[e] = arguments[e];\n    return t.length ? t.reduce(Ka, this) : Ka(this);\n  }\n  function Ba(t, e) {\n    return void 0 === e && (e = {}), Ka(this, e, t);\n  }\n  function Ka(t, e, i) {\n    void 0 === e && (e = {});\n    var r,\n      s = u(i) && i;\n    if (e.prototype instanceof Fa)\n      throw new Error("Ractive no longer supports multiple inheritance.");\n    if (s) {\n      if (!(s.prototype instanceof t))\n        throw new Error(\n          "Only classes that inherit the appropriate prototype may be used with extend"\n        );\n      if (!sm.test(s.toString()))\n        throw new Error(\n          "Only classes that call super in their constructor may be used with extend"\n        );\n      r = s.prototype;\n    } else\n      (s = function (t) {\n        return this instanceof s\n          ? void (\n              (t && t.component === !0) ||\n              (Dr(this, t || {}), ha(this, t || {}, {}))\n            )\n          : new s(t);\n      }),\n        (r = $a(t.prototype)),\n        (r.constructor = s),\n        (s.prototype = r);\n    if (\n      (Ha(s, {\n        defaults: { value: r },\n        extend: { value: Ra, writable: !0, configurable: !0 },\n        extendWith: { value: Ba, writable: !0, configurable: !0 },\n        extensions: { value: [] },\n        use: { value: Ia },\n        isInstance: { value: Oa },\n        Parent: { value: t },\n        Ractive: { value: Fa },\n        styleGet: { value: Na.bind(s), configurable: !0 },\n        styleSet: { value: Ki.bind(s), configurable: !0 },\n      }),\n      bf.extend(t, r, e, s),\n      (s._on = (t._on || []).concat(n(e.on))),\n      (s._observe = (t._observe || []).concat(n(e.observe))),\n      t.extensions.push(s),\n      e.attributes)\n    ) {\n      var a;\n      (a = Ga(e.attributes)\n        ? { optional: e.attributes, required: [] }\n        : e.attributes),\n        Ga(a.required) || (a.required = []),\n        Ga(a.optional) || (a.optional = []),\n        (s.attributes = a);\n    }\n    return (\n      ff.extend(t, r, e, s),\n      qa(s, "helpers", { writable: !0, value: r.helpers }),\n      Ga(e.use) && s.use.apply(s, e.use),\n      s\n    );\n  }\n  function La(t, e) {\n    if (!u(t)) throw new Error("The macro must be a function");\n    return (\n      Ua(t, e),\n      Ha(t, {\n        extensions: { value: [] },\n        _cssIds: { value: [] },\n        cssData: { value: Ua($a(this.cssData), t.cssData || {}) },\n        styleGet: { value: Na.bind(t) },\n        styleSet: { value: Ki.bind(t) },\n      }),\n      qa(t, "_cssModel", { value: new hf(t) }),\n      t.css && Ui(t, t, t),\n      this.extensions.push(t),\n      t\n    );\n  }\n  function Da(t, e, n) {\n    return w(e, n, t);\n  }\n  function Fa(t) {\n    return this instanceof Fa\n      ? void ((t && t.component) || (Dr(this, t || {}), ha(this, t || {}, {})))\n      : new Fa(t);\n  }\n  Object.assign ||\n    (Object.assign = function (t) {\n      for (var e = [], n = arguments.length - 1; n-- > 0; )\n        e[n] = arguments[n + 1];\n      if (null == t)\n        throw new TypeError("Cannot convert undefined or null to object");\n      for (var i = Object(t), r = e.length, s = 0; r > s; s++) {\n        var a = e[s];\n        for (var o in a)\n          Object.prototype.hasOwnProperty.call(a, o) && (i[o] = a[o]);\n      }\n      return i;\n    });\n  var za = Object,\n    Ua = za.assign,\n    $a = za.create,\n    qa = za.defineProperty,\n    Ha = za.defineProperties,\n    Za = za.keys,\n    Wa = Object.prototype.toString,\n    Ga = Array.isArray;\n  if (\n    (Array.prototype.find ||\n      qa(Array.prototype, "find", {\n        value: function (e, n) {\n          if (null === this || c(this))\n            throw new TypeError(\n              "Array.prototype.find called on null or undefined"\n            );\n          if (!u(e)) throw new TypeError(e + " is not a function");\n          for (var i = Object(this), r = i.length >>> 0, s = 0; r > s; s++)\n            if (t(i, s) && e.call(n, i[s], s, i)) return i[s];\n          return void 0;\n        },\n        configurable: !0,\n        writable: !0,\n      }),\n    "undefined" != typeof window &&\n      window.Node &&\n      window.Node.prototype &&\n      !window.Node.prototype.contains &&\n      (Node.prototype.contains = function (t) {\n        var e = this;\n        if (!t) throw new TypeError("node required");\n        do if (e === t) return !0;\n        while ((t = t && t.parentNode));\n        return !1;\n      }),\n    "undefined" != typeof window &&\n      window.performance &&\n      !window.performance.now)\n  ) {\n    window.performance = window.performance || {};\n    var Qa = Date.now();\n    window.performance.now = function () {\n      return Date.now() - Qa;\n    };\n  }\n  var Ya = "undefined" != typeof window ? window : null,\n    Ja = Ya ? document : null,\n    Xa = !!Ja,\n    to = "undefined" != typeof __webpack_require__.g ? __webpack_require__.g : Ya,\n    eo =\n      "undefined" != typeof console && u(console.warn) && u(console.warn.apply),\n    no = Ja\n      ? Ja.implementation.hasFeature(\n          "http://www.w3.org/TR/SVG11/feature#BasicStructure",\n          "1.1"\n        )\n      : !1,\n    io = ["o", "ms", "moz", "webkit"];\n  if (!to.Promise) {\n    var ro = {},\n      so = {},\n      ao = {},\n      oo = (to.Promise = function (t) {\n        var e,\n          n,\n          i = [],\n          r = [],\n          s = ro,\n          a = function (t) {\n            return function (a) {\n              s === ro &&\n                ((e = a), (s = t), (n = ho(s === so ? i : r, e)), uo(n));\n            };\n          },\n          o = a(so),\n          h = a(ao);\n        try {\n          t(o, h);\n        } catch (l) {\n          h(l);\n        }\n        return {\n          then: function (t, e) {\n            var a = new oo(function (o, h) {\n              var l = function (t, e, n) {\n                u(t)\n                  ? e.push(function (e) {\n                      try {\n                        lo(a, t(e), o, h);\n                      } catch (n) {\n                        h(n);\n                      }\n                    })\n                  : e.push(n);\n              };\n              l(t, i, o), l(e, r, h), s !== ro && uo(n);\n            });\n            return a;\n          },\n          catch: function (t) {\n            return this.then(null, t);\n          },\n          finally: function (t) {\n            return this.then(\n              function (e) {\n                return t(), e;\n              },\n              function (e) {\n                throw (t(), e);\n              }\n            );\n          },\n        };\n      });\n    (oo.all = function (t) {\n      return new oo(function (e, n) {\n        var i,\n          r,\n          s = [];\n        if (!t.length) return void e(s);\n        var a = function (t, r) {\n          t && u(t.then)\n            ? t.then(function (t) {\n                (s[r] = t), --i || e(s);\n              }, n)\n            : ((s[r] = t), --i || e(s));\n        };\n        for (i = r = t.length; r--; ) a(t[r], r);\n      });\n    }),\n      (oo.race = function (t) {\n        return new oo(function (e, n) {\n          function i(t) {\n            s && ((s = !1), e(t));\n          }\n          function r(t) {\n            s && ((s = !1), n(t));\n          }\n          for (var s = !0, a = 0; a < t.length; a++)\n            t[a] && u(t[a].then) && t[a].then(i, r);\n        });\n      }),\n      (oo.resolve = function (t) {\n        return t && u(t.then)\n          ? t\n          : new oo(function (e) {\n              e(t);\n            });\n      }),\n      (oo.reject = function (t) {\n        return t && u(t.then)\n          ? t\n          : new oo(function (e, n) {\n              n(t);\n            });\n      });\n    var uo = function (t) {\n        setTimeout(t, 0);\n      },\n      ho = function (t, e) {\n        return function () {\n          for (var n = void 0; (n = t.shift()); ) n(e);\n        };\n      },\n      lo = function (t, e, n, i) {\n        var r;\n        if (e === t)\n          throw new TypeError(\n            "A promise\'s fulfillment handler cannot return the same promise"\n          );\n        if (e instanceof oo) e.then(n, i);\n        else if (e && (o(e) || u(e))) {\n          try {\n            r = e.then;\n          } catch (s) {\n            return void i(s);\n          }\n          if (u(r)) {\n            var a,\n              h = function (e) {\n                a || ((a = !0), lo(t, e, n, i));\n              },\n              l = function (t) {\n                a || ((a = !0), i(t));\n              };\n            try {\n              r.call(e, h, l);\n            } catch (s) {\n              if (!a) return i(s), void (a = !0);\n            }\n          } else n(e);\n        } else n(e);\n      };\n  }\n  if (\n    !(\n      "undefined" == typeof window ||\n      (window.requestAnimationFrame && window.cancelAnimationFrame)\n    )\n  ) {\n    var co = 0;\n    (window.requestAnimationFrame = function (t) {\n      var e = Date.now(),\n        n = Math.max(0, 16 - (e - co)),\n        i = window.setTimeout(function () {\n          t(e + n);\n        }, n);\n      return (co = e + n), i;\n    }),\n      (window.cancelAnimationFrame = function (t) {\n        clearTimeout(t);\n      });\n  }\n  var fo,\n    po,\n    mo,\n    vo = {\n      el: void 0,\n      append: !1,\n      delegate: !0,\n      enhance: !1,\n      template: null,\n      allowExpressions: !0,\n      delimiters: ["{{", "}}"],\n      tripleDelimiters: ["{{{", "}}}"],\n      staticDelimiters: ["[[", "]]"],\n      staticTripleDelimiters: ["[[[", "]]]"],\n      csp: !0,\n      interpolate: !1,\n      preserveWhitespace: !1,\n      preserveStandaloneSections: !1,\n      sanitize: !1,\n      stripComments: !0,\n      contextLines: 0,\n      data: $a(null),\n      helpers: $a(null),\n      computed: $a(null),\n      syncComputedChildren: !1,\n      resolveInstanceMembers: !1,\n      warnAboutAmbiguity: !1,\n      adapt: [],\n      isolated: !0,\n      twoway: !0,\n      lazy: !1,\n      noIntro: !1,\n      noOutro: !1,\n      transitionsEnabled: !0,\n      complete: void 0,\n      nestedTransitions: !0,\n      css: null,\n      noCSSTransform: !1,\n    },\n    go = {\n      linear: function (t) {\n        return t;\n      },\n      easeIn: function (t) {\n        return Math.pow(t, 3);\n      },\n      easeOut: function (t) {\n        return Math.pow(t - 1, 3) + 1;\n      },\n      easeInOut: function (t) {\n        return (t /= 0.5) < 1\n          ? 0.5 * Math.pow(t, 3)\n          : 0.5 * (Math.pow(t - 2, 3) + 2);\n      },\n    },\n    yo = {};\n  if (eo) {\n    var bo = [\n        "%cRactive.js %c1.4.0-edge %cin debug mode, %cmore...",\n        "color: rgb(114, 157, 52); font-weight: normal;",\n        "color: rgb(85, 85, 85); font-weight: normal;",\n        "color: rgb(85, 85, 85); font-weight: normal;",\n        "color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;",\n      ],\n      wo =\n        "You\'re running Ractive 1.4.0-edge in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\\n\\nTo disable debug mode, add this line at the start of your app:\\n  Ractive.DEBUG = false;\\n\\nTo disable debug mode when your app is minified, add this snippet:\\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\\n\\nGet help and support:\\n  http://ractive.js.org\\n  http://stackoverflow.com/questions/tagged/ractivejs\\n  http://groups.google.com/forum/#!forum/ractive-js\\n  http://twitter.com/ractivejs\\n\\nFound a bug? Raise an issue:\\n  https://github.com/ractivejs/ractive/issues\\n\\n";\n    (mo = function () {\n      if (Fa.WELCOME_MESSAGE === !1) return void (mo = f);\n      var t = "WELCOME_MESSAGE" in Fa ? Fa.WELCOME_MESSAGE : wo,\n        e = !!console.groupCollapsed;\n      e && console.groupCollapsed.apply(console, bo),\n        console.log(t),\n        e && console.groupEnd(bo),\n        (mo = f);\n    }),\n      (po = function (t, e) {\n        if ((mo(), o(e[e.length - 1]))) {\n          var n = e.pop(),\n            i = n ? n.ractive : null;\n          if (i) {\n            var r;\n            i.component && (r = i.component.name) && (t = "<" + r + "> " + t);\n            var s;\n            (s =\n              n.node || (i.fragment && i.fragment.rendered && i.find("*"))) &&\n              e.push(s);\n          }\n        }\n        console.warn.apply(\n          console,\n          [\n            "%cRactive.js: %c" + t,\n            "color: rgb(114, 157, 52);",\n            "color: rgb(85, 85, 85);",\n          ].concat(e)\n        );\n      }),\n      (fo = function () {\n        console.log.apply(console, arguments);\n      });\n  } else po = fo = mo = f;\n  var xo = "Bad arguments",\n    ko = \'A function was specified for "%s" %s, but no %s was returned\',\n    _o = function (t, e) {\n      return (\n        \'Missing "\' +\n        t +\n        \'" \' +\n        e +\n        " plugin. You may need to download a plugin via http://ractive.js.org/integrations/#" +\n        e +\n        "s"\n      );\n    },\n    Eo = {\n      number: function (t, e) {\n        if (!r(t) || !r(e)) return null;\n        (t = +t), (e = +e);\n        var n = e - t;\n        return n\n          ? function (e) {\n              return t + e * n;\n            }\n          : function () {\n              return t;\n            };\n      },\n      array: function (t, e) {\n        var n, i;\n        if (!Ga(t) || !Ga(e)) return null;\n        var r = [],\n          s = [];\n        for (i = n = Math.min(t.length, e.length); i--; ) s[i] = k(t[i], e[i]);\n        for (i = n; i < t.length; i += 1) r[i] = t[i];\n        for (i = n; i < e.length; i += 1) r[i] = e[i];\n        return function (t) {\n          for (var e = n; e--; ) r[e] = s[e](t);\n          return r;\n        };\n      },\n      object: function (e, n) {\n        if (!s(e) || !s(n)) return null;\n        var i = [],\n          r = {},\n          a = {},\n          o = function (s) {\n            t(e, s) &&\n              (t(n, s)\n                ? (i.push(s),\n                  (a[s] =\n                    k(e[s], n[s]) ||\n                    function () {\n                      return n[s];\n                    }))\n                : (r[s] = e[s]));\n          };\n        for (var u in e) o(u);\n        for (var h in n) t(n, h) && !t(e, h) && (r[h] = n[h]);\n        var l = i.length;\n        return function (t) {\n          for (var e = l; e--; ) {\n            var n = i[e];\n            r[n] = a[n](t);\n          }\n          return r;\n        };\n      },\n    },\n    So = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g,\n    Ao = /([^\\\\](?:\\\\\\\\)*)\\./,\n    Co = /\\\\|\\./g,\n    Oo = /((?:\\\\)+)\\1|\\\\(\\.)/g,\n    No = Function.prototype.bind,\n    jo = { early: [], mark: [] },\n    To = { early: [], mark: [] },\n    Vo = { virtual: !1 },\n    Po = function (t) {\n      (this.deps = []),\n        (this.children = []),\n        (this.childByKey = {}),\n        (this.links = []),\n        (this.bindings = []),\n        t && ((this.parent = t), (this.root = t.root));\n    },\n    Mo = Po.prototype;\n  (Mo.addShuffleTask = function (t, e) {\n    void 0 === e && (e = "early"), jo[e].push(t);\n  }),\n    (Mo.addShuffleRegister = function (t, e) {\n      void 0 === e && (e = "early"), To[e].push({ model: this, item: t });\n    }),\n    (Mo.downstreamChanged = function () {}),\n    (Mo.findMatches = function (t) {\n      var e,\n        n,\n        i = t.length,\n        r = [this],\n        s = function () {\n          var i = t[n];\n          "*" === i\n            ? ((e = []),\n              r.forEach(function (t) {\n                e.push.apply(e, t.getValueChildren(t.get()));\n              }))\n            : (e = r.map(function (t) {\n                return t.joinKey(i);\n              })),\n            (r = e);\n        };\n      for (n = 0; i > n; n += 1) s();\n      return e;\n    }),\n    (Mo.getKeypath = function (t) {\n      if (t !== this.ractive && this._link)\n        return this._link.target.getKeypath(t);\n      if (!this.keypath) {\n        var e = this.parent && this.parent.getKeypath(t);\n        this.keypath = e\n          ? this.parent.getKeypath(t) + "." + _(this.key)\n          : _(this.key);\n      }\n      return this.keypath;\n    }),\n    (Mo.getValueChildren = function (t) {\n      var e,\n        n = this;\n      Ga(t)\n        ? ((e = []),\n          "length" in this &&\n            this.length !== t.length &&\n            e.push(this.joinKey("length")),\n          t.forEach(function (t, i) {\n            e.push(n.joinKey(i));\n          }))\n        : s(t) || u(t)\n        ? (e = Za(t).map(function (t) {\n            return n.joinKey(_(t));\n          }))\n        : null != t && (e = []);\n      var i = this.computed;\n      return (\n        i &&\n          e.push.apply(\n            e,\n            Za(i).map(function (t) {\n              return n.joinKey(t);\n            })\n          ),\n        e\n      );\n    }),\n    (Mo.getVirtual = function (t) {\n      var e = this,\n        n = this.get(t, { virtual: !1 });\n      if (a(n)) {\n        for (var i = Ga(n) ? [] : $a(null), r = Za(n), s = r.length; s--; ) {\n          var o = e.childByKey[r[s]];\n          o\n            ? o._link\n              ? (i[r[s]] = o._link.getVirtual())\n              : (i[r[s]] = o.getVirtual())\n            : (i[r[s]] = n[r[s]]);\n        }\n        for (s = this.children.length; s--; ) {\n          var u = e.children[s];\n          u.key in i || !u._link || (i[u.key] = u._link.getVirtual());\n        }\n        if (this.computed)\n          for (r = Za(this.computed), s = r.length; s--; )\n            i[r[s]] = e.computed[r[s]].get();\n        return i;\n      }\n      return n;\n    }),\n    (Mo.has = function (t) {\n      var e = this;\n      if (this._link) return this._link.has(t);\n      var n = this.get(!1, Vo);\n      if (!n) return !1;\n      if (((t = A(t)), (u(n) || s(n)) && t in n)) return !0;\n      var i = this.computed;\n      return i && t in this.computed\n        ? !0\n        : ((i = this.root.ractive && this.root.ractive.computed),\n          i &&\n            Za(i).forEach(function (t) {\n              return i[t].pattern && i[t].pattern.test(e.getKeypath())\n                ? !0\n                : void 0;\n            }),\n          !1);\n    }),\n    (Mo.joinAll = function (t, e) {\n      for (var n = this, i = 0; i < t.length; i += 1) {\n        if (\n          e &&\n          e.lastLink === !1 &&\n          i + 1 === t.length &&\n          n.childByKey[t[i]] &&\n          n.childByKey[t[i]]._link\n        )\n          return n.childByKey[t[i]];\n        n = n.joinKey(t[i], e);\n      }\n      return n;\n    }),\n    (Mo.notifyUpstream = function (t) {\n      for (var e = this, n = this.parent, i = t || [this.key]; n; )\n        n.patterns &&\n          n.patterns.forEach(function (t) {\n            return t.notify(i.slice());\n          }),\n          i.unshift(n.key),\n          n.links.forEach(function (t) {\n            return t.notifiedUpstream(i, e.root);\n          }),\n          n.deps.forEach(function (t) {\n            return t.handleChange(i);\n          }),\n          n.downstreamChanged(t),\n          (n = n.parent);\n    }),\n    (Mo.rebind = function (t, e, n) {\n      var i = this;\n      if ((this._link && this._link.rebind(t, e, !1), t !== this)) {\n        for (var r = this.deps.length; r--; )\n          i.deps[r].rebind && i.deps[r].rebind(t, e, n);\n        for (r = this.links.length; r--; ) {\n          var s = i.links[r];\n          s.owner && s.owner._link && s.relinking(t, n);\n        }\n        for (r = this.children.length; r--; ) {\n          var a = i.children[r];\n          a.rebind(t ? t.joinKey(a.key) : void 0, a._link || a, n),\n            i.dataModel &&\n              i.addShuffleTask(function () {\n                return U(i, i.retrieve());\n              }, "early");\n        }\n        for (r = this.bindings.length; r--; ) i.bindings[r].rebind(t, e, n);\n      }\n    }),\n    (Mo.reference = function () {\n      "refs" in this ? this.refs++ : (this.refs = 1);\n    }),\n    (Mo.register = function (t) {\n      this.deps.push(t);\n    }),\n    (Mo.registerLink = function (t) {\n      C(this.links, t);\n    }),\n    (Mo.registerPatternObserver = function (t) {\n      (this.patterns || (this.patterns = [])).push(t), this.register(t);\n    }),\n    (Mo.registerTwowayBinding = function (t) {\n      this.bindings.push(t);\n    }),\n    (Mo.unreference = function () {\n      "refs" in this && this.refs--;\n    }),\n    (Mo.unregister = function (t) {\n      V(this.deps, t);\n    }),\n    (Mo.unregisterLink = function (t) {\n      V(this.links, t);\n    }),\n    (Mo.unregisterPatternObserver = function (t) {\n      V(this.patterns, t), this.unregister(t);\n    }),\n    (Mo.unregisterTwowayBinding = function (t) {\n      V(this.bindings, t);\n    }),\n    (Mo.updateFromBindings = function (t) {\n      for (var e = this, n = this.bindings.length; n--; ) {\n        var i = e.bindings[n].getValue();\n        i !== e.value && e.set(i);\n      }\n      if (!this.bindings.length) {\n        var r = D(this.deps);\n        r && r.value !== this.value && this.set(r.value);\n      }\n      t &&\n        (this.children.forEach(L),\n        this.links.forEach(L),\n        this._link && this._link.updateFromBindings(t));\n    });\n  var Io,\n    Ro = [],\n    Bo = {\n      key: "@missing",\n      animate: f,\n      applyValue: f,\n      get: f,\n      getKeypath: function () {\n        return this.key;\n      },\n      joinAll: function () {\n        return this;\n      },\n      joinKey: function () {\n        return this;\n      },\n      mark: f,\n      registerLink: f,\n      shufle: f,\n      set: f,\n      unregisterLink: f,\n    };\n  Bo.parent = Bo;\n  var Ko = (function (e) {\n    function n(t, n, i, r) {\n      e.call(this, t),\n        (this.owner = n),\n        (this.target = i),\n        (this.key = c(r) ? n.key : r),\n        n && n.isLink && (this.sourcePath = n.sourcePath + "." + this.key),\n        i && i.registerLink(this),\n        t && (this.isReadonly = t.isReadonly),\n        (this.isLink = !0);\n    }\n    e && (n.__proto__ = e);\n    var i = (n.prototype = Object.create(e && e.prototype));\n    return (\n      (i.constructor = n),\n      (i.animate = function (t, e, n, i) {\n        return this.target.animate(t, e, n, i);\n      }),\n      (i.applyValue = function (t) {\n        this.boundValue && (this.boundValue = null), this.target.applyValue(t);\n      }),\n      (i.attach = function (t) {\n        var e = Ye(t, this.key);\n        e ? this.relinking(e, !1) : this.owner.unlink();\n      }),\n      (i.detach = function () {\n        this.relinking(Bo, !1);\n      }),\n      (i.get = function (t, e) {\n        void 0 === e && (e = {}),\n          t && (H(this), (e.unwrap = "unwrap" in e ? e.unwrap : !0));\n        var n = "shouldBind" in e ? e.shouldBind : !0;\n        return (\n          (e.shouldBind =\n            this.mapping && this.target.parent && this.target.parent.isRoot),\n          K(this, this.target.get(!1, e), n)\n        );\n      }),\n      (i.getKeypath = function (t) {\n        return t && t !== this.root.ractive\n          ? this.target.getKeypath(t)\n          : e.prototype.getKeypath.call(this, t);\n      }),\n      (i.handleChange = function () {\n        this.deps.forEach(Q), this.links.forEach(Q), this.notifyUpstream();\n      }),\n      (i.isDetached = function () {\n        return this.virtual && this.target === Bo;\n      }),\n      (i.joinKey = function (e) {\n        if (c(e) || "" === e) return this;\n        if (!t(this.childByKey, e)) {\n          var i = new n(this, this, this.target.joinKey(e), e);\n          this.children.push(i), (this.childByKey[e] = i);\n        }\n        return this.childByKey[e];\n      }),\n      (i.mark = function (t) {\n        this.target.mark(t);\n      }),\n      (i.marked = function () {\n        this.boundValue && (this.boundValue = null),\n          this.links.forEach(X),\n          this.deps.forEach(Q);\n      }),\n      (i.markedAll = function () {\n        this.children.forEach(tt), this.marked();\n      }),\n      (i.notifiedUpstream = function (t, e) {\n        var n = this;\n        if (\n          (this.links.forEach(function (e) {\n            return e.notifiedUpstream(t, n.root);\n          }),\n          this.deps.forEach(Q),\n          t && this.rootLink)\n        ) {\n          var i = this.parent;\n          if (this.root !== e) {\n            var r = t.slice(1);\n            r.unshift(this.key), this.notifyUpstream(r);\n          } else if (i && i !== this.target) {\n            var s = [i.key, this.key];\n            i.links.forEach(function (t) {\n              return t.notifiedUpstream(s, i.root);\n            }),\n              i.deps.forEach(function (t) {\n                return t.handleChange(s);\n              }),\n              i.notifyUpstream(s);\n          }\n        }\n      }),\n      (i.relinked = function () {\n        this.target.registerLink(this),\n          this.children.forEach(function (t) {\n            return t.relinked();\n          });\n      }),\n      (i.relinking = function (t, e) {\n        var n = this;\n        this.rootLink &&\n          this.sourcePath &&\n          (t = ht(this.sourcePath, t, this.target)),\n          t &&\n            this.target !== t &&\n            (this.target && this.target.unregisterLink(this),\n            (this.target = t),\n            this.children.forEach(function (n) {\n              n.relinking(t.joinKey(n.key), e);\n            }),\n            e || (this.keypath = void 0),\n            this.rootLink &&\n              this.addShuffleTask(function () {\n                n.relinked(), e || (n.markedAll(), n.notifyUpstream());\n              }));\n      }),\n      (i.set = function (t) {\n        this.boundValue && (this.boundValue = null), this.target.set(t);\n      }),\n      (i.shuffle = function (t) {\n        this.shuffling ||\n          (this.target.shuffling\n            ? z(this, t, !0)\n            : this.target.shuffle\n            ? this.target.shuffle(t)\n            : this.target.mark());\n      }),\n      (i.source = function () {\n        return this.target.source ? this.target.source() : this.target;\n      }),\n      (i.teardown = function () {\n        this._link && this._link.teardown(),\n          this.target.unregisterLink(this),\n          this.children.forEach(it);\n      }),\n      n\n    );\n  })(Po);\n  (Po.prototype.link = function (t, e, n) {\n    var i = this._link || new Ko(this.parent, this, t, this.key);\n    return (\n      (i.implicit = n && n.implicit),\n      (i.mapping = n && n.mapping),\n      (i.sourcePath = e),\n      (i.rootLink = !0),\n      this._link && this._link.relinking(t, !1),\n      this.rebind(i, this, !1),\n      F(),\n      (this._link = i),\n      i.markedAll(),\n      this.notifyUpstream(),\n      i\n    );\n  }),\n    (Po.prototype.unlink = function () {\n      if (this._link) {\n        var t = this._link;\n        (this._link = void 0),\n          t.rebind(this, t, !1),\n          F(),\n          t.teardown(),\n          this.notifyUpstream();\n      }\n    });\n  var Lo = $a(null),\n    Do = 4,\n    Fo = /^\\s+/,\n    zo = function (t) {\n      (this.name = "ParseError"), (this.message = t);\n      try {\n        throw new Error(t);\n      } catch (e) {\n        this.stack = e.stack;\n      }\n    };\n  zo.prototype = Error.prototype;\n  var Uo = function (t, e) {\n    var n,\n      i = 0;\n    (this.str = t),\n      (this.options = e || {}),\n      (this.pos = 0),\n      (this.lines = this.str.split("\\n")),\n      (this.lineEnds = this.lines.map(function (t) {\n        var e = i + t.length + 1;\n        return (i = e), e;\n      }, 0)),\n      this.init && this.init(t, e);\n    for (var r = []; this.pos < this.str.length && (n = this.read()); )\n      r.push(n);\n    (this.leftover = this.remaining()),\n      (this.result = this.postProcess ? this.postProcess(r, e) : r);\n  };\n  (Uo.prototype = {\n    read: function (t) {\n      var e,\n        n,\n        i = this;\n      t || (t = this.converters);\n      var r = this.pos,\n        s = t.length;\n      for (e = 0; s > e; e += 1) if (((i.pos = r), (n = t[e](i)))) return n;\n      return null;\n    },\n    getContextMessage: function (t, e) {\n      var n = this.getLinePos(t),\n        i = n[0],\n        r = n[1];\n      if (-1 === this.options.contextLines)\n        return [i, r, e + " at line " + i + " character " + r];\n      var s = this.lines[i - 1],\n        a = "",\n        o = "";\n      if (this.options.contextLines) {\n        var u =\n          i - 1 - this.options.contextLines < 0\n            ? 0\n            : i - 1 - this.options.contextLines;\n        (a = this.lines\n          .slice(u, i - 1 - u)\n          .join("\\n")\n          .replace(/\\t/g, "  ")),\n          (o = this.lines\n            .slice(i, i + this.options.contextLines)\n            .join("\\n")\n            .replace(/\\t/g, "  ")),\n          a && (a += "\\n"),\n          o && (o = "\\n" + o);\n      }\n      var h = 0,\n        l =\n          a +\n          s.replace(/\\t/g, function (t, e) {\n            return r > e && (h += 1), "  ";\n          }) +\n          "\\n" +\n          new Array(r + h).join(" ") +\n          "^----" +\n          o;\n      return [i, r, e + " at line " + i + " character " + r + ":\\n" + l];\n    },\n    getLinePos: function (t) {\n      for (var e = this, n = 0, i = 0; t >= this.lineEnds[n]; )\n        (i = e.lineEnds[n]), (n += 1);\n      var r = t - i;\n      return [n + 1, r + 1, t];\n    },\n    error: function um(t) {\n      var e = this.getContextMessage(this.pos, t),\n        n = e[0],\n        i = e[1],\n        r = e[2],\n        um = new zo(r);\n      throw ((um.line = n), (um.character = i), (um.shortMessage = t), um);\n    },\n    matchString: function (t) {\n      return this.str.substr(this.pos, t.length) === t\n        ? ((this.pos += t.length), t)\n        : void 0;\n    },\n    matchPattern: function (t) {\n      var e;\n      return (e = t.exec(this.remaining()))\n        ? ((this.pos += e[0].length), e[1] || e[0])\n        : void 0;\n    },\n    sp: function () {\n      this.matchPattern(Fo);\n    },\n    remaining: function () {\n      return this.str.substring(this.pos);\n    },\n    nextChar: function () {\n      return this.str.charAt(this.pos);\n    },\n    warn: function (t) {\n      var e = this.getContextMessage(this.pos, t)[2];\n      y(e);\n    },\n  }),\n    (Uo.extend = function (e) {\n      var n = this,\n        i = function (t, e) {\n          Uo.call(this, t, e);\n        };\n      i.prototype = $a(n.prototype);\n      for (var r in e) t(e, r) && (i.prototype[r] = e[r]);\n      return (i.extend = Uo.extend), i;\n    });\n  var $o,\n    qo = 1,\n    Ho = 2,\n    Zo = 3,\n    Wo = 4,\n    Go = 5,\n    Qo = 6,\n    Yo = 7,\n    Jo = 8,\n    Xo = 9,\n    tu = 10,\n    eu = 11,\n    nu = 13,\n    iu = 14,\n    ru = 15,\n    su = 16,\n    au = 17,\n    ou = 18,\n    uu = 19,\n    hu = 55,\n    lu = 20,\n    cu = 21,\n    fu = 22,\n    du = 23,\n    pu = 24,\n    mu = 25,\n    vu = 26,\n    gu = 27,\n    yu = 30,\n    bu = 31,\n    wu = 32,\n    xu = 33,\n    ku = 34,\n    _u = 35,\n    Eu = 36,\n    Su = 40,\n    Au = 50,\n    Cu = 51,\n    Ou = 52,\n    Nu = 53,\n    ju = 54,\n    Tu = 60,\n    Vu = 61,\n    Pu = 62,\n    Mu = 63,\n    Iu = 70,\n    Ru = 71,\n    Bu = 72,\n    Ku = 73,\n    Lu = 74,\n    Du = /^[^\\s=]+/,\n    Fu = /^\\s+/,\n    zu =\n      /^(\\/(?:[^\\n\\r\\u2028\\u2029/\\\\[]|\\\\.|\\[(?:[^\\n\\r\\u2028\\u2029\\]\\\\]|\\\\.)*])+\\/(?:([gimuy])(?![a-z]*\\2))*(?![a-zA-Z_$0-9]))/,\n    Uu = /[-/\\\\^$*+?.()|[\\]{}]/g,\n    $u = {},\n    qu = {\n      allowfullscreen: 1,\n      async: 1,\n      autofocus: 1,\n      autoplay: 1,\n      checked: 1,\n      compact: 1,\n      controls: 1,\n      declare: 1,\n      default: 1,\n      defaultchecked: 1,\n      defaultmuted: 1,\n      defaultselected: 1,\n      defer: 1,\n      disabled: 1,\n      enabled: 1,\n      formnovalidate: 1,\n      hidden: 1,\n      indeterminate: 1,\n      inert: 1,\n      ismap: 1,\n      itemscope: 1,\n      loop: 1,\n      multiple: 1,\n      muted: 1,\n      nohref: 1,\n      noresize: 1,\n      noshade: 1,\n      novalidate: 1,\n      nowrap: 1,\n      open: 1,\n      pauseonexit: 1,\n      readonly: 1,\n      required: 1,\n      reversed: 1,\n      scoped: 1,\n      seamless: 1,\n      selected: 1,\n      sortable: 1,\n      translate: 1,\n      truespeed: 1,\n      typemustmatch: 1,\n      visible: 1,\n    },\n    Hu = {\n      area: 1,\n      base: 1,\n      br: 1,\n      col: 1,\n      command: 1,\n      doctype: 1,\n      embed: 1,\n      hr: 1,\n      img: 1,\n      input: 1,\n      keygen: 1,\n      link: 1,\n      meta: 1,\n      param: 1,\n      source: 1,\n      track: 1,\n      wbr: 1,\n    },\n    Zu = {\n      quot: 34,\n      amp: 38,\n      apos: 39,\n      lt: 60,\n      gt: 62,\n      nbsp: 160,\n      iexcl: 161,\n      cent: 162,\n      pound: 163,\n      curren: 164,\n      yen: 165,\n      brvbar: 166,\n      sect: 167,\n      uml: 168,\n      copy: 169,\n      ordf: 170,\n      laquo: 171,\n      not: 172,\n      shy: 173,\n      reg: 174,\n      macr: 175,\n      deg: 176,\n      plusmn: 177,\n      sup2: 178,\n      sup3: 179,\n      acute: 180,\n      micro: 181,\n      para: 182,\n      middot: 183,\n      cedil: 184,\n      sup1: 185,\n      ordm: 186,\n      raquo: 187,\n      frac14: 188,\n      frac12: 189,\n      frac34: 190,\n      iquest: 191,\n      Agrave: 192,\n      Aacute: 193,\n      Acirc: 194,\n      Atilde: 195,\n      Auml: 196,\n      Aring: 197,\n      AElig: 198,\n      Ccedil: 199,\n      Egrave: 200,\n      Eacute: 201,\n      Ecirc: 202,\n      Euml: 203,\n      Igrave: 204,\n      Iacute: 205,\n      Icirc: 206,\n      Iuml: 207,\n      ETH: 208,\n      Ntilde: 209,\n      Ograve: 210,\n      Oacute: 211,\n      Ocirc: 212,\n      Otilde: 213,\n      Ouml: 214,\n      times: 215,\n      Oslash: 216,\n      Ugrave: 217,\n      Uacute: 218,\n      Ucirc: 219,\n      Uuml: 220,\n      Yacute: 221,\n      THORN: 222,\n      szlig: 223,\n      agrave: 224,\n      aacute: 225,\n      acirc: 226,\n      atilde: 227,\n      auml: 228,\n      aring: 229,\n      aelig: 230,\n      ccedil: 231,\n      egrave: 232,\n      eacute: 233,\n      ecirc: 234,\n      euml: 235,\n      igrave: 236,\n      iacute: 237,\n      icirc: 238,\n      iuml: 239,\n      eth: 240,\n      ntilde: 241,\n      ograve: 242,\n      oacute: 243,\n      ocirc: 244,\n      otilde: 245,\n      ouml: 246,\n      divide: 247,\n      oslash: 248,\n      ugrave: 249,\n      uacute: 250,\n      ucirc: 251,\n      uuml: 252,\n      yacute: 253,\n      thorn: 254,\n      yuml: 255,\n      OElig: 338,\n      oelig: 339,\n      Scaron: 352,\n      scaron: 353,\n      Yuml: 376,\n      fnof: 402,\n      circ: 710,\n      tilde: 732,\n      Alpha: 913,\n      Beta: 914,\n      Gamma: 915,\n      Delta: 916,\n      Epsilon: 917,\n      Zeta: 918,\n      Eta: 919,\n      Theta: 920,\n      Iota: 921,\n      Kappa: 922,\n      Lambda: 923,\n      Mu: 924,\n      Nu: 925,\n      Xi: 926,\n      Omicron: 927,\n      Pi: 928,\n      Rho: 929,\n      Sigma: 931,\n      Tau: 932,\n      Upsilon: 933,\n      Phi: 934,\n      Chi: 935,\n      Psi: 936,\n      Omega: 937,\n      alpha: 945,\n      beta: 946,\n      gamma: 947,\n      delta: 948,\n      epsilon: 949,\n      zeta: 950,\n      eta: 951,\n      theta: 952,\n      iota: 953,\n      kappa: 954,\n      lambda: 955,\n      mu: 956,\n      nu: 957,\n      xi: 958,\n      omicron: 959,\n      pi: 960,\n      rho: 961,\n      sigmaf: 962,\n      sigma: 963,\n      tau: 964,\n      upsilon: 965,\n      phi: 966,\n      chi: 967,\n      psi: 968,\n      omega: 969,\n      thetasym: 977,\n      upsih: 978,\n      piv: 982,\n      ensp: 8194,\n      emsp: 8195,\n      thinsp: 8201,\n      zwnj: 8204,\n      zwj: 8205,\n      lrm: 8206,\n      rlm: 8207,\n      ndash: 8211,\n      mdash: 8212,\n      lsquo: 8216,\n      rsquo: 8217,\n      sbquo: 8218,\n      ldquo: 8220,\n      rdquo: 8221,\n      bdquo: 8222,\n      dagger: 8224,\n      Dagger: 8225,\n      bull: 8226,\n      hellip: 8230,\n      permil: 8240,\n      prime: 8242,\n      Prime: 8243,\n      lsaquo: 8249,\n      rsaquo: 8250,\n      oline: 8254,\n      frasl: 8260,\n      euro: 8364,\n      image: 8465,\n      weierp: 8472,\n      real: 8476,\n      trade: 8482,\n      alefsym: 8501,\n      larr: 8592,\n      uarr: 8593,\n      rarr: 8594,\n      darr: 8595,\n      harr: 8596,\n      crarr: 8629,\n      lArr: 8656,\n      uArr: 8657,\n      rArr: 8658,\n      dArr: 8659,\n      hArr: 8660,\n      forall: 8704,\n      part: 8706,\n      exist: 8707,\n      empty: 8709,\n      nabla: 8711,\n      isin: 8712,\n      notin: 8713,\n      ni: 8715,\n      prod: 8719,\n      sum: 8721,\n      minus: 8722,\n      lowast: 8727,\n      radic: 8730,\n      prop: 8733,\n      infin: 8734,\n      ang: 8736,\n      and: 8743,\n      or: 8744,\n      cap: 8745,\n      cup: 8746,\n      int: 8747,\n      there4: 8756,\n      sim: 8764,\n      cong: 8773,\n      asymp: 8776,\n      ne: 8800,\n      equiv: 8801,\n      le: 8804,\n      ge: 8805,\n      sub: 8834,\n      sup: 8835,\n      nsub: 8836,\n      sube: 8838,\n      supe: 8839,\n      oplus: 8853,\n      otimes: 8855,\n      perp: 8869,\n      sdot: 8901,\n      lceil: 8968,\n      rceil: 8969,\n      lfloor: 8970,\n      rfloor: 8971,\n      lang: 9001,\n      rang: 9002,\n      loz: 9674,\n      spades: 9824,\n      clubs: 9827,\n      hearts: 9829,\n      diams: 9830,\n    },\n    Wu = [\n      8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338,\n      141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482,\n      353, 8250, 339, 157, 382, 376,\n    ],\n    Gu = new RegExp("&(#?(?:x[\\\\w\\\\d]+|\\\\d+|" + Za(Zu).join("|") + "));?", "g"),\n    Qu = u(String.fromCodePoint),\n    Yu = Qu ? String.fromCodePoint : String.fromCharCode,\n    Ju = /</g,\n    Xu = />/g,\n    th = /&/g,\n    eh = 65533,\n    nh = "Expected a JavaScript expression",\n    ih = "Expected closing paren",\n    rh =\n      /^(?:[+-]?)0*(?:(?:(?:[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/,\n    sh = /^(?=.)[^"\'\\\\]+?(?:(?!.)|(?=["\'\\\\]))/,\n    ah =\n      /^\\\\(?:[`\'"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/,\n    oh = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/,\n    uh = _t(\'"\'),\n    hh = _t("\'"),\n    lh = /^[^`"\\\\\\$]+?(?:(?=[`"\\\\\\$]))/,\n    ch = /[\\r\\n\\t\\b\\f]/g,\n    fh = /^[a-zA-Z_$][a-zA-Z_$0-9]*/,\n    dh = /^\\s*\\.{3}/,\n    ph =\n      /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:\\.(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/,\n    mh = /^[a-zA-Z_$][-\\/a-zA-Z_$0-9]*(?:\\.(?:[a-zA-Z_$][-\\/a-zA-Z_$0-9]*))*/,\n    vh = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/,\n    gh =\n      /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null|Object|Number|String|Boolean)\\b/,\n    yh =\n      /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/,\n    bh =\n      /^(?:\\@\\.|\\@|~\\/|(?:\\^\\^\\/(?:\\^\\^\\/)*(?:\\.\\.\\/)*)|(?:\\.\\.\\/)+|\\.\\/(?:\\.\\.\\/)*|\\.)/,\n    wh =\n      /^(key|index|keypath|rootpath|this|global|shared|context|event|node|local|style|helpers|last|macro)/,\n    xh = function (t, e) {\n      return function (n) {\n        var i;\n        return (i = e(n))\n          ? i\n          : n.matchString(t)\n          ? (n.sp(), (i = Dt(n)), i || n.error(nh), { s: t, o: i, t: xu })\n          : null;\n      };\n    };\n  !(function () {\n    var t,\n      e,\n      n,\n      i,\n      r = "! ~ + - typeof".split(" ");\n    for (i = Kt, t = 0, e = r.length; e > t; t += 1) (n = xh(r[t], i)), (i = n);\n    $o = i;\n  })();\n  var kh,\n    _h = $o,\n    Eh = function (t, e) {\n      return function (n) {\n        if (n.inUnquotedAttribute && (">" === t || "/" === t)) return e(n);\n        var i, r, s;\n        if (((r = e(n)), !r)) return null;\n        for (;;) {\n          if (((i = n.pos), n.sp(), !n.matchString(t))) return (n.pos = i), r;\n          if ("in" === t && /[a-zA-Z_$0-9]/.test(n.remaining().charAt(0)))\n            return (n.pos = i), r;\n          if ((n.sp(), (s = e(n)), !s)) return (n.pos = i), r;\n          r = { t: Eu, s: t, o: [r, s] };\n        }\n      };\n    };\n  !(function () {\n    var t,\n      e,\n      n,\n      i,\n      r =\n        "* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||".split(\n          " "\n        );\n    for (i = _h, t = 0, e = r.length; e > t; t += 1) (n = Eh(r[t], i)), (i = n);\n    kh = i;\n  })();\n  var Sh = kh,\n    Ah = /^[^\\s"\'>\\/=(]+/,\n    Ch = /^on/,\n    Oh = /^on-([a-zA-Z\\*\\.$_]((?:[a-zA-Z\\*\\.$_0-9\\-]|\\\\-)+))$/,\n    Nh =\n      /^(?:change|reset|teardown|update|construct|config|init|render|complete|unrender|detach|insert|destruct|attachchild|detachchild)$/,\n    jh = /^as-([a-z-A-Z][-a-zA-Z_0-9]*)$/,\n    Th = /^([a-zA-Z](?:(?!-in-out)[-a-zA-Z_0-9])*)-(in|out|in-out)$/,\n    Vh = /^((bind|class)-(([-a-zA-Z0-9_])+))$/,\n    Ph = {\n      lazy: { t: Ku, v: "l" },\n      twoway: { t: Ku, v: "t" },\n      "no-delegation": { t: Lu },\n    },\n    Mh = /^[^\\s"\'=<>\\/`]+/,\n    Ih = /^[^\\s"\'=<>@\\[\\]()]*/,\n    Rh = /^\\s+/,\n    Bh = /\\\\/g,\n    Kh = { t: tu, exclude: !0 },\n    Lh =\n      /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/,\n    Dh = /^as/i,\n    Fh = {\n      else: /^\\s*else\\s*/,\n      elseif: /^\\s*elseif\\s+/,\n      then: /^\\s*then\\s*/,\n      catch: /^\\s*catch\\s*/,\n    },\n    zh = { else: Tu, elseif: Vu, then: Pu, catch: Mu },\n    Uh = { each: Ou, if: Au, with: ju, unless: Cu },\n    $h = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n    qh = /^\\s*,\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n    Hh = new RegExp("^(" + Za(Uh).join("|") + ")\\\\b"),\n    Zh = "\x3c!--",\n    Wh = "--\x3e",\n    Gh = /^[ \\t\\f\\r\\n]*\\r?\\n/,\n    Qh = /\\r?\\n[ \\t\\f\\r\\n]*$/,\n    Yh = /[ \\t\\f\\r\\n]+/g,\n    Jh = /^[ \\t\\f\\r\\n]+/,\n    Xh = /[ \\t\\f\\r\\n]+$/,\n    tl = /^(?:\\r\\n|\\r|\\n)/,\n    el = /(?:\\r\\n|\\r|\\n)$/,\n    nl = /(\\n)?[ \\t]*$/,\n    il = /[ \\t]*\\n/,\n    rl = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/,\n    sl = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/,\n    al = /^[a-zA-Z_$][-a-zA-Z0-9_$]*/,\n    ol = /^[\\s\\n\\/>]/,\n    ul = /;\\s*$/,\n    hl = { exclude: !0 },\n    ll = {\n      li: ["li"],\n      dt: ["dt", "dd"],\n      dd: ["dt", "dd"],\n      p: "address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(\n        " "\n      ),\n      rt: ["rt", "rp"],\n      rp: ["rt", "rp"],\n      optgroup: ["optgroup"],\n      option: ["option", "optgroup"],\n      thead: ["tbody", "tfoot"],\n      tbody: ["tbody", "tfoot"],\n      tfoot: ["tbody"],\n      tr: ["tr", "tbody"],\n      td: ["td", "th", "tr"],\n      th: ["td", "th", "tr"],\n    },\n    cl = /^\\s*(elseif|else|then|catch)\\s*/,\n    fl = /^\\s*#\\s*partial\\s+/,\n    dl = {},\n    pl = [le, oe, me, fe, ce],\n    ml = [ae],\n    vl = [re, ve, Ee, Oe],\n    gl = [Ne],\n    yl = { pre: 1, script: 1, style: 1, textarea: 1 },\n    bl = { textarea: !0, script: !0, style: !0, template: !0 },\n    wl = Uo.extend({\n      init: function (t, e) {\n        var n = e.tripleDelimiters || dl.defaults.tripleDelimiters,\n          i = e.staticDelimiters || dl.defaults.staticDelimiters,\n          r = e.staticTripleDelimiters || dl.defaults.staticTripleDelimiters;\n        (this.standardDelimiters = e.delimiters || dl.defaults.delimiters),\n          (this.tags = [\n            {\n              isStatic: !1,\n              isTriple: !1,\n              open: this.standardDelimiters[0],\n              close: this.standardDelimiters[1],\n              readers: pl,\n            },\n            {\n              isStatic: !1,\n              isTriple: !0,\n              open: n[0],\n              close: n[1],\n              readers: ml,\n            },\n            {\n              isStatic: !0,\n              isTriple: !1,\n              open: i[0],\n              close: i[1],\n              readers: pl,\n            },\n            {\n              isStatic: !0,\n              isTriple: !0,\n              open: r[0],\n              close: r[1],\n              readers: ml,\n            },\n          ]),\n          (this.contextLines = e.contextLines || dl.defaults.contextLines),\n          this.sortMustacheTags(),\n          (this.sectionDepth = 0),\n          (this.elementStack = []),\n          (this.interpolate = Ua(\n            {},\n            bl,\n            dl.defaults.interpolate,\n            e.interpolate\n          )),\n          e.sanitize === !0 &&\n            (e.sanitize = {\n              elements:\n                "applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title".split(\n                  " "\n                ),\n              eventAttributes: !0,\n            }),\n          (this.stripComments = e.stripComments !== !1),\n          (this.preserveWhitespace = o(e.preserveWhitespace)\n            ? !1\n            : e.preserveWhitespace),\n          (this.sanitizeElements = e.sanitize && e.sanitize.elements),\n          (this.sanitizeEventAttributes =\n            e.sanitize && e.sanitize.eventAttributes),\n          (this.includeLinePositions = e.includeLinePositions),\n          (this.textOnlyMode = e.textOnlyMode),\n          (this.csp = e.csp),\n          (this.allowExpressions = e.allowExpressions),\n          (this.preserveStandaloneSections =\n            this.preserveWhitespace && e.preserveStandaloneSections),\n          e.expression && (this.converters = [Dt]),\n          e.attributes && (this.inTag = !0),\n          (this.whiteSpaceElements = Ua({}, e.preserveWhitespace, yl));\n      },\n      postProcess: function (t, e) {\n        var n = t[0];\n        if (e.expression) {\n          var i = Ut(n);\n          return (i.e = ct(i.s, i.r.length)), i;\n        }\n        if (!t.length) return { t: [], v: Do };\n        if (\n          (this.sectionDepth > 0 && this.error("A section was left open"),\n          xe(\n            n.t,\n            this.stripComments,\n            this.preserveWhitespace,\n            !this.preserveWhitespace,\n            !this.preserveWhitespace,\n            this.whiteSpaceElements,\n            this.preserveStandaloneSections\n          ),\n          this.csp !== !1)\n        ) {\n          var r = {};\n          Te(n.t, r), Te(n.p || {}, r), Za(r).length && (n.e = r);\n        }\n        return n;\n      },\n      converters: [je],\n      sortMustacheTags: function () {\n        this.tags.sort(function (t, e) {\n          return e.open.length - t.open.length;\n        });\n      },\n    }),\n    xl = [\n      "delimiters",\n      "tripleDelimiters",\n      "staticDelimiters",\n      "staticTripleDelimiters",\n      "csp",\n      "interpolate",\n      "preserveWhitespace",\n      "preserveStandaloneSections",\n      "sanitize",\n      "stripComments",\n      "contextLines",\n      "allowExpressions",\n      "attributes",\n    ],\n    kl =\n      "Either preparse or use a ractive runtime source that includes the parser. ",\n    _l =\n      "Either include a version of Ractive that can parse or convert your computation strings to functions.",\n    El = {\n      fromId: function (t, e) {\n        if (!Ja) {\n          if (e && e.noThrow) return;\n          throw new Error(\n            "Cannot retrieve template #" +\n              t +\n              " as Ractive is not running in a browser."\n          );\n        }\n        t && (t = t.replace(/^#/, ""));\n        var n;\n        if (!(n = Ja.getElementById(t))) {\n          if (e && e.noThrow) return;\n          throw new Error("Could not find template element with id #" + t);\n        }\n        if ("SCRIPT" !== n.tagName.toUpperCase()) {\n          if (e && e.noThrow) return;\n          throw new Error(\n            "Template element with id #" + t + ", must be a <script> element"\n          );\n        }\n        return "textContent" in n ? n.textContent : n.innerHTML;\n      },\n      isParsed: function (t) {\n        return !h(t);\n      },\n      getParseOptions: function (t) {\n        return (\n          t.defaults && (t = t.defaults),\n          xl.reduce(function (e, n) {\n            return (e[n] = t[n]), e;\n          }, {})\n        );\n      },\n      parse: function (t, e) {\n        Re(Ie, "template", kl);\n        var n = Ie(t, e);\n        return dt(n), n;\n      },\n      parseFor: function (t, e) {\n        return this.parse(t, this.getParseOptions(e));\n      },\n    },\n    Sl = 0,\n    Al = function (t, e) {\n      (this.callback = t),\n        (this.parent = e),\n        (this.intros = []),\n        (this.outros = []),\n        (this.children = []),\n        (this.totalChildren = this.outroChildren = 0),\n        (this.detachQueue = []),\n        (this.outrosComplete = !1),\n        (this.id = Sl++),\n        e && e.addChild(this);\n    },\n    Cl = Al.prototype;\n  (Cl.add = function (t) {\n    var e = t.isIntro ? this.intros : this.outros;\n    (t.starting = !0), e.push(t);\n  }),\n    (Cl.addChild = function (t) {\n      this.children.push(t),\n        (this.totalChildren += 1),\n        (this.outroChildren += 1);\n    }),\n    (Cl.checkStart = function () {\n      this.parent && this.parent.started && this.start();\n    }),\n    (Cl.decrementOutros = function () {\n      (this.outroChildren -= 1), De(this);\n    }),\n    (Cl.decrementTotal = function () {\n      (this.totalChildren -= 1), De(this);\n    }),\n    (Cl.detachNodes = function () {\n      for (var t = this, e = this.detachQueue.length, n = 0; e > n; n++)\n        t.detachQueue[n].detach();\n      e = this.children.length;\n      for (var i = 0; e > i; i++) t.children[i].detachNodes();\n      this.detachQueue = [];\n    }),\n    (Cl.ready = function () {\n      this.detachQueue.length && ze(this);\n    }),\n    (Cl.remove = function (t) {\n      var e = t.isIntro ? this.intros : this.outros;\n      V(e, t), De(this);\n    }),\n    (Cl.start = function () {\n      (this.started = !0),\n        this.children.forEach(function (t) {\n          return t.start();\n        }),\n        this.intros.concat(this.outros).forEach(function (t) {\n          return t.start();\n        }),\n        De(this);\n    });\n  var Ol,\n    Nl = {\n      active: function () {\n        return !!Ol;\n      },\n      start: function () {\n        var t,\n          e = new Promise(function (e) {\n            return (t = e);\n          });\n        return (\n          (Ol = {\n            previousBatch: Ol,\n            transitionManager: new Al(t, Ol && Ol.transitionManager),\n            fragments: [],\n            tasks: [],\n            immediateObservers: [],\n            deferredObservers: [],\n            promise: e,\n          }),\n          e\n        );\n      },\n      end: function () {\n        qe(),\n          Ol.previousBatch\n            ? Ol.transitionManager.checkStart()\n            : Ol.transitionManager.start(),\n          (Ol = Ol.previousBatch);\n      },\n      addFragment: function (t) {\n        C(Ol.fragments, t);\n      },\n      addFragmentToRoot: function (t) {\n        if (Ol) {\n          for (var e = Ol; e.previousBatch; ) e = e.previousBatch;\n          C(e.fragments, t);\n        }\n      },\n      addObserver: function (t, e) {\n        Ol\n          ? C(e ? Ol.deferredObservers : Ol.immediateObservers, t)\n          : t.dispatch();\n      },\n      registerTransition: function (t) {\n        (t._manager = Ol.transitionManager), Ol.transitionManager.add(t);\n      },\n      detachWhenReady: function (t) {\n        Ol.transitionManager.detachQueue.push(t);\n      },\n      scheduleTask: function (t, e) {\n        var n;\n        if (Ol) {\n          for (n = Ol; e && n.previousBatch; ) n = n.previousBatch;\n          n.tasks.push(t);\n        } else t();\n      },\n      promise: function () {\n        if (!Ol) return Promise.resolve();\n        for (var t = Ol; t.previousBatch; ) t = t.previousBatch;\n        return t.promise || Promise.resolve();\n      },\n    },\n    jl = [],\n    Tl = !1,\n    Vl = function (t) {\n      (this.duration = t.duration),\n        (this.step = t.step),\n        (this.complete = t.complete),\n        (this.easing = t.easing),\n        (this.start = performance.now()),\n        (this.end = this.start + this.duration),\n        (this.running = !0),\n        jl.push(this),\n        Tl || requestAnimationFrame(He);\n    },\n    Pl = Vl.prototype;\n  (Pl.tick = function (t) {\n    if (!this.running) return !1;\n    if (t > this.end)\n      return this.step && this.step(1), this.complete && this.complete(1), !1;\n    var e = t - this.start,\n      n = this.easing(e / this.duration);\n    return this.step && this.step(n), !0;\n  }),\n    (Pl.stop = function () {\n      this.abort && this.abort(), (this.running = !1);\n    });\n  var Ml = {},\n    Il = {},\n    Rl = (function (e) {\n      function n(t, n) {\n        e.call(this, t),\n          (this.ticker = null),\n          t &&\n            ((this.key = A(n)),\n            (this.isReadonly = t.isReadonly),\n            t.value &&\n              ((this.value = t.value[this.key]),\n              Ga(this.value) && (this.length = this.value.length),\n              this.adapt()));\n      }\n      e && (n.__proto__ = e);\n      var s = (n.prototype = Object.create(e && e.prototype));\n      return (\n        (s.constructor = n),\n        (s.adapt = function () {\n          var t = this,\n            e = this.root.adaptors,\n            n = e.length;\n          if (((this.rewrap = !1), 0 !== n)) {\n            var i = this.wrapper\n                ? "newWrapperValue" in this\n                  ? this.newWrapperValue\n                  : this.wrapperValue\n                : this.value,\n              r = this.root.ractive,\n              s = this.getKeypath();\n            if (this.wrapper) {\n              var a =\n                this.wrapperValue === i\n                  ? !1\n                  : !this.wrapper.reset || this.wrapper.reset(i) === !1;\n              if (!a)\n                return (\n                  delete this.newWrapperValue,\n                  void (this.value = this.wrapper.get())\n                );\n              if (\n                (this.wrapper.teardown(),\n                delete this.wrapper,\n                delete this.wrapperValue,\n                delete this.newWrapperValue,\n                void 0 !== this.value)\n              ) {\n                var o = this.parent.value || this.parent.createBranch(this.key);\n                o[this.key] !== i && (o[this.key] = i), (this.value = i);\n              }\n            }\n            var u;\n            for (u = 0; n > u; u += 1) {\n              var h = e[u];\n              if (h.filter(i, s, r)) {\n                (t.wrapper = h.wrap(r, i, s, We(s))),\n                  (t.wrapperValue = i),\n                  (t.wrapper.__model = t),\n                  (t.value = t.wrapper.get());\n                break;\n              }\n            }\n          }\n        }),\n        (s.animate = function (t, e, n, i) {\n          var r = this;\n          this.ticker && this.ticker.stop();\n          var s,\n            a = new Promise(function (t) {\n              return (s = t);\n            });\n          return (\n            (this.ticker = new Vl({\n              duration: n.duration,\n              easing: n.easing,\n              step: function (t) {\n                var e = i(t);\n                r.applyValue(e), n.step && n.step(t, e);\n              },\n              complete: function () {\n                r.applyValue(e),\n                  n.complete && n.complete(e),\n                  (r.ticker = null),\n                  s(e);\n              },\n            })),\n            (a.stop = this.ticker.stop),\n            a\n          );\n        }),\n        (s.applyValue = function (t, e) {\n          if ((void 0 === e && (e = !0), !i(t, this.value))) {\n            if (\n              (this.boundValue && (this.boundValue = null),\n              this.parent.wrapper && this.parent.wrapper.set)\n            )\n              this.parent.wrapper.set(this.key, t),\n                (this.parent.value = this.parent.wrapper.get()),\n                (this.value = this.parent.value[this.key]),\n                this.wrapper && (this.newWrapperValue = this.value),\n                this.adapt();\n            else if (this.wrapper) (this.newWrapperValue = t), this.adapt();\n            else {\n              var n = this.parent.value || this.parent.createBranch(this.key);\n              if (!a(n))\n                return void y(\n                  "Attempted to set a property of a non-object \'" +\n                    this.getKeypath() +\n                    "\'"\n                );\n              (n[this.key] = t), (this.value = t), this.adapt();\n            }\n            (this.dataModel || (t && t.viewmodel && t.viewmodel.isRoot)) &&\n              U(this, t),\n              Ga(t)\n                ? ((this.length = t.length), (this.isArray = !0))\n                : (this.isArray = !1),\n              this.links.forEach(Q),\n              this.children.forEach(Y),\n              this.deps.forEach(Q),\n              e && this.notifyUpstream(),\n              this.parent.isArray &&\n                ("length" === this.key\n                  ? (this.parent.length = t)\n                  : this.parent.joinKey("length").mark());\n          }\n        }),\n        (s.compute = function (t, e) {\n          var n = this.computed || (this.computed = {});\n          return (\n            n[t]\n              ? ((n[t].signature = Le(this.root.ractive, t, e)), n[t].mark())\n              : (n[t] = new Il.Computation(\n                  this,\n                  Le(this.root.ractive, t, e),\n                  t\n                )),\n            n[t]\n          );\n        }),\n        (s.createBranch = function (t) {\n          var e = r(t) ? [] : {};\n          return this.applyValue(e, !1), e;\n        }),\n        (s.get = function (t, e) {\n          return this._link\n            ? this._link.get(t, e)\n            : (t && H(this),\n              e && e.virtual\n                ? this.getVirtual(!1)\n                : K(\n                    this,\n                    (e && "unwrap" in e ? e.unwrap !== !1 : t) && this.wrapper\n                      ? this.wrapperValue\n                      : this.value,\n                    !e || e.shouldBind !== !1\n                  ));\n        }),\n        (s.joinKey = function (e, i) {\n          var r = this;\n          if (this._link)\n            return i && i.lastLink !== !1 && (c(e) || "" === e)\n              ? this\n              : this._link.joinKey(e);\n          if (c(e) || "" === e) return this;\n          var s;\n          if (\n            ((s = t(this.childByKey, e)\n              ? this.childByKey[e]\n              : this.computed && this.computed[e]),\n            !s)\n          ) {\n            var a;\n            if (this.isRoot && this.ractive && (a = this.ractive.computed[e]))\n              s = this.compute(e, a);\n            else if (!this.isRoot && this.root.ractive) {\n              var o = this.root.ractive.computed;\n              for (var u in o)\n                (a = o[u]),\n                  a.pattern &&\n                    a.pattern.test(r.getKeypath() + "." + e) &&\n                    (s = r.compute(e, a));\n            }\n          }\n          if (\n            !s &&\n            ((s = new n(this, e)),\n            this.children.push(s),\n            (this.childByKey[e] = s),\n            "data" === e)\n          ) {\n            var h = this.retrieve();\n            h &&\n              h.viewmodel &&\n              h.viewmodel.isRoot &&\n              (s.link(h.viewmodel, "data"), (this.dataModel = h));\n          }\n          return !s._link || (i && i.lastLink === !1) ? s : s._link;\n        }),\n        (s.mark = function (t) {\n          if (this._link) return this._link.mark(t);\n          var e = this.value,\n            n = this.retrieve();\n          (this.dataModel || (n && n.viewmodel && n.viewmodel.isRoot)) &&\n            U(this, n),\n            (t || !i(n, e)) &&\n              ((this.value = n),\n              this.boundValue && (this.boundValue = null),\n              (e !== n || this.rewrap) &&\n                (this.wrapper && (this.newWrapperValue = n), this.adapt()),\n              Ga(n)\n                ? ((this.length = n.length), (this.isArray = !0))\n                : (this.isArray = !1),\n              this.children.forEach(t ? J : Y),\n              this.links.forEach(X),\n              this.deps.forEach(Q));\n        }),\n        (s.merge = function (t, e) {\n          var n = R(this.value === t ? Ge(this) : this.value, t, e);\n          (this.parent.value[this.key] = t), this.shuffle(n, !0);\n        }),\n        (s.retrieve = function () {\n          return this.parent.value ? this.parent.value[this.key] : void 0;\n        }),\n        (s.set = function (t) {\n          this.ticker && this.ticker.stop(), this.applyValue(t);\n        }),\n        (s.shuffle = function (t, e) {\n          z(this, t, !1, e);\n        }),\n        (s.source = function () {\n          return this;\n        }),\n        (s.teardown = function () {\n          var t = this;\n          this._link && (this._link.teardown(), (this._link = null)),\n            this.children.forEach(it),\n            this.wrapper && this.wrapper.teardown(),\n            this.computed &&\n              Za(this.computed).forEach(function (e) {\n                return t.computed[e].teardown();\n              });\n        }),\n        n\n      );\n    })(Po),\n    Bl = {},\n    Kl = (function (t) {\n      function e(e, n, i) {\n        t.call(this, null, "@" + n),\n          (this.key = "@" + n),\n          (this.value = e),\n          (this.isRoot = !0),\n          (this.root = this),\n          (this.adaptors = []),\n          (this.ractive = i);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.getKeypath = function () {\n          return this.key;\n        }),\n        (n.retrieve = function () {\n          return this.value;\n        }),\n        e\n      );\n    })(Rl),\n    Ll = new Kl(Bl, "shared"),\n    Dl = new Kl(to, "global"),\n    Fl = {},\n    zl = function (t) {\n      this.ractive = t;\n    };\n  zl.prototype.findContext = function () {\n    return this.ractive.viewmodel;\n  };\n  var Ul = zl.prototype;\n  (Ul.getContext = rn),\n    (Ul.find = Ul.findComponent = Ul.findAll = Ul.findAllComponents = f);\n  var $l = !1,\n    ql = /\\*/,\n    Hl = { virtual: !1 },\n    Zl = {},\n    Wl = "Cannot add to a non-numeric value",\n    Gl = go.linear,\n    Ql = {},\n    Yl = {},\n    Jl = function (t) {\n      (this.event = t), (this.method = "on" + t);\n    };\n  Jl.prototype.fire = function (t, e) {\n    var n = nn(t),\n      i = this.method;\n    t[i] && (e ? t[i](n, e) : t[i](n)), wn(t, this.event, n, e ? [e, t] : [t]);\n  };\n  var Xl = function (t) {\n      (this.hook = new Jl(t)), (this.inProcess = {}), (this.queue = {});\n    },\n    tc = Xl.prototype;\n  (tc.begin = function (t) {\n    this.inProcess[t._guid] = !0;\n  }),\n    (tc.end = function (t) {\n      var e = t.parent;\n      e && this.inProcess[e._guid] ? _n(this.queue, e).push(t) : En(this, t),\n        delete this.inProcess[t._guid];\n    });\n  var ec = {};\n  [\n    "construct",\n    "config",\n    "attachchild",\n    "detach",\n    "detachchild",\n    "insert",\n    "complete",\n    "reset",\n    "render",\n    "unrendering",\n    "unrender",\n    "teardown",\n    "destruct",\n    "update",\n  ].forEach(function (t) {\n    ec[t] = new Jl(t);\n  }),\n    (ec.init = new Xl("init"));\n  var nc = Array.prototype,\n    ic = qn("push").model,\n    rc = qn("pop").model,\n    sc = qn("shift").model,\n    ac = qn("unshift").model,\n    oc = qn("sort").model,\n    uc = qn("splice").model,\n    hc = qn("reverse").model,\n    lc = {},\n    cc = (function (t) {\n      function e(e) {\n        t.call(this, null, null),\n          (this.isRoot = !0),\n          (this.root = this),\n          (this.value = {}),\n          (this.ractive = e.ractive),\n          (this.adaptors = []),\n          (this.context = e.context);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.getKeypath = function () {\n          return "@context.data";\n        }),\n        (n.rebound = function () {}),\n        e\n      );\n    })(Rl),\n    fc = function (t, e) {\n      (this.fragment = t),\n        (this.element = e || zn(t)),\n        (this.node = this.element && this.element.node),\n        (this.ractive = t.ractive),\n        (this.root = this);\n    },\n    dc = fc.prototype,\n    pc = { decorators: {}, _data: {} };\n  (pc.decorators.get = function () {\n    var t = {};\n    return this.element\n      ? (this.element.decorators.forEach(function (e) {\n          return (t[e.name] = e.handle);\n        }),\n        t)\n      : t;\n  }),\n    (pc._data.get = function () {\n      return (\n        this.model ||\n        (this.root.model = new cc({\n          ractive: this.ractive,\n          context: this.root,\n        }))\n      );\n    }),\n    (dc.add = function (t, e, n) {\n      var i = l(e) ? +e : 1,\n        s = o(e) ? e : n;\n      return an(\n        Wn(this, t, i).map(function (t) {\n          var e = t[0],\n            n = t[1],\n            i = e.get();\n          if (!r(n) || !r(i)) throw new Error("Cannot add non-numeric value");\n          return [e, i + n];\n        }),\n        s\n      );\n    }),\n    (dc.animate = function (t, e, n) {\n      var i = Gn(this, t).model;\n      return mn(this.ractive, i, e, n);\n    }),\n    (dc.find = function (t, e) {\n      return this.fragment.find(t, e);\n    }),\n    (dc.findAll = function (t, e) {\n      var n = [];\n      return (e = e || {}), (e.result = n), this.fragment.findAll(t, e), n;\n    }),\n    (dc.findAllComponents = function (t, e) {\n      var n = [];\n      return (\n        (e = e || {}), (e.result = n), this.fragment.findAllComponents(t, e), n\n      );\n    }),\n    (dc.findComponent = function (t, e) {\n      return this.fragment.findComponent(t, e);\n    }),\n    (dc.get = function (t) {\n      if (!t) return this.fragment.findContext().get(!0);\n      var e = Gn(this, t),\n        n = e.model;\n      return n ? n.get(!0) : void 0;\n    }),\n    (dc.getParent = function (t) {\n      var e = this.fragment;\n      return (\n        !e.parent && t\n          ? (e = e.componentParent)\n          : e.context\n          ? (e = sn(e.parent))\n          : ((e = sn(e.parent)),\n            e && (e = !e.parent && t ? e.componentParent : sn(e.parent))),\n        e && e !== this.fragment ? e.getContext() : void 0\n      );\n    }),\n    (dc.hasListener = function (t, e) {\n      var n,\n        i = this.fragment.owner.component\n          ? this.fragment.owner\n          : this.element || this.fragment.owner;\n      do {\n        if (((n = i.component || i), n.template.t === Yo && Qn(n, t)))\n          return !0;\n        (i = i.up && i.up.owner), i && i.component && (i = i.component);\n      } while (i && e);\n    }),\n    (dc.link = function (t, e) {\n      var n = Gn(this, t).model,\n        i = Gn(this, e).model,\n        r = Nl.start();\n      return i.link(n, t), Nl.end(), r;\n    }),\n    (dc.listen = function (t, e) {\n      var n = this.element;\n      return (\n        n.on(t, e),\n        {\n          cancel: function () {\n            n.off(t, e);\n          },\n        }\n      );\n    }),\n    (dc.observe = function (t, e, n) {\n      return (\n        void 0 === n && (n = {}),\n        s(t) && (n = e || {}),\n        (n.fragment = this.fragment),\n        this.ractive.observe(t, e, n)\n      );\n    }),\n    (dc.observeOnce = function (t, e, n) {\n      return (\n        void 0 === n && (n = {}),\n        s(t) && (n = e || {}),\n        (n.fragment = this.fragment),\n        this.ractive.observeOnce(t, e, n)\n      );\n    }),\n    (dc.pop = function (t) {\n      return rc(Gn(this, t).model, []);\n    }),\n    (dc.push = function (t) {\n      for (var e = [], n = arguments.length - 1; n-- > 0; )\n        e[n] = arguments[n + 1];\n      return ic(Gn(this, t).model, e);\n    }),\n    (dc.raise = function (t, e) {\n      for (var n = [], i = arguments.length - 2; i-- > 0; )\n        n[i] = arguments[i + 2];\n      for (var r, s = this.element; s; ) {\n        if ((s.component && (s = s.component), (r = Qn(s, t))))\n          return r.fire(\n            r.element.getContext(\n              e || {},\n              !e || "original" in e ? {} : { original: {} }\n            ),\n            n\n          );\n        s = s.up && s.up.owner;\n      }\n    }),\n    (dc.readLink = function (t, e) {\n      return this.ractive.readLink(this.resolve(t), e);\n    }),\n    (dc.resolve = function (t, e) {\n      var n = Gn(this, t),\n        i = n.model,\n        r = n.instance;\n      return i ? i.getKeypath(e || r) : t;\n    }),\n    (dc.reverse = function (t) {\n      return hc(Gn(this, t).model, []);\n    }),\n    (dc.set = function (t, e, n) {\n      return an(Wn(this, t, e), n);\n    }),\n    (dc.shift = function (t) {\n      return sc(Gn(this, t).model, []);\n    }),\n    (dc.splice = function (t, e, n) {\n      for (var i = [], r = arguments.length - 3; r-- > 0; )\n        i[r] = arguments[r + 3];\n      return i.unshift(e, n), uc(Gn(this, t).model, i);\n    }),\n    (dc.sort = function (t) {\n      return oc(Gn(this, t).model, []);\n    }),\n    (dc.subtract = function (t, e, n) {\n      var i = l(e) ? e : 1,\n        s = o(e) ? e : n;\n      return an(\n        Wn(this, t, i).map(function (t) {\n          var e = t[0],\n            n = t[1],\n            i = e.get();\n          if (!r(n) || !r(i)) throw new Error("Cannot add non-numeric value");\n          return [e, i - n];\n        }),\n        s\n      );\n    }),\n    (dc.toggle = function (t, e) {\n      var n = Gn(this, t),\n        i = n.model;\n      return an([[i, !i.get()]], e);\n    }),\n    (dc.unlink = function (t) {\n      var e = Gn(this, t).model,\n        n = Nl.start();\n      return e.owner && e.owner._link && e.owner.unlink(), Nl.end(), n;\n    }),\n    (dc.unlisten = function (t, e) {\n      this.element.off(t, e);\n    }),\n    (dc.unshift = function (t) {\n      for (var e = [], n = arguments.length - 1; n-- > 0; )\n        e[n] = arguments[n + 1];\n      return ac(Gn(this, t).model, e);\n    }),\n    (dc.update = function (t, e) {\n      return Hn(this.ractive, Gn(this, t).model, e);\n    }),\n    (dc.updateModel = function (t, e) {\n      var n = Gn(this, t),\n        i = n.model,\n        r = Nl.start();\n      return i.updateFromBindings(e), Nl.end(), r;\n    }),\n    (dc.isBound = function () {\n      var t = this.getBindingModel(this),\n        e = t.model;\n      return !!e;\n    }),\n    (dc.getBindingPath = function (t) {\n      var e = this.getBindingModel(this),\n        n = e.model,\n        i = e.instance;\n      return n ? n.getKeypath(t || i) : void 0;\n    }),\n    (dc.getBinding = function () {\n      var t = this.getBindingModel(this),\n        e = t.model;\n      return e ? e.get(!0) : void 0;\n    }),\n    (dc.getBindingModel = function (t) {\n      var e = t.element;\n      return { model: e.binding && e.binding.model, instance: e.up.ractive };\n    }),\n    (dc.setBinding = function (t) {\n      var e = this.getBindingModel(this),\n        n = e.model;\n      return an([[n, t]]);\n    }),\n    Object.defineProperties(dc, pc),\n    (fc.forRactive = nn),\n    (Fl.Context = fc);\n  var mc,\n    vc,\n    gc,\n    yc,\n    bc,\n    wc,\n    xc,\n    kc,\n    _c,\n    Ec = Ja && Ja.querySelector,\n    Sc = "http://www.w3.org/1999/xhtml",\n    Ac = "http://www.w3.org/1998/Math/MathML",\n    Cc = "http://www.w3.org/2000/svg",\n    Oc = "http://www.w3.org/1999/xlink",\n    Nc = "http://www.w3.org/XML/1998/namespace",\n    jc = "http://www.w3.org/2000/xmlns",\n    Tc = { html: Sc, mathml: Ac, svg: Cc, xlink: Oc, xml: Nc, xmlns: jc },\n    Vc = Xa && "registerElement" in Ja;\n  if (\n    ((mc = no\n      ? function (t, e, n) {\n          return e && e !== Sc\n            ? n\n              ? Ja.createElementNS(e, t, ni(n))\n              : Ja.createElementNS(e, t)\n            : n\n            ? Ja.createElement(t, ni(n))\n            : Ja.createElement(t);\n        }\n      : function (t, e, n) {\n          if (e && e !== Sc)\n            throw "This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\'re trying to render SVG in an older browser. See http://ractive.js.org/support/#svgs for more information";\n          return n ? Ja.createElement(t, ni(n)) : Ja.createElement(t);\n        }),\n    Xa)\n  ) {\n    for (\n      gc = mc("div"),\n        yc = ["matches", "matchesSelector"],\n        _c = function (t) {\n          return function (e, n) {\n            return e[t](n);\n          };\n        },\n        xc = yc.length;\n      xc-- && !vc;\n\n    )\n      if (((bc = yc[xc]), gc[bc])) vc = _c(bc);\n      else\n        for (kc = io.length; kc--; )\n          if (\n            ((wc = io[xc] + bc.substr(0, 1).toUpperCase() + bc.substring(1)),\n            gc[wc])\n          ) {\n            vc = _c(wc);\n            break;\n          }\n    vc ||\n      (vc = function (t, e) {\n        var n, i;\n        (n = t.parentNode),\n          n ||\n            ((gc.innerHTML = ""),\n            (n = gc),\n            (t = t.cloneNode()),\n            gc.appendChild(t));\n        var r = n.querySelectorAll(e);\n        for (i = r.length; i--; ) if (r[i] === t) return !0;\n        return !1;\n      });\n  } else vc = null;\n  var Pc = function (t, e, n, i) {\n      (this.context = i.context || t),\n        (this.callback = n),\n        (this.ractive = t),\n        (this.keypath = i.keypath),\n        (this.options = i),\n        e && this.resolved(e),\n        u(i.old) && ((this.oldContext = $a(t)), (this.oldFn = i.old)),\n        i.init !== !1 ? ((this.dirty = !0), this.dispatch()) : fi(this),\n        (this.dirty = !1);\n    },\n    Mc = Pc.prototype;\n  (Mc.cancel = function () {\n    (this.cancelled = !0),\n      this.model ? this.model.unregister(this) : this.resolver.unbind(),\n      V(this.ractive._observers, this);\n  }),\n    (Mc.dispatch = function () {\n      if (!this.cancelled) {\n        try {\n          this.callback.call(\n            this.context,\n            this.newValue,\n            this.oldValue,\n            this.keypath\n          );\n        } catch (t) {\n          y(\n            "Failed to execute observer callback for \'" +\n              this.keypath +\n              "\': " +\n              (t.message || t)\n          );\n        }\n        fi(this, !0), (this.dirty = !1);\n      }\n    }),\n    (Mc.handleChange = function () {\n      var t = this;\n      if (this.dirty) this.newValue = this.model.get();\n      else {\n        var e = this.model.get();\n        if (i(e, this.oldValue)) return;\n        if (\n          ((this.newValue = e),\n          this.options.strict && this.newValue === this.oldValue)\n        )\n          return;\n        Nl.addObserver(this, this.options.defer),\n          (this.dirty = !0),\n          this.options.once &&\n            Nl.scheduleTask(function () {\n              return t.cancel();\n            });\n      }\n    }),\n    (Mc.rebind = function (t, e) {\n      var n = this;\n      return (\n        (t = ht(this.keypath, t, e)),\n        t === this.model\n          ? !1\n          : (this.model && this.model.unregister(this),\n            void (\n              t &&\n              t.addShuffleTask(function () {\n                return n.resolved(t);\n              })\n            ))\n      );\n    }),\n    (Mc.resolved = function (t) {\n      (this.model = t),\n        (this.oldValue = void 0),\n        (this.newValue = t.get()),\n        t.register(this);\n    });\n  var Ic = /\\*+/g,\n    Rc = function (t, e, n, i, r) {\n      var s = this;\n      (this.context = r.context || t),\n        (this.ractive = t),\n        (this.baseModel = e),\n        (this.keys = n),\n        (this.callback = i);\n      var a = n.join("\\\\.").replace(Ic, "(.+)"),\n        o = (this.baseKeypath = e.getKeypath(t));\n      (this.pattern = new RegExp("^" + (o ? o + "\\\\." : "") + a + "$")),\n        (this.recursive = 1 === n.length && "**" === n[0]),\n        this.recursive && (this.keys = ["*"]),\n        r.old && ((this.oldContext = $a(t)), (this.oldFn = r.old)),\n        (this.oldValues = {}),\n        (this.newValues = {}),\n        (this.defer = r.defer),\n        (this.once = r.once),\n        (this.strict = r.strict),\n        (this.dirty = !1),\n        (this.changed = []),\n        (this.cache = []),\n        (this.partial = !1),\n        (this.links = r.links);\n      var u = e.findMatches(this.keys);\n      u.forEach(function (t) {\n        s.newValues[t.getKeypath(s.ractive)] = t.get();\n      }),\n        r.init !== !1 ? this.dispatch() : mi(this, this.newValues),\n        e.registerPatternObserver(this);\n    },\n    Bc = Rc.prototype;\n  (Bc.cancel = function () {\n    this.baseModel.unregisterPatternObserver(this),\n      V(this.ractive._observers, this);\n  }),\n    (Bc.dispatch = function () {\n      var t = this,\n        e = this.newValues;\n      (this.newValues = {}),\n        Za(e).forEach(function (n) {\n          var r = e[n],\n            s = t.oldValues[n];\n          if (!((t.strict && r === s) || i(r, s))) {\n            var a = [r, s, n];\n            if (n) {\n              var o = t.pattern.exec(n);\n              o && (a = a.concat(o.slice(1)));\n            }\n            try {\n              t.callback.apply(t.context, a);\n            } catch (u) {\n              y(\n                "Failed to execute pattern observer callback for \'" +\n                  t.keypath +\n                  "\': " +\n                  (u.message || u)\n              );\n            }\n          }\n        }),\n        mi(this, e, this.partial),\n        (this.dirty = !1);\n    }),\n    (Bc.notify = function (t) {\n      var e = di(t);\n      ~this.cache.indexOf(e) || (this.cache.push(e), this.changed.push(t));\n    }),\n    (Bc.shuffle = function (t) {\n      var e = this;\n      if (Ga(this.baseModel.value)) {\n        for (var n = this.baseModel.value.length, i = 0; i < t.length; i++)\n          -1 !== t[i] && t[i] !== i && e.changed.push([i]);\n        for (var r = t.touchedFrom; n > r; r++) e.changed.push([r]);\n      }\n    }),\n    (Bc.handleChange = function () {\n      var t = this;\n      if (!this.dirty || this.changed.length) {\n        if ((this.dirty || (this.newValues = {}), this.changed.length)) {\n          var e = 0;\n          if (this.recursive) {\n            var n = this.changed.slice();\n            (this.changed.length = 0),\n              (this.dirty = !0),\n              n.forEach(function (n) {\n                var i = t.baseModel.joinAll(n);\n                (!i.isLink || t.links) &&\n                  (e++, (t.newValues[i.getKeypath(t.ractive)] = i.get()));\n              }),\n              (this.dirty = !1);\n          } else {\n            var i = this.baseModel.isRoot\n              ? this.changed.map(function (t) {\n                  return t.map(_).join(".");\n                })\n              : this.changed.map(function (e) {\n                  return t.baseKeypath + "." + e.map(_).join(".");\n                });\n            this.baseModel.findMatches(this.keys).forEach(function (n) {\n              var r = n.getKeypath(t.ractive),\n                s = function (t) {\n                  return (\n                    (0 === t.indexOf(r) &&\n                      (t.length === r.length || "." === t[r.length])) ||\n                    (0 === r.indexOf(t) &&\n                      (t.length === r.length || "." === r[t.length]))\n                  );\n                };\n              i.filter(s).length && (e++, (t.newValues[r] = n.get()));\n            });\n          }\n          if (!e) return;\n          this.partial = !0;\n        } else\n          this.baseModel.findMatches(this.keys).forEach(function (e) {\n            var n = e.getKeypath(t.ractive);\n            t.newValues[n] = e.get();\n          }),\n            (this.partial = !1);\n        Nl.addObserver(this, this.defer),\n          (this.dirty = !0),\n          (this.changed.length = 0),\n          (this.cache = []),\n          this.once && this.cancel();\n      }\n    });\n  var Kc = function (t, e, n, i) {\n      (this.ractive = t),\n        (this.model = e),\n        (this.keypath = e.getKeypath()),\n        (this.callback = n),\n        (this.options = i),\n        (this.pending = null),\n        e.register(this),\n        i.init !== !1\n          ? ((this.sliced = []), this.shuffle([]), this.dispatch())\n          : (this.sliced = this.slice());\n    },\n    Lc = Kc.prototype;\n  (Lc.cancel = function () {\n    this.model.unregister(this), V(this.ractive._observers, this);\n  }),\n    (Lc.dispatch = function () {\n      try {\n        this.callback(this.pending);\n      } catch (t) {\n        y(\n          "Failed to execute array observer callback for \'" +\n            this.keypath +\n            "\': " +\n            (t.message || t)\n        );\n      }\n      (this.pending = null), this.options.once && this.cancel();\n    }),\n    (Lc.handleChange = function (t) {\n      this.pending\n        ? Nl.addObserver(this, this.options.defer)\n        : t || (this.shuffle(this.sliced.map(vi)), this.handleChange());\n    }),\n    (Lc.shuffle = function (t) {\n      var e,\n        n = this,\n        i = this.slice(),\n        r = [],\n        s = [],\n        a = {};\n      t.forEach(function (t, i) {\n        (a[t] = !0),\n          t !== i && c(e) && (e = i),\n          -1 === t && s.push(n.sliced[i]);\n      }),\n        c(e) && (e = t.length);\n      for (var o = i.length, u = 0; o > u; u += 1) a[u] || r.push(i[u]);\n      (this.pending = { inserted: r, deleted: s, start: e }), (this.sliced = i);\n    }),\n    (Lc.slice = function () {\n      var t = this.model.get();\n      return Ga(t) ? t.slice() : [];\n    });\n  var Dc = { init: !1, once: !0 },\n    Fc = function (t) {\n      return t.trim();\n    },\n    zc = function (t) {\n      return "" !== t;\n    },\n    Uc = qn("pop").path,\n    $c = qn("push").path,\n    qc = "/* Ractive.js component styles */",\n    Hc = [],\n    Zc = !1,\n    Wc = null,\n    Gc = null,\n    Qc = !1,\n    Yc = {\n      extend: function (t, e, n) {\n        e.adapt = P(e.adapt, j(n.adapt));\n      },\n      init: function () {},\n    },\n    Jc = /\\/\\*(?:[\\s\\S]*?)\\*\\//g,\n    Xc =\n      /url\\(\\s*([\'"])(?:\\\\[\\s\\S]|(?!\\1).)*\\1\\s*\\)|url\\((?:\\\\[\\s\\S]|[^)])*\\)|([\'"])(?:\\\\[\\s\\S]|(?!\\2).)*\\2/gi,\n    tf = /\\0(\\d+)/g,\n    ef = /(?:^|\\}|\\{|\\x01)\\s*([^\\{\\}\\0\\x01]+)\\s*(?=\\{)/g,\n    nf = /@import\\s*\\([^)]*\\)\\s*;?/gi,\n    rf = /\\x01/g,\n    sf = /@keyframes\\s+[^\\{\\}]+\\s*\\{(?:[^{}]+|\\{[^{}]+})*}/gi,\n    af =\n      /((?:(?:\\[[^\\]]+\\])|(?:[^\\s\\+\\>~:]))+)((?:::?[^\\s\\+\\>\\~\\(:]+(?:\\([^\\)]+\\))?)*\\s*[\\s\\+\\>\\~]?)\\s*/g,\n    of = /^(?:@|\\d+%)/,\n    uf = /\\[data-ractive-css~="\\{[a-z0-9-]+\\}"]/g,\n    hf = (function (t) {\n      function e(e) {\n        t.call(this, e.cssData, "@style"), (this.component = e);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.downstreamChanged = function (t, e) {\n          if (!this.locked) {\n            var n = this.component;\n            n.extensions.forEach(function (n) {\n              var i = n._cssModel;\n              i.mark(), i.downstreamChanged(t, e || 1);\n            }),\n              e || Li(n, !0);\n          }\n        }),\n        e\n      );\n    })(Kl),\n    lf = /\\{/,\n    cf = {\n      name: "css",\n      extend: function (t, e, n, i) {\n        (i._cssIds = Fi(t)),\n          qa(i, "cssData", {\n            configurable: !0,\n            value: Ua($a(t.cssData), n.cssData || {}),\n          }),\n          qa(i, "_cssModel", { configurable: !0, value: new hf(i) }),\n          n.css && Ui(n, i, e);\n      },\n      init: function (t, e, n) {\n        n.css &&\n          y(\n            "\\nThe css option is currently not supported on a per-instance basis and will be discarded. Instead, we recommend instantiating from a component definition with a css option.\\n\\nconst Component = Ractive.extend({\\n\t...\\n\tcss: \'/* your css */\',\\n\t...\\n});\\n\\nconst componentInstance = new Component({ ... })\\n\t\t"\n          );\n      },\n    },\n    ff = {\n      name: "data",\n      extend: function (t, e, n) {\n        var i, r;\n        if (n.data && s(n.data))\n          for (i in n.data)\n            (r = n.data[i]),\n              r &&\n                o(r) &&\n                (s(r) || Ga(r)) &&\n                y(\n                  "Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\\n\\n  // this...\\n  data: function () {\\n    return {\\n      myObject: {}\\n    };\\n  })\\n\\n  // instead of this:\\n  data: {\\n    myObject: {}\\n  }"\n                );\n        e.data = Hi(e.data, n.data);\n      },\n      init: function (t, e, n) {\n        var i = Hi(t.prototype.data, n.data);\n        if ((u(i) && (i = i.call(e)), i && i.constructor === Object))\n          for (var r in i)\n            if (u(i[r])) {\n              var s = i[r];\n              (i[r] = B(s, e)), (i[r]._r_unbound = s);\n            }\n        return i || {};\n      },\n      reset: function (t) {\n        var e = this.init(t.constructor, t, t.viewmodel);\n        return t.viewmodel.root.set(e), !0;\n      },\n    },\n    df = {\n      name: "template",\n      extend: function (t, e, n) {\n        if ("template" in n) {\n          var i = n.template;\n          u(i) ? (e.template = i) : (e.template = Yi(i, e));\n        }\n      },\n      init: function (t, e, n) {\n        var i = "template" in n ? n.template : t.prototype.template;\n        if (((i = i || { v: Do, t: [] }), u(i))) {\n          var r = i;\n          (i = Qi(e, r)), (e._config.template = { fn: r, result: i });\n        }\n        (i = Yi(i, e)), (e.template = i.t), i.p && tr(e.partials, i.p);\n      },\n      reset: function (t) {\n        var e = Gi(t);\n        if (e) {\n          var n = Yi(e, t);\n          return (t.template = n.t), tr(t.partials, n.p, !0), !0;\n        }\n      },\n    },\n    pf = [\n      "adaptors",\n      "components",\n      "computed",\n      "decorators",\n      "easing",\n      "events",\n      "helpers",\n      "interpolators",\n      "partials",\n      "transitions",\n    ],\n    mf = ["computed", "helpers"],\n    vf = function (t, e) {\n      (this.name = t), (this.useDefaults = e);\n    },\n    gf = vf.prototype;\n  (gf.extend = function (t, e, n) {\n    var i = this.useDefaults ? t.defaults : t,\n      r = this.useDefaults ? e : e.constructor;\n    this.configure(i, r, n);\n  }),\n    (gf.init = function () {}),\n    (gf.configure = function (t, e, n) {\n      var i = this.name,\n        r = n[i],\n        s = $a(t[i]);\n      Ua(s, r),\n        (e[i] = s),\n        "partials" === i &&\n          e[i] &&\n          Za(e[i]).forEach(function (t) {\n            dt(e[i][t]);\n          });\n    }),\n    (gf.reset = function (t) {\n      var e = t[this.name],\n        n = !1;\n      return (\n        Za(e).forEach(function (t) {\n          var i = e[t];\n          i._fn && (i._fn.isOwner ? (e[t] = i._fn) : delete e[t], (n = !0));\n        }),\n        n\n      );\n    });\n  var yf = pf.map(function (t) {\n      var e = mf.indexOf(t) > -1;\n      return new vf(t, e);\n    }),\n    bf = {\n      extend: function (t, e, n, i) {\n        return ar("extend", t, e, n, i);\n      },\n      init: function (t, e, n) {\n        return ar("init", t, e, n);\n      },\n      reset: function (t) {\n        return Ef.filter(function (e) {\n          return e.reset && e.reset(t);\n        }).map(function (t) {\n          return t.name;\n        });\n      },\n    },\n    wf = {\n      adapt: Yc,\n      computed: bf,\n      css: cf,\n      data: ff,\n      helpers: bf,\n      template: df,\n    },\n    xf = Za(vo),\n    kf = ur(\n      xf.filter(function (t) {\n        return !wf[t];\n      })\n    ),\n    _f = ur(\n      xf.concat(\n        yf.map(function (t) {\n          return t.name;\n        }),\n        ["on", "observe", "attributes", "cssData", "use"]\n      )\n    ),\n    Ef = [].concat(\n      xf.filter(function (t) {\n        return !yf[t] && !wf[t];\n      }),\n      yf,\n      wf.template,\n      wf.css\n    ),\n    Sf = /\\b_super\\b/,\n    Af = function (t) {\n      (this.up = t.up),\n        (this.ractive = t.up.ractive),\n        (this.template = t.template),\n        (this.index = t.index),\n        (this.type = t.template.t),\n        (this.dirty = !1);\n    },\n    Cf = Af.prototype;\n  (Cf.bubble = function () {\n    this.dirty || ((this.dirty = !0), this.up.bubble());\n  }),\n    (Cf.destroyed = function () {\n      this.fragment && this.fragment.destroyed();\n    }),\n    (Cf.find = function () {\n      return null;\n    }),\n    (Cf.findComponent = function () {\n      return null;\n    }),\n    (Cf.findNextNode = function () {\n      return this.up.findNextNode(this);\n    }),\n    (Cf.rebound = function (t) {\n      this.fragment && this.fragment.rebound(t);\n    }),\n    (Cf.shuffled = function () {\n      this.fragment && this.fragment.shuffled();\n    }),\n    (Cf.valueOf = function () {\n      return this.toString();\n    }),\n    (Af.prototype.findAll = f),\n    (Af.prototype.findAllComponents = f);\n  var Of = (function (t) {\n      function e(e) {\n        t.call(this, e);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.detach = function () {\n          return this.fragment ? this.fragment.detach() : ii();\n        }),\n        (n.find = function (t) {\n          return this.fragment ? this.fragment.find(t) : void 0;\n        }),\n        (n.findAll = function (t, e) {\n          this.fragment && this.fragment.findAll(t, e);\n        }),\n        (n.findComponent = function (t) {\n          return this.fragment ? this.fragment.findComponent(t) : void 0;\n        }),\n        (n.findAllComponents = function (t, e) {\n          this.fragment && this.fragment.findAllComponents(t, e);\n        }),\n        (n.firstNode = function (t) {\n          return this.fragment && this.fragment.firstNode(t);\n        }),\n        (n.toString = function (t) {\n          return this.fragment ? this.fragment.toString(t) : "";\n        }),\n        e\n      );\n    })(Af),\n    Nf = /\\s+/,\n    jf = [\n      void 0,\n      "text",\n      "search",\n      "url",\n      "email",\n      "hidden",\n      "password",\n      "search",\n      "reset",\n      "submit",\n    ],\n    Tf = {\n      "accept-charset": "acceptCharset",\n      accesskey: "accessKey",\n      bgcolor: "bgColor",\n      class: "className",\n      codebase: "codeBase",\n      colspan: "colSpan",\n      contenteditable: "contentEditable",\n      datetime: "dateTime",\n      dirname: "dirName",\n      for: "htmlFor",\n      "http-equiv": "httpEquiv",\n      ismap: "isMap",\n      maxlength: "maxLength",\n      novalidate: "noValidate",\n      pubdate: "pubDate",\n      readonly: "readOnly",\n      rowspan: "rowSpan",\n      tabindex: "tabIndex",\n      usemap: "useMap",\n    },\n    Vf = Ja ? mc("div") : null,\n    Pf = !1,\n    Mf = (function (t) {\n      function e(e) {\n        t.call(this, e),\n          (this.attributes = []),\n          (this.owner = e.owner),\n          (this.fragment = new Gp({\n            ractive: this.ractive,\n            owner: this,\n            template: this.template,\n          })),\n          (this.fragment.findNextNode = f),\n          (this.dirty = !1);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.bind = function () {\n          this.fragment.bind();\n        }),\n        (n.bubble = function () {\n          this.dirty || ((this.dirty = !0), this.owner.bubble());\n        }),\n        (n.destroyed = function () {\n          this.unrender();\n        }),\n        (n.render = function () {\n          (this.node = this.owner.node),\n            this.node && (this.isSvg = this.node.namespaceURI === Cc),\n            (Pf = !0),\n            this.rendered || this.fragment.render(),\n            (this.rendered = !0),\n            (this.dirty = !0),\n            this.update(),\n            (Pf = !1);\n        }),\n        (n.toString = function () {\n          return this.fragment.toString();\n        }),\n        (n.unbind = function (t) {\n          this.fragment.unbind(t);\n        }),\n        (n.unrender = function () {\n          (this.rendered = !1), this.fragment.unrender();\n        }),\n        (n.update = function () {\n          var t,\n            e,\n            n = this;\n          if (this.dirty) {\n            this.dirty = !1;\n            var i = Pf;\n            (Pf = !0),\n              this.fragment.update(),\n              this.rendered &&\n                this.node &&\n                ((t = this.fragment.toString()),\n                (e = Or(t, this.isSvg)),\n                this.attributes\n                  .filter(function (t) {\n                    return Nr(e, t);\n                  })\n                  .forEach(function (t) {\n                    n.node.removeAttribute(t.name);\n                  }),\n                e.forEach(function (t) {\n                  n.node.setAttribute(t.name, t.value);\n                }),\n                (this.attributes = e)),\n              (Pf = i || !1);\n          }\n        }),\n        e\n      );\n    })(Af),\n    If = /^\\s*$/,\n    Rf = !1,\n    Bf = (function (t) {\n      function e(e) {\n        return (\n          t.call(this, e),\n          (this.name = e.template.n),\n          (this.namespace = null),\n          (this.owner = e.owner || e.up.owner || e.element || zn(e.up)),\n          (this.element =\n            e.element || (this.owner.attributeByName ? this.owner : zn(e.up))),\n          (this.up = e.up),\n          (this.ractive = this.up.ractive),\n          (this.rendered = !1),\n          (this.updateDelegate = null),\n          (this.fragment = null),\n          (this.element.attributeByName[this.name] = this),\n          Ga(e.template.f)\n            ? ((this.fragment = new Gp({\n                owner: this,\n                template: e.template.f,\n              })),\n              (this.interpolator =\n                this.fragment &&\n                1 === this.fragment.items.length &&\n                this.fragment.items[0].type === Ho &&\n                this.fragment.items[0]),\n              void (this.interpolator && (this.interpolator.owner = this)))\n            : ((this.value = e.template.f),\n              void (0 === this.value\n                ? (this.value = "")\n                : c(this.value) && (this.value = !0)))\n        );\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.bind = function () {\n          this.fragment && this.fragment.bind();\n        }),\n        (n.bubble = function () {\n          this.dirty ||\n            (this.up.bubble(), this.element.bubble(), (this.dirty = !0));\n        }),\n        (n.firstNode = function () {}),\n        (n.getString = function () {\n          Rf = !0;\n          var t = this.fragment\n            ? this.fragment.toString()\n            : null != this.value\n            ? "" + this.value\n            : "";\n          return (Rf = !1), t;\n        }),\n        (n.getValue = function () {\n          Rf = !0;\n          var t = this.fragment\n            ? this.fragment.valueOf()\n            : qu[this.name.toLowerCase()]\n            ? !0\n            : this.value;\n          return (Rf = !1), t;\n        }),\n        (n.render = function () {\n          var t = this.element.node;\n          if (\n            ((this.node = t),\n            (t.namespaceURI && t.namespaceURI !== Tc.html) ||\n              ((this.propertyName = Tf[this.name] || this.name),\n              void 0 !== t[this.propertyName] && (this.useProperty = !0),\n              (qu[this.name.toLowerCase()] || this.isTwoway) &&\n                (this.isBoolean = !0),\n              "value" === this.propertyName && (t._ractive.value = this.value)),\n            t.namespaceURI)\n          ) {\n            var e = this.name.indexOf(":");\n            -1 !== e\n              ? (this.namespace = jr(t, this.name.slice(0, e)))\n              : (this.namespace = t.namespaceURI);\n          }\n          (this.rendered = !0),\n            (this.updateDelegate = cr(this)),\n            this.updateDelegate();\n        }),\n        (n.toString = function () {\n          if (Cr()) return "";\n          Rf = !0;\n          var t = this.getValue();\n          if (\n            "value" !== this.name ||\n            (void 0 === this.element.getAttribute("contenteditable") &&\n              "select" !== this.element.name &&\n              "textarea" !== this.element.name)\n          ) {\n            if (\n              "name" === this.name &&\n              "input" === this.element.name &&\n              this.interpolator &&\n              "radio" === this.element.getAttribute("type")\n            )\n              return \'name="{{\' + this.interpolator.model.getKeypath() + \'}}"\';\n            if (\n              this.owner !== this.element ||\n              ("style" !== this.name &&\n                "class" !== this.name &&\n                !this.style &&\n                !this.inlineClass)\n            ) {\n              if (\n                !(\n                  this.rendered ||\n                  this.owner !== this.element ||\n                  (this.name.indexOf("style-") && this.name.indexOf("class-"))\n                )\n              )\n                return void (this.name.indexOf("style-")\n                  ? (this.inlineClass = this.name.substr(6))\n                  : (this.style = _e(this.name.substr(6))));\n              if (qu[this.name.toLowerCase()])\n                return t\n                  ? h(t)\n                    ? this.name + \'="\' + oi(t) + \'"\'\n                    : this.name\n                  : "";\n              if (null == t) return "";\n              var e = oi(this.getString());\n              return (Rf = !1), e ? this.name + \'="\' + e + \'"\' : this.name;\n            }\n          }\n        }),\n        (n.unbind = function (t) {\n          this.fragment && this.fragment.unbind(t);\n        }),\n        (n.unrender = function () {\n          this.updateDelegate(!0), (this.rendered = !1);\n        }),\n        (n.update = function () {\n          if (this.dirty) {\n            var t;\n            if (\n              ((this.dirty = !1),\n              this.fragment && this.fragment.update(),\n              this.rendered && this.updateDelegate(),\n              this.isTwoway && !this.locked)\n            )\n              this.interpolator.twowayBinding.lastVal(\n                !0,\n                this.interpolator.model.get()\n              );\n            else if ("value" === this.name && (t = this.element.binding)) {\n              var e = t.attribute;\n              e &&\n                !e.dirty &&\n                e.rendered &&\n                this.element.binding.attribute.updateDelegate();\n            }\n          }\n        }),\n        e\n      );\n    })(Af),\n    Kf = (function (t) {\n      function e(e) {\n        t.call(this, e),\n          (this.owner = e.owner || e.up.owner || zn(e.up)),\n          (this.element = this.owner.attributeByName ? this.owner : zn(e.up)),\n          (this.flag = "l" === e.template.v ? "lazy" : "twoway"),\n          (this.bubbler = this.owner === this.element ? this.element : this.up),\n          this.element.type === Yo &&\n            (Ga(e.template.f) &&\n              (this.fragment = new Gp({ owner: this, template: e.template.f })),\n            (this.interpolator =\n              this.fragment &&\n              1 === this.fragment.items.length &&\n              this.fragment.items[0].type === Ho &&\n              this.fragment.items[0]));\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.bind = function () {\n          this.fragment && this.fragment.bind(), Vr(this, this.getValue(), !0);\n        }),\n        (n.bubble = function () {\n          this.dirty || (this.bubbler.bubble(), (this.dirty = !0));\n        }),\n        (n.getValue = function () {\n          return this.fragment\n            ? this.fragment.valueOf()\n            : "value" in this\n            ? this.value\n            : "f" in this.template\n            ? this.template.f\n            : !0;\n        }),\n        (n.render = function () {\n          Vr(this, this.getValue(), !0);\n        }),\n        (n.toString = function () {\n          return "";\n        }),\n        (n.unbind = function (t) {\n          this.fragment && this.fragment.unbind(t),\n            delete this.element[this.flag];\n        }),\n        (n.unrender = function () {\n          this.element.rendered && this.element.recreateTwowayBinding();\n        }),\n        (n.update = function () {\n          this.dirty &&\n            ((this.dirty = !1),\n            this.fragment && this.fragment.update(),\n            Vr(this, this.getValue(), !0));\n        }),\n        e\n      );\n    })(Af),\n    Lf = $a(Af.prototype);\n  Ua(Lf, {\n    bind: f,\n    unbind: f,\n    update: f,\n    detach: function () {\n      return si(this.node);\n    },\n    firstNode: function () {\n      return this.node;\n    },\n    render: function (t) {\n      (this.rendered = !0),\n        (this.node = Ja.createComment(this.template.c)),\n        t.appendChild(this.node);\n    },\n    toString: function () {\n      return "\x3c!-- " + this.template.c + " --\x3e";\n    },\n    unrender: function (t) {\n      this.rendered && t && this.detach(), (this.rendered = !1);\n    },\n  }),\n    (Pr.prototype = Lf);\n  var Df = (function (t) {\n      function e(e) {\n        t.call(this, e, "@this"), (this.ractive = e);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.joinKey = function (e) {\n          var n = t.prototype.joinKey.call(this, e);\n          return ("root" !== e && "parent" !== e) || n.isLink\n            ? "data" === e\n              ? this.ractive.viewmodel\n              : "cssData" === e\n              ? this.ractive.constructor._cssModel\n              : n\n            : Rr(n, e);\n        }),\n        e\n      );\n    })(Kl),\n    Ff = {\n      "@this": function (t) {\n        return t.getRactiveModel();\n      },\n      "@global": function () {\n        return Dl;\n      },\n      "@shared": function () {\n        return Ll;\n      },\n      "@style": function (t) {\n        return t.getRactiveModel().joinKey("cssData");\n      },\n      "@helpers": function (t) {\n        return t.getHelpers();\n      },\n    };\n  Ff["@"] = Ff["@this"];\n  var zf = (function (t) {\n    function e(e) {\n      t.call(this, null, null),\n        (this.isRoot = !0),\n        (this.root = this),\n        (this.ractive = e.ractive),\n        (this.value = e.data),\n        (this.adaptors = e.adapt),\n        this.adapt();\n    }\n    t && (e.__proto__ = t);\n    var n = (e.prototype = Object.create(t && t.prototype));\n    return (\n      (n.constructor = e),\n      (n.attached = function (t) {\n        Br(this, t);\n      }),\n      (n.createLink = function (t, e, n, i) {\n        for (var r = S(t), s = this; r.length; ) {\n          var a = r.shift();\n          s = s.childByKey[a] || s.joinKey(a);\n        }\n        return s.link(e, n, i);\n      }),\n      (n.detached = function () {\n        Kr(this);\n      }),\n      (n.get = function (t, e) {\n        return (\n          t && H(this), e && e.virtual === !1 ? this.value : this.getVirtual()\n        );\n      }),\n      (n.getHelpers = function () {\n        return (\n          this.helpers ||\n            (this.helpers = new Kl(\n              this.ractive.helpers,\n              "helpers",\n              this.ractive\n            )),\n          this.helpers\n        );\n      }),\n      (n.getKeypath = function () {\n        return "";\n      }),\n      (n.getRactiveModel = function () {\n        return this.ractiveModel || (this.ractiveModel = new Df(this.ractive));\n      }),\n      (n.getValueChildren = function () {\n        var e = t.prototype.getValueChildren.call(this, this.value);\n        return (\n          this.children.forEach(function (t) {\n            if (t._link) {\n              var n = e.indexOf(t);\n              ~n ? e.splice(n, 1, t._link) : e.push(t._link);\n            }\n          }),\n          e\n        );\n      }),\n      (n.has = function (e) {\n        if (\n          ("~" === e[0] && "/" === e[1] && (e = e.slice(2)), Ff[e] || "" === e)\n        )\n          return !0;\n        if (t.prototype.has.call(this, e)) return !0;\n        var n = A(e);\n        return this.childByKey[n] && this.childByKey[n]._link ? !0 : void 0;\n      }),\n      (n.joinKey = function (e, n) {\n        if (("~" === e[0] && "/" === e[1] && (e = e.slice(2)), "@" !== e[0]))\n          return t.prototype.joinKey.call(this, e, n);\n        var i = Ff[e];\n        return i ? i(this) : void 0;\n      }),\n      (n.set = function (t) {\n        var e = this.wrapper;\n        if (e) {\n          var n = !e.reset || e.reset(t) === !1;\n          n &&\n            (e.teardown(),\n            (this.wrapper = null),\n            (this.value = t),\n            this.adapt());\n        } else (this.value = t), this.adapt();\n        this.deps.forEach(Q), this.children.forEach(Y);\n      }),\n      (n.retrieve = function () {\n        return this.wrapper ? this.wrapper.get() : this.value;\n      }),\n      (n.teardown = function () {\n        t.prototype.teardown.call(this),\n          this.ractiveModel && this.ractiveModel.teardown();\n      }),\n      e\n    );\n  })(Rl);\n  zf.prototype.update = f;\n  var Uf = [\n      "adaptors",\n      "components",\n      "decorators",\n      "easing",\n      "events",\n      "interpolators",\n      "partials",\n      "transitions",\n    ],\n    $f = ["computed", "helpers"],\n    qf = 0,\n    Hf = (function (t) {\n      function e(e, n) {\n        var i = this;\n        t.call(this, e);\n        var r = e.template;\n        (this.isAnchor = r.t === eu), (this.type = this.isAnchor ? eu : ru);\n        var s = r.m,\n          a = r.p || {};\n        if (\n          ("content" in a || (a.content = r.f || []),\n          (this._partials = a),\n          this.isAnchor)\n        )\n          (this.name = r.n), (this.addChild = $r), (this.removeChild = qr);\n        else {\n          var o = new n({ component: !0 });\n          (this.instance = o),\n            (this.name = r.e),\n            (o.el || o.target) &&\n              (y(\n                "The <" +\n                  this.name +\n                  "> component has a default \'" +\n                  (o.el ? "el" : "target") +\n                  "\' property; it has been disregarded"\n              ),\n              (o.el = o.target = null));\n          for (var u, l = e.up; l; ) {\n            if (l.owner.type === su) {\n              u = l.owner.container;\n              break;\n            }\n            l = l.parent;\n          }\n          (o.parent = this.up.ractive),\n            (o.container = u || null),\n            (o.root = o.parent.root),\n            (o.component = this),\n            Dr(this.instance, { partials: a }, n),\n            (r = this.template),\n            (s = r.m),\n            Ga(this.mappings)\n              ? (s = (s || []).concat(this.mappings))\n              : h(this.mappings) &&\n                (s = (s || []).concat(\n                  El.parse(this.mappings, { attributes: !0 }).t\n                )),\n            (o._inlinePartials = a);\n        }\n        if (((this.attributeByName = {}), (this.attributes = []), s)) {\n          var c = [];\n          s.forEach(function (t) {\n            switch (t.t) {\n              case nu:\n              case Iu:\n                i.attributes.push(sa({ owner: i, up: i.up, template: t }));\n                break;\n              case Bu:\n              case Ku:\n              case Ru:\n                break;\n              default:\n                c.push(t);\n            }\n          }),\n            c.length &&\n              this.attributes.push(\n                new Mf({ owner: this, up: this.up, template: c })\n              );\n        }\n        this.eventHandlers = [];\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.bind = function () {\n          this.isAnchor ||\n            (this.attributes.forEach(Z),\n            this.eventHandlers.forEach(Z),\n            ha(\n              this.instance,\n              { partials: this._partials },\n              { cssIds: this.up.cssIds }\n            ),\n            (this.instance.target || this.instance.el) && (this.extern = !0),\n            (this.bound = !0));\n        }),\n        (n.bubble = function () {\n          this.dirty || ((this.dirty = !0), this.up.bubble());\n        }),\n        (n.destroyed = function () {\n          !this.isAnchor &&\n            this.instance.fragment &&\n            this.instance.fragment.destroyed();\n        }),\n        (n.detach = function () {\n          return this.isAnchor\n            ? this.instance\n              ? this.instance.fragment.detach()\n              : ii()\n            : this.instance.fragment.detach();\n        }),\n        (n.find = function (t, e) {\n          return this.instance ? this.instance.fragment.find(t, e) : void 0;\n        }),\n        (n.findAll = function (t, e) {\n          this.instance && this.instance.fragment.findAll(t, e);\n        }),\n        (n.findComponent = function (t, e) {\n          return t && this.name !== t\n            ? this.instance.fragment\n              ? this.instance.fragment.findComponent(t, e)\n              : void 0\n            : this.instance;\n        }),\n        (n.findAllComponents = function (t, e) {\n          var n = e.result;\n          !this.instance || (t && this.name !== t) || n.push(this.instance),\n            this.instance && this.instance.findAllComponents(t, e);\n        }),\n        (n.firstNode = function (t) {\n          return this.instance ? this.instance.fragment.firstNode(t) : void 0;\n        }),\n        (n.getContext = function () {\n          for (var t = [], e = arguments.length; e--; ) t[e] = arguments[e];\n          return t.unshift(this.instance), nn.apply(null, t);\n        }),\n        (n.rebound = function (t) {\n          this.attributes.forEach(function (e) {\n            return e.rebound(t);\n          });\n        }),\n        (n.render = function (t, e) {\n          this.isAnchor\n            ? ((this.rendered = !0),\n              (this.target = t),\n              Zf.length ||\n                (Zf.push(this.ractive),\n                e\n                  ? ((this.occupants = e), Wr(), (this.occupants = null))\n                  : Nl.scheduleTask(Wr, !0)))\n            : (this.attributes.forEach(et),\n              this.eventHandlers.forEach(et),\n              this.extern\n                ? ((this.instance.delegate = !1), this.instance.render())\n                : ca(this.instance, t, null, e),\n              (this.rendered = !0));\n        }),\n        (n.shuffled = function () {\n          t.prototype.shuffled.call(this),\n            this.instance &&\n              !this.instance.isolated &&\n              this.instance.fragment &&\n              this.instance.fragment.shuffled();\n        }),\n        (n.toString = function () {\n          return this.instance ? this.instance.toHTML() : void 0;\n        }),\n        (n.unbind = function (t) {\n          this.isAnchor ||\n            ((this.bound = !1),\n            this.attributes.forEach(rt),\n            t\n              ? this.instance.fragment.unbind()\n              : Ir(this.instance, function () {\n                  return Nl.promise();\n                }));\n        }),\n        (n.unrender = function (t) {\n          (this.shouldDestroy = t),\n            this.isAnchor\n              ? (this.item && Zr(this, this.item),\n                (this.target = null),\n                Zf.length || (Zf.push(this.ractive), Nl.scheduleTask(Wr, !0)))\n              : (this.instance.unrender(),\n                (this.instance.el = this.instance.target = null),\n                this.attributes.forEach(st),\n                this.eventHandlers.forEach(st)),\n            (this.rendered = !1);\n        }),\n        (n.update = function () {\n          (this.dirty = !1),\n            this.instance &&\n              (this.instance.fragment.update(),\n              this.attributes.forEach(at),\n              this.eventHandlers.forEach(at));\n        }),\n        e\n      );\n    })(Af),\n    Zf = [],\n    Wf = (function (e) {\n      function n(t, n) {\n        e.call(this, t, n),\n          (this.isReadonly = !this.root.ractive.syncComputedChildren),\n          (this.dirty = !0),\n          (this.isComputed = !0);\n      }\n      e && (n.__proto__ = e);\n      var i = (n.prototype = Object.create(e && e.prototype));\n      i.constructor = n;\n      var r = { setRoot: {} };\n      return (\n        (r.setRoot.get = function () {\n          return this.parent.setRoot;\n        }),\n        (i.applyValue = function (t) {\n          if ((e.prototype.applyValue.call(this, t), !this.isReadonly)) {\n            for (var n = this.parent; n && n.shuffle; ) n = n.parent;\n            n && n.dependencies.forEach(Y);\n          }\n          this.setRoot && this.setRoot.set(this.setRoot.value);\n        }),\n        (i.get = function (t, e) {\n          if ((t && H(this), this.dirty)) {\n            var n = this.parent.get();\n            (this.value = n ? n[this.key] : void 0),\n              this.wrapper && (this.newWrapperValue = this.value),\n              this.adapt();\n          }\n          return (\n            (this.dirty = !1),\n            (e && "unwrap" in e ? e.unwrap !== !1 : t) && this.wrapper\n              ? this.wrapperValue\n              : this.value\n          );\n        }),\n        (i.handleChange = function () {\n          return this.dirty\n            ? void this.deps.forEach(Q)\n            : ((this.dirty = !0),\n              this.boundValue && (this.boundValue = null),\n              this.links.forEach(X),\n              this.deps.forEach(Q),\n              void this.children.forEach(Q));\n        }),\n        (i.joinKey = function (e) {\n          if (c(e) || "" === e) return this;\n          if (!t(this.childByKey, e)) {\n            var i = new n(this, e);\n            this.children.push(i), (this.childByKey[e] = i);\n          }\n          return this.childByKey[e];\n        }),\n        Object.defineProperties(i, r),\n        n\n      );\n    })(Rl),\n    Gf = (function (t) {\n      function e(e, n, i) {\n        t.call(this, e, i),\n          (this.signature = n),\n          (this.isReadonly = !this.signature.setter),\n          (this.isComputed = !0),\n          (this.dependencies = []),\n          (this.children = []),\n          (this.childByKey = {}),\n          (this.deps = []),\n          (this.dirty = !0),\n          (this.shuffle = void 0);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      n.constructor = e;\n      var r = { setRoot: {} };\n      return (\n        (r.setRoot.get = function () {\n          return this.signature.setter ? this : void 0;\n        }),\n        (n.get = function (t, e) {\n          if ((t && H(this), this.dirty)) {\n            var n = this.value;\n            (this.value = this.getValue()),\n              Nl.active()\n                ? i(n, this.value) || this.notifyUpstream()\n                : (Nl.start(),\n                  i(n, this.value) || this.notifyUpstream(),\n                  Nl.end()),\n              this.wrapper && (this.newWrapperValue = this.value),\n              this.adapt(),\n              (this.dirty = !1);\n          }\n          return K(\n            this,\n            this.wrapper && (e && "unwrap" in e ? e.unwrap !== !1 : t)\n              ? this.wrapperValue\n              : this.value,\n            !e || e.shouldBind !== !1\n          );\n        }),\n        (n.getContext = function () {\n          return this.parent.isRoot\n            ? this.root.ractive\n            : this.parent.get(!1, Vo);\n        }),\n        (n.getValue = function () {\n          $();\n          var t;\n          try {\n            t = this.signature.getter.call(\n              this.root.ractive,\n              this.getContext(),\n              this.getKeypath()\n            );\n          } catch (e) {\n            if (\n              (y(\n                "Failed to compute " +\n                  this.getKeypath() +\n                  ": " +\n                  (e.message || e)\n              ),\n              eo)\n            ) {\n              console.groupCollapsed &&\n                console.groupCollapsed(\n                  "%cshow details",\n                  "color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;"\n                );\n              var n = this.signature;\n              console.error(\n                e.name +\n                  ": " +\n                  e.message +\n                  "\\n\\n" +\n                  n.getterString +\n                  (n.getterUseStack ? "\\n\\n" + e.stack : "")\n              ),\n                console.groupCollapsed && console.groupEnd();\n            }\n          }\n          var i = q();\n          return (\n            this.parent.keypath &&\n              !~i.indexOf(this.parent) &&\n              i.push(this.parent),\n            this.setDependencies(i),\n            t\n          );\n        }),\n        (n.mark = function () {\n          this.handleChange();\n        }),\n        (n.rebind = function (t, e) {\n          t !== e && this.handleChange();\n        }),\n        (n.set = function (t) {\n          if (this.isReadonly)\n            throw new Error(\n              "Cannot set read-only computed value \'" + this.key + "\'"\n            );\n          this.signature.setter(t, this.getContext(), this.getKeypath()),\n            this.mark();\n        }),\n        (n.setDependencies = function (t) {\n          for (var e = this, n = this.dependencies.length; n--; ) {\n            var i = e.dependencies[n];\n            ~t.indexOf(i) || i.unregister(e);\n          }\n          for (n = t.length; n--; ) {\n            var r = t[n];\n            ~e.dependencies.indexOf(r) || r.register(e);\n          }\n          this.dependencies = t;\n        }),\n        (n.teardown = function () {\n          for (var e = this, n = this.dependencies.length; n--; )\n            e.dependencies[n] && e.dependencies[n].unregister(e);\n          this.parent.computed[this.key] === this &&\n            delete this.parent.computed[this.key],\n            t.prototype.teardown.call(this);\n        }),\n        Object.defineProperties(n, r),\n        e\n      );\n    })(Rl),\n    Qf = Gf.prototype,\n    Yf = Wf.prototype;\n  (Qf.handleChange = Yf.handleChange),\n    (Qf.joinKey = Yf.joinKey),\n    (Il.Computation = Gf);\n  var Jf = (function (t) {\n      function e(e, n) {\n        var i = this;\n        t.call(this, e.ractive.viewmodel, null),\n          (this.fragment = e),\n          (this.template = n),\n          (this.isReadonly = !0),\n          (this.isComputed = !0),\n          (this.dirty = !0),\n          (this.fn =\n            e.ractive.allowExpressions === !1 ? f : ft(n.s, n.r.length)),\n          (this.models = this.template.r.map(function (t) {\n            return Ye(i.fragment, t);\n          })),\n          (this.dependencies = []),\n          (this.shuffle = void 0),\n          this.bubble();\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.bubble = function (t) {\n          void 0 === t && (t = !0),\n            (this.keypath = void 0),\n            t && this.handleChange();\n        }),\n        (n.getKeypath = function () {\n          var t = this;\n          return this.template\n            ? (this.keypath ||\n                (this.keypath =\n                  "@" +\n                  this.template.s.replace(/_(\\d+)/g, function (e, n) {\n                    if (n >= t.models.length) return e;\n                    var i = t.models[n];\n                    return i ? i.getKeypath() : "@undefined";\n                  })),\n              this.keypath)\n            : "@undefined";\n        }),\n        (n.getValue = function () {\n          var t = this;\n          $();\n          var e;\n          try {\n            var n = this.models.map(function (t) {\n              return t ? t.get(!0) : void 0;\n            });\n            e = this.fn.apply(this.fragment.ractive, n);\n          } catch (i) {\n            y(\n              "Failed to compute " + this.getKeypath() + ": " + (i.message || i)\n            );\n          }\n          var r = q();\n          return (\n            this.dependencies\n              .filter(function (t) {\n                return !~r.indexOf(t);\n              })\n              .forEach(function (e) {\n                e.unregister(t), V(t.dependencies, e);\n              }),\n            r\n              .filter(function (e) {\n                return !~t.dependencies.indexOf(e);\n              })\n              .forEach(function (e) {\n                e.register(t), t.dependencies.push(e);\n              }),\n            e\n          );\n        }),\n        (n.notifyUpstream = function () {}),\n        (n.rebind = function (t, e, n) {\n          var i = this.models.indexOf(e);\n          ~i &&\n            ((t = ht(this.template.r[i], t, e)),\n            t !== e &&\n              (e.unregister(this),\n              this.models.splice(i, 1, t),\n              t && t.addShuffleRegister(this, "mark"))),\n            this.bubble(!n);\n        }),\n        (n.rebound = function (t) {\n          var e = this;\n          (this.models = this.template.r.map(function (t) {\n            return Ye(e.fragment, t);\n          })),\n            t && this.bubble(!0);\n        }),\n        (n.retrieve = function () {\n          return this.get();\n        }),\n        (n.teardown = function () {\n          var e = this;\n          (this.fragment = void 0),\n            this.dependencies &&\n              this.dependencies.forEach(function (t) {\n                return t.unregister(e);\n              }),\n            t.prototype.teardown.call(this);\n        }),\n        (n.unreference = function () {\n          t.prototype.unreference.call(this), Gr(this);\n        }),\n        (n.unregister = function (e) {\n          t.prototype.unregister.call(this, e), Gr(this);\n        }),\n        (n.unregisterLink = function (e) {\n          t.prototype.unregisterLink.call(this, e), Gr(this);\n        }),\n        e\n      );\n    })(Rl),\n    Xf = Jf.prototype,\n    td = Gf.prototype;\n  (Xf.get = td.get),\n    (Xf.handleChange = td.handleChange),\n    (Xf.joinKey = td.joinKey),\n    (Xf.mark = td.mark),\n    (Xf.unbind = f);\n  var ed = { update: f, teardown: f },\n    nd = function (t) {\n      (this.owner = t.owner || t.up.owner || zn(t.up)),\n        (this.element = this.owner.attributeByName ? this.owner : zn(t.up)),\n        (this.up = t.up || this.owner.up),\n        (this.ractive = this.up.ractive || this.owner.ractive);\n      var e = (this.template = t.template);\n      (this.name = e.n),\n        (this.node = null),\n        (this.handle = null),\n        this.element.decorators.push(this);\n    },\n    id = nd.prototype;\n  (id.bind = function () {\n    var t =\n      this.element === this.owner ? new Gp({ owner: this.owner }) : this.up;\n    Qr(this, this.template, t, { register: !0 });\n  }),\n    (id.bubble = function () {\n      this.dirty || ((this.dirty = !0), this.owner.bubble(), this.up.bubble());\n    }),\n    (id.destroyed = function () {\n      this.handle && (this.handle.teardown(), (this.handle = null)),\n        (this.shouldDestroy = !0);\n    }),\n    (id.handleChange = function () {\n      this.bubble();\n    }),\n    (id.rebound = function (t) {\n      this.model && this.model.rebound(t);\n    }),\n    (id.render = function () {\n      var t = this;\n      (this.shouldDestroy = !1), this.handle && this.unrender();\n      var e = this.ractive;\n      Nl.scheduleTask(function () {\n        if (t.element.rendered) {\n          var n = w("decorators", e, t.name);\n          if (!n) return g(_o(t.name, "decorator")), void (t.handle = ed);\n          t.node = t.element.node;\n          var i = t.model ? t.model.get() : [];\n          if (\n            ((lc.f = t.up),\n            (t.handle = n.apply(e, [t.node].concat(i))),\n            (lc.f = null),\n            !t.handle || !t.handle.teardown)\n          )\n            throw new Error(\n              "The \'" +\n                t.name +\n                "\' decorator must return an object with a teardown method"\n            );\n          t.shouldDestroy && t.destroyed();\n        }\n      }, !0);\n    }),\n    (id.shuffled = function () {\n      this.handle && this.handle.shuffled && this.handle.shuffled();\n    }),\n    (id.toString = function () {\n      return "";\n    }),\n    (id.unbind = function () {\n      Jr(this, this.template);\n    }),\n    (id.unrender = function (t) {\n      (t && !this.element.rendered) ||\n        !this.handle ||\n        (this.handle.teardown(), (this.handle = null));\n    }),\n    (id.update = function () {\n      var t = this.handle;\n      if (!this.dirty)\n        return void (\n          t &&\n          t.invalidate &&\n          Nl.scheduleTask(function () {\n            return t.invalidate();\n          }, !0)\n        );\n      if (((this.dirty = !1), t))\n        if (t.update) {\n          var e = this.model ? this.model.get() : [];\n          t.update.apply(this.ractive, e);\n        } else this.unrender(), this.render();\n    }),\n    (nd.prototype.firstNode = f);\n  var rd = (function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.toString = function () {\n          return "<!DOCTYPE" + this.template.a + ">";\n        }),\n        e\n      );\n    })(Af),\n    sd = rd.prototype;\n  sd.bind = sd.render = sd.teardown = sd.unbind = sd.unrender = sd.update = f;\n  var ad = function (t, e) {\n      void 0 === e && (e = "value"),\n        (this.element = t),\n        (this.ractive = t.ractive),\n        (this.attribute = t.attributeByName[e]);\n      var n = this.attribute.interpolator;\n      n.twowayBinding = this;\n      var i = n.model;\n      if (i.isReadonly && !i.setRoot) {\n        var r = i.getKeypath().replace(/^@/, "");\n        return (\n          b(\n            "Cannot use two-way binding on <" +\n              t.name +\n              "> element: " +\n              r +\n              " is read-only. To suppress this warning use <" +\n              t.name +\n              " twoway=\'false\'...>",\n            { ractive: this.ractive }\n          ),\n          !1\n        );\n      }\n      (this.attribute.isTwoway = !0), (this.model = i);\n      var s = i.get();\n      (this.wasUndefined = c(s)),\n        c(s) &&\n          this.getInitialValue &&\n          ((s = this.getInitialValue()), i.set(s)),\n        this.lastVal(!0, s);\n      var a = zn(this.element, !1, "form");\n      a && ((this.resetValue = s), a.formBindings.push(this));\n    },\n    od = ad.prototype;\n  (od.bind = function () {\n    this.model.registerTwowayBinding(this);\n  }),\n    (od.handleChange = function () {\n      var t = this,\n        e = this.getValue();\n      this.lastVal() !== e &&\n        (Nl.start(),\n        (this.attribute.locked = !0),\n        this.model.set(e),\n        this.lastVal(!0, e),\n        this.model.get() !== e\n          ? (this.attribute.locked = !1)\n          : Nl.scheduleTask(function () {\n              return (t.attribute.locked = !1);\n            }),\n        Nl.end());\n    }),\n    (od.lastVal = function (t, e) {\n      return t ? void (this.lastValue = e) : this.lastValue;\n    }),\n    (od.rebind = function (t, e) {\n      var n = this;\n      this.model && this.model === e && e.unregisterTwowayBinding(this),\n        t &&\n          ((this.model = t),\n          Nl.scheduleTask(function () {\n            return t.registerTwowayBinding(n);\n          }));\n    }),\n    (od.rebound = function () {\n      this.model && this.model.unregisterTwowayBinding(this),\n        (this.model = this.attribute.interpolator.model),\n        this.model && this.model.registerTwowayBinding(this);\n    }),\n    (od.render = function () {\n      (this.node = this.element.node),\n        (this.node._ractive.binding = this),\n        (this.rendered = !0);\n    }),\n    (od.setFromNode = function (t) {\n      this.model.set(t.value);\n    }),\n    (od.unbind = function () {\n      this.model && this.model.unregisterTwowayBinding(this);\n    }),\n    (ad.prototype.unrender = f);\n  var ud = (function (t) {\n      function e(e) {\n        t.call(this, e, "checked");\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.render = function () {\n          t.prototype.render.call(this),\n            this.element.on("change", Xr),\n            this.node.attachEvent && this.element.on("click", Xr);\n        }),\n        (n.unrender = function () {\n          this.element.off("change", Xr),\n            this.node.attachEvent && this.element.off("click", Xr);\n        }),\n        (n.getInitialValue = function () {\n          return !!this.element.getAttribute("checked");\n        }),\n        (n.getValue = function () {\n          return this.node.checked;\n        }),\n        (n.setFromNode = function (t) {\n          this.model.set(t.checked);\n        }),\n        e\n      );\n    })(ad),\n    hd = function (t, e, n) {\n      var i = this;\n      (this.model = e),\n        (this.hash = t),\n        (this.getValue = function () {\n          return (i.value = n.call(i)), i.value;\n        }),\n        (this.bindings = []);\n    },\n    ld = hd.prototype;\n  (ld.add = function (t) {\n    this.bindings.push(t);\n  }),\n    (ld.bind = function () {\n      var t = this;\n      (this.value = this.model.get()),\n        this.bindings.forEach(function (e) {\n          return e.lastVal(!0, t.value);\n        }),\n        this.model.registerTwowayBinding(this),\n        (this.bound = !0);\n    }),\n    (ld.remove = function (t) {\n      V(this.bindings, t), this.bindings.length || this.unbind();\n    }),\n    (ld.unbind = function () {\n      this.model.unregisterTwowayBinding(this),\n        (this.bound = !1),\n        delete this.model[this.hash];\n    }),\n    (hd.prototype.rebind = ad.prototype.rebind);\n  var cd = [].push,\n    fd = (function (t) {\n      function e(e) {\n        if (\n          (t.call(this, e, "name"),\n          (this.checkboxName = !0),\n          (this.group = ts("checkboxes", this.model, es)),\n          this.group.add(this),\n          this.noInitialValue && (this.group.noInitialValue = !0),\n          this.group.noInitialValue && this.element.getAttribute("checked"))\n        ) {\n          var n = this.model.get(),\n            i = this.element.getAttribute("value");\n          this.arrayContains(n, i) || cd.call(n, i);\n        }\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.bind = function () {\n          this.group.bound || this.group.bind();\n        }),\n        (n.getInitialValue = function () {\n          return (this.noInitialValue = !0), [];\n        }),\n        (n.getValue = function () {\n          return this.group.value;\n        }),\n        (n.handleChange = function () {\n          this.isChecked = this.element.node.checked;\n          var e = this.model.get();\n          this.group.value = void 0 === e ? [] : e.slice();\n          var n = this.element.getAttribute("value");\n          this.isChecked && !this.arrayContains(this.group.value, n)\n            ? this.group.value.push(n)\n            : !this.isChecked &&\n              this.arrayContains(this.group.value, n) &&\n              this.removeFromArray(this.group.value, n),\n            (this.lastValue = null),\n            t.prototype.handleChange.call(this);\n        }),\n        (n.render = function () {\n          t.prototype.render.call(this);\n          var e = this.node,\n            n = this.model.get(),\n            i = this.element.getAttribute("value");\n          Ga(n)\n            ? (this.isChecked = this.arrayContains(n, i))\n            : (this.isChecked = this.element.compare(n, i)),\n            (e.name = "{{" + this.model.getKeypath() + "}}"),\n            (e.checked = this.isChecked),\n            this.element.on("change", Xr),\n            this.node.attachEvent && this.element.on("click", Xr);\n        }),\n        (n.setFromNode = function (t) {\n          if (\n            (this.group.bindings.forEach(function (t) {\n              return (t.wasUndefined = !0);\n            }),\n            t.checked)\n          ) {\n            var e = this.group.getValue();\n            e.push(this.element.getAttribute("value")), this.group.model.set(e);\n          }\n        }),\n        (n.unbind = function () {\n          this.group.remove(this);\n        }),\n        (n.unrender = function () {\n          var t = this.element;\n          t.off("change", Xr), this.node.attachEvent && t.off("click", Xr);\n        }),\n        (n.arrayContains = function (t, e) {\n          for (var n = this, i = t.length; i--; )\n            if (n.element.compare(e, t[i])) return !0;\n          return !1;\n        }),\n        (n.removeFromArray = function (t, e) {\n          var n = this;\n          if (t)\n            for (var i = t.length; i--; )\n              n.element.compare(e, t[i]) && t.splice(i, 1);\n        }),\n        e\n      );\n    })(ad),\n    dd = (function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.getInitialValue = function () {\n          return this.element.fragment ? this.element.fragment.toString() : "";\n        }),\n        (n.getValue = function () {\n          return this.element.node.innerHTML;\n        }),\n        (n.render = function () {\n          t.prototype.render.call(this);\n          var e = this.element;\n          e.on("change", Xr),\n            e.on("blur", Xr),\n            this.ractive.lazy ||\n              (e.on("input", Xr), this.node.attachEvent && e.on("keyup", Xr));\n        }),\n        (n.setFromNode = function (t) {\n          this.model.set(t.innerHTML);\n        }),\n        (n.unrender = function () {\n          var t = this.element;\n          t.off("blur", Xr),\n            t.off("change", Xr),\n            t.off("input", Xr),\n            t.off("keyup", Xr);\n        }),\n        e\n      );\n    })(ad),\n    pd = (function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.getInitialValue = function () {\n          return "";\n        }),\n        (n.getValue = function () {\n          return this.node.value;\n        }),\n        (n.render = function () {\n          t.prototype.render.call(this);\n          var e = this.ractive.lazy,\n            n = !1,\n            i = this.element;\n          "lazy" in this.element && (e = this.element.lazy),\n            r(e) && ((n = +e), (e = !1)),\n            (this.handler = n ? is(n) : Xr);\n          var s = this.node;\n          i.on("change", Xr),\n            "file" !== s.type &&\n              (e ||\n                (i.on("input", this.handler),\n                s.attachEvent && i.on("keyup", this.handler)),\n              i.on("blur", ns));\n        }),\n        (n.unrender = function () {\n          var t = this.element;\n          (this.rendered = !1),\n            t.off("change", Xr),\n            t.off("input", this.handler),\n            t.off("keyup", this.handler),\n            t.off("blur", ns);\n        }),\n        e\n      );\n    })(ad),\n    md = (function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.getInitialValue = function () {\n          return void 0;\n        }),\n        (n.getValue = function () {\n          return this.node.files;\n        }),\n        (n.render = function () {\n          (this.element.lazy = !1), t.prototype.render.call(this);\n        }),\n        (n.setFromNode = function (t) {\n          this.model.set(t.files);\n        }),\n        e\n      );\n    })(pd),\n    vd = (function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.getInitialValue = function () {\n          return this.element.options\n            .filter(function (t) {\n              return t.getAttribute("selected");\n            })\n            .map(function (t) {\n              return t.getAttribute("value");\n            });\n        }),\n        (n.getValue = function () {\n          for (\n            var t = this.element.node.options, e = t.length, n = [], i = 0;\n            e > i;\n            i += 1\n          ) {\n            var r = t[i];\n            if (r.selected) {\n              var s = r._ractive ? r._ractive.value : r.value;\n              n.push(s);\n            }\n          }\n          return n;\n        }),\n        (n.handleChange = function () {\n          var e = this.attribute,\n            n = e.getValue(),\n            i = this.getValue();\n          return (\n            (c(n) || !N(i, n)) && t.prototype.handleChange.call(this), this\n          );\n        }),\n        (n.render = function () {\n          t.prototype.render.call(this),\n            this.element.on("change", Xr),\n            c(this.model.get()) && this.handleChange();\n        }),\n        (n.setFromNode = function (t) {\n          for (var e = rs(t), n = e.length, i = new Array(n); n--; ) {\n            var r = e[n];\n            i[n] = r._ractive ? r._ractive.value : r.value;\n          }\n          this.model.set(i);\n        }),\n        (n.unrender = function () {\n          this.element.off("change", Xr);\n        }),\n        e\n      );\n    })(ad),\n    gd = (function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.getInitialValue = function () {\n          return void 0;\n        }),\n        (n.getValue = function () {\n          var t = parseFloat(this.node.value);\n          return isNaN(t) ? void 0 : t;\n        }),\n        (n.setFromNode = function (t) {\n          var e = parseFloat(t.value);\n          isNaN(e) || this.model.set(e);\n        }),\n        e\n      );\n    })(pd),\n    yd = {},\n    bd = (function (t) {\n      function e(e) {\n        t.call(this, e, "checked"),\n          (this.siblings = ss(\n            this.ractive._guid + this.element.getAttribute("name")\n          )),\n          this.siblings.push(this);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.getValue = function () {\n          return this.node.checked;\n        }),\n        (n.handleChange = function () {\n          Nl.start(),\n            this.siblings.forEach(function (t) {\n              t.model.set(t.getValue());\n            }),\n            Nl.end();\n        }),\n        (n.render = function () {\n          t.prototype.render.call(this),\n            this.element.on("change", Xr),\n            this.node.attachEvent && this.element.on("click", Xr);\n        }),\n        (n.setFromNode = function (t) {\n          this.model.set(t.checked);\n        }),\n        (n.unbind = function () {\n          V(this.siblings, this);\n        }),\n        (n.unrender = function () {\n          this.element.off("change", Xr),\n            this.node.attachEvent && this.element.off("click", Xr);\n        }),\n        e\n      );\n    })(ad),\n    wd = (function (t) {\n      function e(e) {\n        var n = this;\n        t.call(this, e, "name"),\n          (this.group = ts("radioname", this.model, as)),\n          this.group.add(this),\n          e.checked && (this.group.value = this.getValue()),\n          (this.attribute.interpolator.pathChanged = function () {\n            return n.updateName();\n          });\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.bind = function () {\n          this.group.bound || this.group.bind();\n        }),\n        (n.getInitialValue = function () {\n          return this.element.getAttribute("checked")\n            ? this.element.getAttribute("value")\n            : void 0;\n        }),\n        (n.getValue = function () {\n          return this.element.getAttribute("value");\n        }),\n        (n.handleChange = function () {\n          this.node.checked &&\n            ((this.group.value = this.getValue()),\n            t.prototype.handleChange.call(this)),\n            this.updateName();\n        }),\n        (n.lastVal = function (t, e) {\n          return this.group\n            ? t\n              ? void (this.group.lastValue = e)\n              : this.group.lastValue\n            : void 0;\n        }),\n        (n.rebind = function (e, n) {\n          t.prototype.rebind.call(this, e, n), this.updateName();\n        }),\n        (n.rebound = function (e) {\n          t.prototype.rebound.call(this, e), this.updateName();\n        }),\n        (n.render = function () {\n          t.prototype.render.call(this);\n          var e = this.node;\n          this.updateName(),\n            (e.checked = this.element.compare(\n              this.model.get(),\n              this.element.getAttribute("value")\n            )),\n            this.element.on("change", Xr),\n            e.attachEvent && this.element.on("click", Xr);\n        }),\n        (n.setFromNode = function (t) {\n          t.checked && this.group.model.set(this.element.getAttribute("value"));\n        }),\n        (n.unbind = function () {\n          this.group.remove(this);\n        }),\n        (n.unrender = function () {\n          var t = this.element;\n          t.off("change", Xr), this.node.attachEvent && t.off("click", Xr);\n        }),\n        (n.updateName = function () {\n          this.node && (this.node.name = "{{" + this.model.getKeypath() + "}}");\n        }),\n        e\n      );\n    })(ad),\n    xd = (function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.forceUpdate = function () {\n          var t = this,\n            e = this.getValue();\n          void 0 !== e &&\n            ((this.attribute.locked = !0),\n            Nl.scheduleTask(function () {\n              return (t.attribute.locked = !1);\n            }),\n            this.model.set(e));\n        }),\n        (n.getInitialValue = function () {\n          if (void 0 === this.element.getAttribute("value")) {\n            var t = this.element.options,\n              e = t.length;\n            if (e) {\n              for (var n, i, r = e; r--; ) {\n                var s = t[r];\n                if (s.getAttribute("selected")) {\n                  s.getAttribute("disabled") || (n = s.getAttribute("value")),\n                    (i = !0);\n                  break;\n                }\n              }\n              if (!i)\n                for (; ++r < e; )\n                  if (!t[r].getAttribute("disabled")) {\n                    n = t[r].getAttribute("value");\n                    break;\n                  }\n              return (\n                void 0 !== n && (this.element.attributeByName.value.value = n),\n                n\n              );\n            }\n          }\n        }),\n        (n.getValue = function () {\n          var t,\n            e = this.node.options,\n            n = e.length;\n          for (t = 0; n > t; t += 1) {\n            var i = e[t];\n            if (e[t].selected && !e[t].disabled)\n              return i._ractive ? i._ractive.value : i.value;\n          }\n        }),\n        (n.render = function () {\n          t.prototype.render.call(this), this.element.on("change", Xr);\n        }),\n        (n.setFromNode = function (t) {\n          var e = rs(t)[0];\n          this.model.set(e._ractive ? e._ractive.value : e.value);\n        }),\n        (n.unrender = function () {\n          this.element.off("change", Xr);\n        }),\n        e\n      );\n    })(ad),\n    kd = /;\\s*$/,\n    _d = (function (t) {\n      function e(e) {\n        var n = this;\n        if (\n          (t.call(this, e),\n          (this.name = e.template.e.toLowerCase()),\n          (this.parent = zn(this.up, !1)),\n          this.parent && "option" === this.parent.name)\n        )\n          throw new Error(\n            "An <option> element cannot contain other elements (encountered <" +\n              this.name +\n              ">)"\n          );\n        (this.decorators = []), (this.attributeByName = {});\n        for (\n          var i,\n            r,\n            s,\n            a,\n            o,\n            u,\n            l,\n            c,\n            f = this.template.m,\n            d = (f && f.length) || 0,\n            p = 0;\n          d > p;\n          p++\n        )\n          if (((l = f[p]), l.g))\n            (n.statics || (n.statics = {}))[l.n] = h(l.f) ? l.f : l.n;\n          else\n            switch (l.t) {\n              case nu:\n              case Ku:\n              case Ru:\n              case Iu:\n              case Bu:\n                (s = sa({ owner: n, up: n.up, template: l })),\n                  (r = l.n),\n                  (i = i || (i = n.attributes = [])),\n                  "value" === r\n                    ? (a = s)\n                    : "name" === r\n                    ? (u = s)\n                    : "class" === r\n                    ? (o = s)\n                    : i.push(s);\n                break;\n              case Lu:\n                n.delegate = !1;\n                break;\n              default:\n                (c || (c = [])).push(l);\n            }\n        a && i.push(a),\n          u && i.push(u),\n          o && i.unshift(o),\n          c &&\n            ((i || (this.attributes = [])).push(\n              new Mf({ owner: this, up: this.up, template: c })\n            ),\n            (c = [])),\n          e.template.f &&\n            !e.deferContent &&\n            (this.fragment = new Gp({\n              template: e.template.f,\n              owner: this,\n              cssIds: null,\n            })),\n          (this.binding = null);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.bind = function () {\n          var t = this.attributes;\n          if (t) {\n            t.binding = !0;\n            for (var e = t.length, n = 0; e > n; n++) t[n].bind();\n            t.binding = !1;\n          }\n          this.fragment && this.fragment.bind(),\n            this.binding ? this.binding.bind() : this.recreateTwowayBinding();\n        }),\n        (n.createTwowayBinding = function () {\n          if ("twoway" in this ? this.twoway : this.ractive.twoway) {\n            var t = us(this);\n            if (t) {\n              var e = new t(this);\n              if (e && e.model) return e;\n            }\n          }\n        }),\n        (n.destroyed = function () {\n          this.attributes && this.attributes.forEach(G),\n            this.fragment && this.fragment.destroyed();\n        }),\n        (n.detach = function () {\n          return this.rendered || this.destroyed(), si(this.node);\n        }),\n        (n.find = function (t, e) {\n          return this.node && vc(this.node, t)\n            ? this.node\n            : this.fragment\n            ? this.fragment.find(t, e)\n            : void 0;\n        }),\n        (n.findAll = function (t, e) {\n          var n = e.result;\n          vc(this.node, t) && n.push(this.node),\n            this.fragment && this.fragment.findAll(t, e);\n        }),\n        (n.findNextNode = function () {\n          return null;\n        }),\n        (n.firstNode = function () {\n          return this.node;\n        }),\n        (n.getAttribute = function (t) {\n          if (this.statics && t in this.statics) return this.statics[t];\n          var e = this.attributeByName[t];\n          return e ? e.getValue() : void 0;\n        }),\n        (n.getContext = function () {\n          for (var t = [], e = arguments.length; e--; ) t[e] = arguments[e];\n          return this.fragment\n            ? (n = this.fragment).getContext.apply(n, t)\n            : (this.ctx || (this.ctx = new fc(this.up, this)),\n              t.unshift($a(this.ctx)),\n              Ua.apply(null, t));\n          var n;\n        }),\n        (n.off = function (t, e, n) {\n          void 0 === n && (n = !1);\n          var i = this.up.delegate,\n            r = this.listeners && this.listeners[t];\n          if (r)\n            if ((V(r, e), i)) {\n              var s =\n                (i.listeners || (i.listeners = [])) &&\n                (i.listeners[t] || (i.listeners[t] = []));\n              s.refs && !--s.refs && i.off(t, ms, !0);\n            } else if (this.rendered) {\n              var a = this.node,\n                o = a.addEventListener,\n                u = a.removeEventListener;\n              r.length\n                ? r.length &&\n                  !r.refs &&\n                  n &&\n                  (u.call(a, t, gs, !0), o.call(a, t, gs, !1))\n                : u.call(a, t, gs, n);\n            }\n        }),\n        (n.on = function (t, e, n) {\n          void 0 === n && (n = !1);\n          var i = this.up.delegate,\n            r =\n              (this.listeners || (this.listeners = {}))[t] ||\n              (this.listeners[t] = []);\n          if (i) {\n            var s =\n              ((i.listeners || (i.listeners = [])) && i.listeners[t]) ||\n              (i.listeners[t] = []);\n            s.refs ? s.refs++ : ((s.refs = 0), i.on(t, ms, !0), s.refs++);\n          } else if (this.rendered) {\n            var a = this.node,\n              o = a.addEventListener,\n              u = a.removeEventListener;\n            r.length\n              ? r.length &&\n                !r.refs &&\n                n &&\n                (u.call(a, t, gs, !1), o.call(a, t, gs, !0))\n              : o.call(a, t, gs, n);\n          }\n          C(this.listeners[t], e);\n        }),\n        (n.recreateTwowayBinding = function () {\n          this.binding && (this.binding.unbind(), this.binding.unrender()),\n            (this.binding = this.createTwowayBinding()) &&\n              (this.binding.bind(), this.rendered && this.binding.render());\n        }),\n        (n.rebound = function (e) {\n          t.prototype.rebound.call(this, e),\n            this.attributes &&\n              this.attributes.forEach(function (t) {\n                return t.rebound(e);\n              }),\n            this.binding && this.binding.rebound(e);\n        }),\n        (n.render = function (t, e) {\n          var n = this;\n          this.namespace = cs(this);\n          var i,\n            r = !1;\n          if (e)\n            for (var s; (s = e.shift()); ) {\n              if (\n                s.nodeName.toUpperCase() === n.template.e.toUpperCase() &&\n                s.namespaceURI === n.namespace\n              ) {\n                (n.node = i = s), (r = !0);\n                break;\n              }\n              si(s);\n            }\n          if (\n            (!r && this.node && ((i = this.node), t.appendChild(i), (r = !0)),\n            !i)\n          ) {\n            var a = this.template.e;\n            (i = mc(\n              this.namespace === Sc ? a.toLowerCase() : a,\n              this.namespace,\n              this.getAttribute("is")\n            )),\n              (this.node = i);\n          }\n          qa(i, "_ractive", { value: { proxy: this }, configurable: !0 }),\n            this.statics &&\n              Za(this.statics).forEach(function (t) {\n                i.setAttribute(t, n.statics[t]);\n              }),\n            r && this.foundNode && this.foundNode(i);\n          var o = this.intro;\n          if (\n            (o &&\n              o.shouldFire("intro") &&\n              ((o.isIntro = !0), (o.isOutro = !1), Nl.registerTransition(o)),\n            this.fragment)\n          ) {\n            var u = r ? M(i.childNodes) : void 0;\n            this.fragment.render(i, u), u && u.forEach(si);\n          }\n          if (r) {\n            this.binding &&\n              this.binding.wasUndefined &&\n              this.binding.setFromNode(i);\n            for (var h = i.attributes.length; h--; ) {\n              var l = i.attributes[h].name;\n              l in n.attributeByName ||\n                (n.statics && l in n.statics) ||\n                i.removeAttribute(l);\n            }\n          }\n          if (\n            (this.up.cssIds &&\n              i.setAttribute(\n                "data-ractive-css",\n                this.up.cssIds\n                  .map(function (t) {\n                    return "{" + t + "}";\n                  })\n                  .join(" ")\n              ),\n            this.attributes)\n          )\n            for (var c = this.attributes.length, f = 0; c > f; f++)\n              n.attributes[f].render();\n          if (\n            (this.binding && this.binding.render(),\n            !this.up.delegate && this.listeners)\n          ) {\n            var d = this.listeners;\n            for (var p in d)\n              d[p] &&\n                d[p].length &&\n                n.node.addEventListener(p, gs, !!d[p].refs);\n          }\n          r || t.appendChild(i), (this.rendered = !0);\n        }),\n        (n.shuffled = function () {\n          t.prototype.shuffled.call(this), this.decorators.forEach(nt);\n        }),\n        (n.toString = function () {\n          var t = this,\n            e = this.template.e,\n            n = (this.attributes && this.attributes.map(ls).join("")) || "";\n          this.statics &&\n            Za(this.statics).forEach(function (e) {\n              return (\n                "class" !== e &&\n                "style" !== e &&\n                (n = " " + e + \'="\' + oi(t.statics[e]) + \'"\' + n)\n              );\n            }),\n            "option" === this.name && this.isSelected() && (n += " selected"),\n            "input" === this.name && hs(this) && (n += " checked");\n          var i = this.statics ? this.statics.style : void 0,\n            r = this.statics ? this.statics["class"] : void 0;\n          this.attributes &&\n            this.attributes.forEach(function (t) {\n              "class" === t.name\n                ? (r = (r || "") + (r ? " " : "") + oi(t.getString()))\n                : "style" === t.name\n                ? ((i = (i || "") + (i ? " " : "") + oi(t.getString())),\n                  i && !kd.test(i) && (i += ";"))\n                : t.style\n                ? (i =\n                    (i || "") +\n                    (i ? " " : "") +\n                    t.style +\n                    ": " +\n                    oi(t.getString()) +\n                    ";")\n                : t.inlineClass &&\n                  t.getValue() &&\n                  (r = (r || "") + (r ? " " : "") + t.inlineClass);\n            }),\n            void 0 !== i && (n = " style" + (i ? \'="\' + i + \'"\' : "") + n),\n            void 0 !== r && (n = " class" + (r ? \'="\' + r + \'"\' : "") + n),\n            this.up.cssIds &&\n              (n +=\n                \' data-ractive-css="\' +\n                this.up.cssIds\n                  .map(function (t) {\n                    return "{" + t + "}";\n                  })\n                  .join(" ") +\n                \'"\');\n          var s = "<" + e + n + ">";\n          return Hu[this.name.toLowerCase()]\n            ? s\n            : ("textarea" === this.name && void 0 !== this.getAttribute("value")\n                ? (s += bt(this.getAttribute("value")))\n                : void 0 !== this.getAttribute("contenteditable") &&\n                  (s += this.getAttribute("value") || ""),\n              this.fragment &&\n                (s += this.fragment.toString(\n                  !/^(?:script|style)$/i.test(this.template.e)\n                )),\n              (s += "</" + e + ">"));\n        }),\n        (n.unbind = function (t) {\n          var e = this.attributes;\n          if (e) {\n            e.unbinding = !0;\n            for (var n = e.length, i = 0; n > i; i++) e[i].unbind(t);\n            e.unbinding = !1;\n          }\n          this.binding && this.binding.unbind(t),\n            this.fragment && this.fragment.unbind(t);\n        }),\n        (n.unrender = function (t) {\n          if (this.rendered) {\n            this.rendered = !1;\n            var e = this.intro;\n            e && e.complete && e.complete(),\n              "option" === this.name\n                ? this.detach()\n                : t && Nl.detachWhenReady(this);\n            var n = this.outro;\n            n &&\n              n.shouldFire("outro") &&\n              ((n.isIntro = !1), (n.isOutro = !0), Nl.registerTransition(n)),\n              this.fragment && this.fragment.unrender(),\n              this.binding && this.binding.unrender();\n          }\n        }),\n        (n.update = function () {\n          if (this.dirty) {\n            this.dirty = !1;\n            var t = this.attributes;\n            if (t) for (var e = t.length, n = 0; e > n; n++) t[n].update();\n            this.fragment && this.fragment.update();\n          }\n        }),\n        e\n      );\n    })(Of),\n    Ed = !1,\n    Sd = !1,\n    Ad = !1,\n    Cd = null !== Ya ? Ya.UIEvent : null,\n    Od = (function (t) {\n      function e(e) {\n        t.call(this, e), (this.formBindings = []);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.render = function (e, n) {\n          t.prototype.render.call(this, e, n), this.on("reset", ys);\n        }),\n        (n.unrender = function (e) {\n          this.off("reset", ys), t.prototype.unrender.call(this, e);\n        }),\n        e\n      );\n    })(_d),\n    Nd = function (t, e) {\n      -1 !== t.indexOf("*") &&\n        p(\n          \'Only component proxy-events may contain "*" wildcards, <\' +\n            e.name +\n            " on-" +\n            t +\n            \'="..."/> is not valid\'\n        ),\n        (this.name = t),\n        (this.owner = e),\n        (this.handler = null);\n    },\n    jd = Nd.prototype;\n  (jd.bind = function () {}),\n    (jd.render = function (t) {\n      var e = this,\n        n = this.name,\n        i = function () {\n          var i = e.owner.node;\n          e.owner.on(\n            n,\n            (e.handler = function (e) {\n              return t.fire({ node: i, original: e, event: e, name: n });\n            })\n          );\n        };\n      "load" !== n ? Nl.scheduleTask(i, !0) : i();\n    }),\n    (jd.unbind = function () {}),\n    (jd.unrender = function () {\n      this.handler && this.owner.off(this.name, this.handler);\n    });\n  var Td = function (t, e, n, i) {\n      (this.eventPlugin = t),\n        (this.owner = e),\n        (this.name = n),\n        (this.handler = null),\n        (this.args = i);\n    },\n    Vd = Td.prototype;\n  (Vd.bind = function () {}),\n    (Vd.render = function (t) {\n      var e = this;\n      Nl.scheduleTask(function () {\n        var n = e.owner.node;\n        (lc.f = t.up),\n          (e.handler = e.eventPlugin.apply(\n            e.owner.ractive,\n            [\n              n,\n              function (i) {\n                return (\n                  void 0 === i && (i = {}),\n                  i.original ? (i.event = i.original) : (i.original = i.event),\n                  (i.name = e.name),\n                  (i.node = i.node || n),\n                  t.fire(i)\n                );\n              },\n            ].concat(e.args || [])\n          )),\n          (lc.f = null);\n      });\n    }),\n    (Vd.unbind = function () {}),\n    (Vd.unrender = function () {\n      var t = this;\n      this.handler\n        ? this.handler.teardown()\n        : Nl.scheduleTask(function () {\n            return t.handler && t.handler.teardown();\n          });\n    });\n  var Pd = function (t, e) {\n      (this.component = t), (this.name = e), (this.handler = null);\n    },\n    Md = Pd.prototype;\n  (Md.bind = function (t) {\n    var e = this.component.instance;\n    this.handler = e.on(this.name, function () {\n      for (var n = [], i = arguments.length; i--; ) n[i] = arguments[i];\n      if (n[0] instanceof fc) {\n        var r = n.shift();\n        (r.component = e), t.fire(r, n);\n      } else t.fire({}, n);\n      return !1;\n    });\n  }),\n    (Md.render = function () {}),\n    (Md.unbind = function () {\n      this.handler.cancel();\n    }),\n    (Md.unrender = function () {});\n  var Id = /^(event|arguments|@node|@event|@context)(\\..+)?$/,\n    Rd = /^\\$(\\d+)(\\..+)?$/,\n    Bd = function (t) {\n      (this.owner = t.owner || t.up.owner || zn(t.up)),\n        (this.element = this.owner.attributeByName ? this.owner : zn(t.up, !0)),\n        (this.template = t.template),\n        (this.up = t.up),\n        (this.ractive = t.up.ractive),\n        (this.events = []);\n    },\n    Kd = Bd.prototype;\n  (Kd.bind = function () {\n    var t = this;\n    if (\n      (this.events.length &&\n        (this.events.forEach(function (t) {\n          return t.unrender();\n        }),\n        (this.events = [])),\n      this.element.type === ru || this.element.type === eu)\n    )\n      this.template.n.forEach(function (e) {\n        t.events.push(new Pd(t.element, e));\n      });\n    else {\n      var e;\n      if ((e = this.template.a)) {\n        var n = e.r.map(function (e) {\n          var n = Ye(t.up, e);\n          return n ? n.get() : void 0;\n        });\n        try {\n          e = ft(e.s, n.length).apply(null, n);\n        } catch (i) {\n          (e = null),\n            y(\n              "Failed to compute args for event on-" +\n                this.template.n.join("- ") +\n                ": " +\n                (i.message || i)\n            );\n        }\n      }\n      this.template.n.forEach(function (n) {\n        var i = w("events", t.ractive, n);\n        i\n          ? t.events.push(new Td(i, t.element, n, e))\n          : t.events.push(new Nd(n, t.element));\n      });\n    }\n    (this.models = null),\n      C(this.element.events || (this.element.events = []), this),\n      Qr(this, this.template),\n      this.fn || (this.action = this.template.f),\n      this.events.forEach(function (e) {\n        return e.bind(t);\n      });\n  }),\n    (Kd.destroyed = function () {\n      this.events.forEach(function (t) {\n        return t.unrender();\n      });\n    }),\n    (Kd.fire = function (t, e) {\n      var n = this;\n      void 0 === e && (e = []);\n      var i = t instanceof fc && t.refire ? t : this.element.getContext(t);\n      if (this.fn) {\n        var r = [],\n          s = Yr(this, this.template, this.up, {\n            specialRef: function (t) {\n              var e = Id.exec(t);\n              if (e)\n                return { special: e[1], keys: e[2] ? S(e[2].substr(1)) : [] };\n              var n = Rd.exec(t);\n              return n\n                ? {\n                    special: "arguments",\n                    keys: [n[1] - 1].concat(n[2] ? S(n[2].substr(1)) : []),\n                  }\n                : void 0;\n            },\n          });\n        s &&\n          s.forEach(function (s) {\n            if (!s) return r.push(void 0);\n            if (s.special) {\n              var a,\n                o = s.special;\n              "@node" === o\n                ? (a = n.element.node)\n                : "@event" === o\n                ? (a = t && t.event)\n                : "event" === o\n                ? (b(\n                    "The event reference available to event directives is deprecated and should be replaced with @context and @event"\n                  ),\n                  (a = i))\n                : (a = "@context" === o ? i : e);\n              for (var u = s.keys.slice(); a && u.length; ) a = a[u.shift()];\n              return r.push(a);\n            }\n            return s.wrapper ? r.push(s.wrapperValue) : void r.push(s.get());\n          });\n        var a = this.ractive,\n          o = a.event;\n        a.event = i;\n        var u = this.fn.apply(a, r),\n          l = u.pop();\n        if (l === !1) {\n          var c = t ? t.original : void 0;\n          c\n            ? (c.preventDefault && c.preventDefault(),\n              c.stopPropagation && c.stopPropagation())\n            : b(\n                "handler \'" +\n                  this.template.n.join(" ") +\n                  "\' returned false, but there is no event available to cancel"\n              );\n        } else\n          !u.length &&\n            Ga(l) &&\n            h(l[0]) &&\n            (l = wn(this.ractive, l.shift(), i, l));\n        return (a.event = o), l;\n      }\n      return wn(this.ractive, this.action, i, e);\n    }),\n    (Kd.handleChange = function () {}),\n    (Kd.render = function () {\n      var t = this;\n      this.events.forEach(function (e) {\n        return e.render(t);\n      });\n    }),\n    (Kd.toString = function () {\n      return "";\n    }),\n    (Kd.unbind = function (t) {\n      V(this.element.events, this),\n        this.events.forEach(function (e) {\n          return e.unbind(t);\n        });\n    }),\n    (Kd.unrender = function () {\n      this.events.forEach(function (t) {\n        return t.unrender();\n      });\n    });\n  var Ld = Bd.prototype;\n  Ld.firstNode = Ld.rebound = Ld.update = f;\n  var Dd = (function (t) {\n      function e(e, n) {\n        t.call(this, null, null, null, "@undefined"),\n          (this.root = e.ractive.viewmodel),\n          (this.template = n),\n          (this.rootLink = !0),\n          (this.template = n),\n          (this.fragment = e),\n          this.rebound();\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.getKeypath = function () {\n          return this.model ? this.model.getKeypath() : "@undefined";\n        }),\n        (n.rebound = function () {\n          var t,\n            e = this,\n            n = this.fragment,\n            i = this.template,\n            r = (this.base = _s(n, i));\n          this.proxy && xs(this);\n          var s = (this.proxy = {\n            rebind: function (n, o) {\n              o === r\n                ? ((n = ht(i, n, o)), n !== r && (e.base = r = n))\n                : ~(t = a.indexOf(o)) &&\n                  ((n = ht(i.m[t].n, n, o)),\n                  n !== a[t] && a.splice(t, 1, n || Bo)),\n                n !== o &&\n                  (o.unregister(s),\n                  n &&\n                    n.addShuffleTask(function () {\n                      return n.register(s);\n                    }));\n            },\n            handleChange: function () {\n              o();\n            },\n          });\n          r.register(s);\n          var a = (this.members = i.m.map(function (t) {\n              if (h(t))\n                return {\n                  get: function () {\n                    return t;\n                  },\n                };\n              var e;\n              return t.t === yu\n                ? ((e = Ye(n, t.n)), e.register(s), e)\n                : ((e = new Jf(n, t)), e.register(s), e);\n            })),\n            o = function () {\n              var t =\n                r &&\n                r.joinAll(\n                  a.reduce(function (t, e) {\n                    var n = e.get();\n                    return Ga(n) ? t.concat(n) : (t.push(_(String(n))), t);\n                  }, [])\n                );\n              t !== e.model &&\n                ((e.model = t),\n                e.relinking(t),\n                F(),\n                ks(e),\n                e.fragment.shuffled());\n            };\n          o();\n        }),\n        (n.teardown = function () {\n          xs(this), t.prototype.teardown.call(this);\n        }),\n        (n.unreference = function () {\n          t.prototype.unreference.call(this),\n            this.deps.length || this.refs || this.teardown();\n        }),\n        (n.unregister = function (e) {\n          t.prototype.unregister.call(this, e),\n            this.deps.length || this.refs || this.teardown();\n        }),\n        e\n      );\n    })(Ko),\n    Fd = Jf.prototype,\n    zd = Dd.prototype;\n  (zd.unreference = Fd.unreference),\n    (zd.unregister = Fd.unregister),\n    (zd.unregisterLink = Fd.unregisterLink);\n  var Ud = (function (t) {\n      function e(e) {\n        t.call(this, e),\n          e.owner && (this.parent = e.owner),\n          (this.isStatic = !!e.template.s),\n          (this.model = null),\n          (this.dirty = !1);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.bind = function (t) {\n          var e = this.template.y\n              ? this.template.y.containerFragment\n              : this.containerFragment || this.up,\n            n = t || _s(e, this.template);\n          if (n) {\n            var i = n.get();\n            if (this.isStatic)\n              return (\n                (this.model = {\n                  get: function () {\n                    return i;\n                  },\n                }),\n                void n.unreference()\n              );\n            n.register(this), (this.model = n);\n          }\n        }),\n        (n.handleChange = function () {\n          this.bubble();\n        }),\n        (n.rebind = function (t, e, n) {\n          return this.isStatic\n            ? void 0\n            : ((t = ht(this.template, t, e, this.up)),\n              t === this.model\n                ? !1\n                : (this.model && this.model.unregister(this),\n                  t && t.addShuffleRegister(this, "mark"),\n                  (this.model = t),\n                  n || this.handleChange(),\n                  !0));\n        }),\n        (n.rebound = function (t) {\n          if (this.model) {\n            if (this.model.rebound) this.model.rebound(t);\n            else {\n              var e = this.template.y\n                  ? this.template.y.containerFragment\n                  : this.containerFragment || this.up,\n                n = _s(e, this.template);\n              n !== this.model && (this.model.unregister(this), this.bind(n));\n            }\n            t && this.bubble();\n          }\n          this.fragment && this.fragment.rebound(t);\n        }),\n        (n.unbind = function () {\n          this.isStatic ||\n            (this.model && this.model.unregister(this), (this.model = void 0));\n        }),\n        e\n      );\n    })(Af),\n    $d = (Es.prototype = Object.create(Of.prototype));\n  Ua($d, Ud.prototype, { constructor: Es });\n  var qd = (function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.bubble = function () {\n          this.owner && this.owner.bubble(), t.prototype.bubble.call(this);\n        }),\n        (n.detach = function () {\n          return si(this.node);\n        }),\n        (n.firstNode = function () {\n          return this.node;\n        }),\n        (n.getString = function () {\n          return this.model ? ai(this.model.get()) : "";\n        }),\n        (n.render = function (t, e) {\n          if (!Cr()) {\n            var n = (this.value = this.getString());\n            (this.rendered = !0), ws(this, t, e, n);\n          }\n        }),\n        (n.toString = function (t) {\n          var e = this.getString();\n          return t ? bt(e) : e;\n        }),\n        (n.unrender = function (t) {\n          t && this.detach(), (this.rendered = !1);\n        }),\n        (n.update = function () {\n          if (this.dirty && ((this.dirty = !1), this.rendered)) {\n            var t = this.getString();\n            t !== this.value && (this.node.data = this.value = t);\n          }\n        }),\n        (n.valueOf = function () {\n          return this.model ? this.model.get() : void 0;\n        }),\n        e\n      );\n    })(Ud),\n    Hd = (function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.render = function (e, n) {\n          t.prototype.render.call(this, e, n),\n            (this.node.defaultValue = this.node.value);\n        }),\n        (n.compare = function (t, e) {\n          var n = this.getAttribute("value-comparator");\n          if (n) {\n            if (u(n)) return n(t, e);\n            if (t && e) return t[n] == e[n];\n          }\n          return t == e;\n        }),\n        e\n      );\n    })(_d),\n    Zd = { true: !0, false: !1, null: null, undefined: void 0 },\n    Wd = new RegExp("^(?:" + Za(Zd).join("|") + ")"),\n    Gd =\n      /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/,\n    Qd = /\\$\\{([^\\}]+)\\}/g,\n    Yd = /^\\$\\{([^\\}]+)\\}/,\n    Jd = /^\\s*$/,\n    Xd = Uo.extend({\n      init: function (t, e) {\n        (this.values = e.values), this.sp();\n      },\n      postProcess: function (t) {\n        return 1 === t.length && Jd.test(this.leftover)\n          ? { value: t[0].v }\n          : null;\n      },\n      converters: [\n        function (e) {\n          if (!e.values) return null;\n          var n = e.matchPattern(Yd);\n          return n && t(e.values, n) ? { v: e.values[n] } : void 0;\n        },\n        function (t) {\n          var e = t.matchPattern(Wd);\n          return e ? { v: Zd[e] } : void 0;\n        },\n        function (t) {\n          var e = t.matchPattern(Gd);\n          return e ? { v: +e } : void 0;\n        },\n        function (t) {\n          var e = Et(t),\n            n = t.values;\n          return e && n\n            ? {\n                v: e.v.replace(Qd, function (t, e) {\n                  return e in n ? n[e] : e;\n                }),\n              }\n            : e;\n        },\n        function (t) {\n          if (!t.matchString("{")) return null;\n          var e = {};\n          if ((t.sp(), t.matchString("}"))) return { v: e };\n          for (var n; (n = Ss(t)); ) {\n            if (((e[n.key] = n.value), t.sp(), t.matchString("}")))\n              return { v: e };\n            if (!t.matchString(",")) return null;\n          }\n          return null;\n        },\n        function (t) {\n          if (!t.matchString("[")) return null;\n          var e = [];\n          if ((t.sp(), t.matchString("]"))) return { v: e };\n          for (var n; (n = t.read()); ) {\n            if ((e.push(n.v), t.sp(), t.matchString("]"))) return { v: e };\n            if (!t.matchString(",")) return null;\n            t.sp();\n          }\n          return null;\n        },\n      ],\n    }),\n    tp = (function (t) {\n      function e(e) {\n        t.call(this, e),\n          (this.name = e.template.n),\n          (this.owner = e.owner || e.up.owner || e.element || zn(e.up)),\n          (this.element =\n            e.element || (this.owner.attributeByName ? this.owner : zn(e.up))),\n          (this.up = this.element.up),\n          (this.ractive = this.up.ractive),\n          (this.element.attributeByName[this.name] = this),\n          (this.value = e.template.f);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.bind = function () {\n          var t = this.template.f,\n            e = this.element.instance.viewmodel;\n          if (0 === t) e.joinKey(this.name).set(!0);\n          else if (h(t)) {\n            var n = As(t);\n            e.joinKey(this.name).set(n ? n.value : t);\n          } else Ga(t) && Cs(this, !0);\n        }),\n        (n.rebound = function (t) {\n          if (\n            (this.boundFragment && this.boundFragment.rebound(t), this.link)\n          ) {\n            this.model = _s(this.up, this.template.f[0]);\n            var e = this.element.instance.viewmodel.joinAll(S(this.name));\n            e.link(this.model, this.name, { mapping: !0 });\n          }\n        }),\n        (n.render = function () {}),\n        (n.unbind = function (t) {\n          this.model && this.model.unregister(this),\n            this.boundFragment && this.boundFragment.unbind(t),\n            this.element.bound &&\n              this.link.target === this.model &&\n              this.link.owner.unlink();\n        }),\n        (n.unrender = function () {}),\n        (n.update = function () {\n          this.dirty &&\n            ((this.dirty = !1),\n            this.boundFragment && this.boundFragment.update());\n        }),\n        e\n      );\n    })(Af),\n    ep = (function (t) {\n      function e(e) {\n        var n = e.template;\n        n.a || (n.a = {}),\n          !c(n.a.value) || "disabled" in n.a || (n.a.value = n.f || ""),\n          t.call(this, e),\n          (this.select = zn(this.parent || this.up, !1, "select"));\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.bind = function () {\n          if (!this.select) return void t.prototype.bind.call(this);\n          var e = this.attributeByName.selected;\n          if (e && void 0 !== this.select.getAttribute("value")) {\n            var n = this.attributes.indexOf(e);\n            this.attributes.splice(n, 1), delete this.attributeByName.selected;\n          }\n          t.prototype.bind.call(this), this.select.options.push(this);\n        }),\n        (n.bubble = function () {\n          var e = this.getAttribute("value");\n          this.node && this.node.value !== e && (this.node._ractive.value = e),\n            t.prototype.bubble.call(this);\n        }),\n        (n.getAttribute = function (t) {\n          var e = this.attributeByName[t];\n          return e\n            ? e.getValue()\n            : "value" === t && this.fragment\n            ? this.fragment.valueOf()\n            : void 0;\n        }),\n        (n.isSelected = function () {\n          var t = this,\n            e = this.getAttribute("value");\n          if (c(e) || !this.select) return !1;\n          var n = this.select.getAttribute("value");\n          if (this.select.compare(n, e)) return !0;\n          if (this.select.getAttribute("multiple") && Ga(n))\n            for (var i = n.length; i--; )\n              if (t.select.compare(n[i], e)) return !0;\n        }),\n        (n.render = function (e, n) {\n          t.prototype.render.call(this, e, n),\n            this.attributeByName.value ||\n              (this.node._ractive.value = this.getAttribute("value"));\n        }),\n        (n.unbind = function (e) {\n          t.prototype.unbind.call(this, e),\n            this.select && V(this.select.options, this);\n        }),\n        e\n      );\n    })(_d),\n    np = (Ps.prototype = $a(Es.prototype));\n  Ua(np, {\n    constructor: Ps,\n    bind: function () {\n      var t = this.template;\n      if (this.yielder) {\n        if (\n          ((this.container = this.up.ractive),\n          (this.component = this.container.component),\n          (this.containerFragment = this.up),\n          !this.component)\n        )\n          return (\n            (this.fragment = new Gp({ owner: this, template: [] })),\n            void this.fragment.bind()\n          );\n        (this.up = this.component.up),\n          t.r || t.x || t.rx || (this.refName = "content");\n      }\n      this.macro\n        ? (this.fn = this.macro)\n        : (this.refName || (this.refName = t.r),\n          this.refName && Rs(this, this.refName),\n          this.partial ||\n            this.fn ||\n            (Es.prototype.bind.call(this),\n            this.model && Rs(this, this.model.get()))),\n        this.partial ||\n          this.fn ||\n          b("Could not find template for partial \'" + this.name + "\'"),\n        Ms(this, this.partial || []),\n        this.fn && Ls(this),\n        this.fragment.bind();\n    },\n    bubble: function () {\n      this.dirty ||\n        ((this.dirty = !0),\n        this.yielder ? this.containerFragment.bubble() : this.up.bubble());\n    },\n    findNextNode: function () {\n      return (this.containerFragment || this.up).findNextNode(this);\n    },\n    handleChange: function () {\n      (this.dirtyTemplate = !0), (this.externalChange = !0), this.bubble();\n    },\n    rebound: function (t) {\n      var e = this;\n      this._attrs &&\n        Za(this._attrs).forEach(function (n) {\n          return e._attrs[n].rebound(t);\n        }),\n        Es.prototype.rebound.call(this, t);\n    },\n    refreshAttrs: function () {\n      var t = this;\n      Za(this._attrs).forEach(function (e) {\n        t.handle.attributes[e] =\n          !t._attrs[e].items.length || t._attrs[e].valueOf();\n      });\n    },\n    resetTemplate: function () {\n      var t = this;\n      if (this.fn && this.proxy) {\n        if (((this.last = 0), !this.externalChange))\n          return (this.partial = this.fnTemplate), !0;\n        u(this.proxy.teardown) && this.proxy.teardown(),\n          (this.fn = this.proxy = null);\n      }\n      if (\n        ((this.partial = null),\n        this.refName &&\n          (this.partial = Os(this.ractive, this.refName, this.up)),\n        !this.partial && this.model && Rs(this, this.model.get()),\n        !this.fn)\n      ) {\n        if (this.last && this.partial === this.last) return !1;\n        this.partial && ((this.last = this.partial), Is(this));\n      }\n      return (\n        this.unbindAttrs(),\n        this.fn\n          ? (Ls(this),\n            u(this.proxy.render) &&\n              Nl.scheduleTask(function () {\n                return t.proxy.render();\n              }))\n          : this.partial ||\n            b("Could not find template for partial \'" + this.name + "\'"),\n        !0\n      );\n    },\n    render: function (t, e) {\n      this.fn && this.fn._cssDef && !this.fn._cssDef.applied && Ai(),\n        this.fragment.render(t, e),\n        this.proxy && u(this.proxy.render) && this.proxy.render();\n    },\n    unbind: function (t) {\n      this.fragment.unbind(t),\n        this.unbindAttrs(t),\n        Es.prototype.unbind.call(this, t);\n    },\n    unbindAttrs: function (t) {\n      var e = this;\n      this._attrs &&\n        Za(this._attrs).forEach(function (n) {\n          e._attrs[n].unbind(t);\n        });\n    },\n    unrender: function (t) {\n      this.proxy && u(this.proxy.teardown) && this.proxy.teardown(),\n        this.fragment.unrender(t);\n    },\n    update: function () {\n      var t = this,\n        e = this.proxy;\n      (this.updating = 1),\n        this.dirtyAttrs &&\n          ((this.dirtyAttrs = !1),\n          Za(this._attrs).forEach(function (e) {\n            return t._attrs[e].update();\n          }),\n          this.refreshAttrs(),\n          u(e.update) && e.update(this.handle.attributes)),\n        this.dirtyTemplate &&\n          ((this.dirtyTemplate = !1),\n          this.resetTemplate() &&\n            this.fragment.resetTemplate(this.partial || [])),\n        this.dirty &&\n          ((this.dirty = !1),\n          e && u(e.invalidate) && e.invalidate(),\n          this.fragment.update()),\n        (this.externalChange = !1),\n        (this.updating = 0);\n    },\n  });\n  var ip = "extra-attributes",\n    rp = function (t, e, n) {\n      (this.value = this.key = t),\n        (this.context = e),\n        (this.isReadonly = this.isKey = !0),\n        (this.deps = []),\n        (this.links = []),\n        (this.children = []),\n        (this.instance = n);\n    },\n    sp = rp.prototype;\n  (sp.applyValue = function (t) {\n    t !== this.value &&\n      ((this.value = this.key = t),\n      this.deps.forEach(Q),\n      this.links.forEach(Q),\n      this.children.forEach(function (t) {\n        t.applyValue(t.context.getKeypath(t.instance));\n      }));\n  }),\n    (sp.destroyed = function () {\n      this.upstream && this.upstream.unregisterChild(this);\n    }),\n    (sp.get = function (t) {\n      return t && H(this), A(this.value);\n    }),\n    (sp.getKeypath = function () {\n      return A(this.value);\n    }),\n    (sp.has = function () {\n      return !1;\n    }),\n    (sp.rebind = function (t, e) {\n      for (var n = this, i = this.deps.length; i--; )\n        n.deps[i].rebind(t, e, !1);\n      for (i = this.links.length; i--; ) n.links[i].relinking(t, !1);\n    }),\n    (sp.register = function (t) {\n      this.deps.push(t);\n    }),\n    (sp.registerChild = function (t) {\n      C(this.children, t), (t.upstream = this);\n    }),\n    (sp.registerLink = function (t) {\n      C(this.links, t);\n    }),\n    (sp.unregister = function (t) {\n      V(this.deps, t);\n    }),\n    (sp.unregisterChild = function (t) {\n      V(this.children, t);\n    }),\n    (sp.unregisterLink = function (t) {\n      V(this.links, t);\n    }),\n    (rp.prototype.reference = f),\n    (rp.prototype.unreference = f);\n  var ap = /^"(\\\\"|[^"])+"$/,\n    op = function (t) {\n      (this.parent = t.owner.up),\n        (this.up = this),\n        (this.owner = t.owner),\n        (this.ractive = this.parent.ractive),\n        (this.delegate =\n          this.ractive.delegate !== !1 &&\n          (this.parent.delegate || Fs(this.parent))),\n        this.delegate && this.delegate.delegate === !1 && (this.delegate = !1),\n        this.delegate && (this.delegate.delegate = this.delegate),\n        (this.cssIds =\n          "cssIds" in t ? t.cssIds : this.parent ? this.parent.cssIds : null),\n        (this.context = null),\n        (this.rendered = !1),\n        (this.iterations = []),\n        (this.template = t.template),\n        (this.indexRef = t.indexRef),\n        (this.keyRef = t.keyRef),\n        (this.pendingNewIndices = null),\n        (this.previousIterations = null),\n        (this.isArray = !1);\n    },\n    up = op.prototype;\n  (up.bind = function (t) {\n    var e = this;\n    (this.context = t), (this.bound = !0);\n    var n = t.get(),\n      i = (this.aliases =\n        this.owner.template.z && this.owner.template.z.slice()),\n      r =\n        i &&\n        i.find(function (t) {\n          return "shuffle" === t.n;\n        });\n    r &&\n      r.x &&\n      r.x.x &&\n      ("true" === r.x.x.s\n        ? (this.shuffler = !0)\n        : ap.test(r.x.x.s) && (this.shuffler = S(r.x.x.s.slice(1, -1)))),\n      this.shuffler && (this.values = Us(this, this.shuffler)),\n      this.source && this.source.model.unbind(this.source);\n    var a =\n      t.isComputed &&\n      i &&\n      i.find(function (t) {\n        return "source" === t.n;\n      });\n    if (a && a.x && a.x.r) {\n      var o = _s(this, a.x);\n      (this.source = {\n        handleChange: function () {},\n        rebind: function (t) {\n          this.model.unregister(this), (this.model = t), t.register(this);\n        },\n      }),\n        (this.source.model = o),\n        o.register(this.source);\n    }\n    if ((this.isArray = Ga(n))) {\n      this.iterations = [];\n      for (var u = (this.length = n.length), h = 0; u > h; h += 1)\n        e.iterations[h] = e.createIteration(h, h);\n    } else if (s(n)) {\n      if (((this.isArray = !1), this.indexRef)) {\n        var l = this.indexRef.split(",");\n        (this.keyRef = l[0]), (this.indexRef = l[1]);\n      }\n      var c = Za(n);\n      (this.length = c.length),\n        (this.iterations = c.map(function (t, n) {\n          return e.createIteration(t, n);\n        }));\n    }\n    return this;\n  }),\n    (up.bubble = function (t) {\n      this.bubbled || (this.bubbled = []),\n        this.bubbled.push(t),\n        this.rebounding || this.owner.bubble();\n    }),\n    (up.createIteration = function (t, e) {\n      var n = new Gp({ owner: this, template: this.template });\n      return (\n        (n.isIteration = !0),\n        (n.delegate = this.delegate),\n        this.aliases && (n.aliases = {}),\n        zs(this, n, t, e),\n        n.bind(n.context)\n      );\n    }),\n    (up.destroyed = function () {\n      for (var t = this, e = this.iterations.length, n = 0; e > n; n++)\n        t.iterations[n].destroyed();\n      this.pathModel && this.pathModel.destroyed(),\n        this.rootModel && this.rootModel.destroyed();\n    }),\n    (up.detach = function () {\n      var t = ii();\n      return (\n        this.iterations.forEach(function (e) {\n          return t.appendChild(e.detach());\n        }),\n        t\n      );\n    }),\n    (up.find = function (t, e) {\n      return I(this.iterations, function (n) {\n        return n.find(t, e);\n      });\n    }),\n    (up.findAll = function (t, e) {\n      return this.iterations.forEach(function (n) {\n        return n.findAll(t, e);\n      });\n    }),\n    (up.findAllComponents = function (t, e) {\n      return this.iterations.forEach(function (n) {\n        return n.findAllComponents(t, e);\n      });\n    }),\n    (up.findComponent = function (t, e) {\n      return I(this.iterations, function (n) {\n        return n.findComponent(t, e);\n      });\n    }),\n    (up.findContext = function () {\n      return this.context;\n    }),\n    (up.findNextNode = function (t) {\n      var e = this;\n      if (t.index < this.iterations.length - 1)\n        for (var n = t.index + 1; n < this.iterations.length; n++) {\n          var i = e.iterations[n].firstNode(!0);\n          if (i) return i;\n        }\n      return this.owner.findNextNode();\n    }),\n    (up.firstNode = function (t) {\n      return this.iterations[0] ? this.iterations[0].firstNode(t) : null;\n    }),\n    (up.getLast = function () {\n      return this.lastModel || (this.lastModel = new rp(this.length - 1));\n    }),\n    (up.rebind = function (t) {\n      var e = this;\n      (this.context = t),\n        this.source ||\n          (t &&\n            this.iterations.forEach(function (t) {\n              zs(e, t, t.key, t.index);\n            }));\n    }),\n    (up.rebound = function (t) {\n      var e = this;\n      (this.context = this.owner.model),\n        this.iterations.forEach(function (n, i) {\n          (n.context = $s(e, n, i)), n.rebound(t);\n        });\n    }),\n    (up.render = function (t, e) {\n      var n = this.iterations;\n      if (n) for (var i = n.length, r = 0; i > r; r++) n[r].render(t, e);\n      this.rendered = !0;\n    }),\n    (up.shuffle = function (t, e) {\n      var n = this;\n      this.pendingNewIndices ||\n        (this.previousIterations = this.iterations.slice()),\n        this.pendingNewIndices || (this.pendingNewIndices = []),\n        this.pendingNewIndices.push(t);\n      var i = [];\n      t.forEach(function (t, r) {\n        if (-1 !== t) {\n          var s = n.iterations[r];\n          (i[t] = s),\n            t !== r && s && ((s.dirty = !0), e && (s.shouldRebind = 1));\n        }\n      }),\n        (this.iterations = i),\n        e || this.bubble();\n    }),\n    (up.shuffled = function () {\n      this.iterations.forEach(nt);\n    }),\n    (up.toString = function (t) {\n      return this.iterations ? this.iterations.map(t ? ut : ot).join("") : "";\n    }),\n    (up.unbind = function (t) {\n      (this.bound = !1),\n        this.source && this.source.model.unregister(this.source);\n      for (\n        var e = this.pendingNewIndices\n            ? this.previousIterations\n            : this.iterations,\n          n = e.length,\n          i = 0;\n        n > i;\n        i++\n      )\n        e[i].unbind(t);\n      return this;\n    }),\n    (up.unrender = function (t) {\n      for (var e = this, n = this.iterations.length, i = 0; n > i; i++)\n        e.iterations[i].unrender(t);\n      if (this.pendingNewIndices && this.previousIterations) {\n        n = this.previousIterations.length;\n        for (var r = 0; n > r; r++) e.previousIterations[r].unrender(t);\n      }\n      this.rendered = !1;\n    }),\n    (up.update = function () {\n      var t = this;\n      if (this.pendingNewIndices)\n        return (this.bubbled.length = 0), void this.updatePostShuffle();\n      if (!this.updating) {\n        if (((this.updating = !0), this.shuffler)) {\n          var e = Us(this, this.shuffler),\n            n = R(this.values, e);\n          n.same\n            ? this.iterations.forEach(at)\n            : (this.shuffle(n, !0), this.updatePostShuffle());\n        } else {\n          for (var i = this.iterations.length, r = 0; i > r; r++) {\n            var a = t.iterations[r];\n            a && a.idxModel && a.idxModel.applyValue(r);\n          }\n          var o,\n            u,\n            h,\n            l = this.context.get(),\n            c = this.isArray,\n            f = !0;\n          if ((this.isArray = Ga(l))) {\n            if (this.source) {\n              this.rebounding = 1;\n              var d = this.source.model.get();\n              this.iterations.forEach(function (e, n) {\n                n < l.length &&\n                  e.lastValue !== l[n] &&\n                  ~(h = d.indexOf(l[n])) &&\n                  (zs(t, e, n, n), e.rebound(!0));\n              }),\n                (this.rebounding = 0);\n            }\n            c &&\n              ((f = !1),\n              this.iterations.length > l.length &&\n                (o = this.iterations.splice(l.length)));\n          } else if (s(l) && !c)\n            for (f = !1, o = [], u = {}, h = this.iterations.length; h--; ) {\n              var p = t.iterations[h];\n              p.key in l\n                ? (u[p.key] = !0)\n                : (t.iterations.splice(h, 1), o.push(p));\n            }\n          var m = Ga(l) ? l.length : s(l) ? Za(l).length : 0;\n          if (\n            ((this.length = m),\n            this.updateLast(),\n            f && ((o = this.iterations), (this.iterations = [])),\n            o)\n          ) {\n            i = o.length;\n            for (var v = 0; i > v; v++) o[v].unbind().unrender(!0);\n          }\n          if (!f && this.isArray && this.bubbled && this.bubbled.length) {\n            var g = this.bubbled;\n            (this.bubbled = []), (i = g.length);\n            for (var y = 0; i > y; y++)\n              t.iterations[g[y]] && t.iterations[g[y]].update();\n          } else {\n            i = this.iterations.length;\n            for (var b = 0; i > b; b++) t.iterations[b].update();\n          }\n          var w, x;\n          if (m > this.iterations.length) {\n            if (\n              ((w = this.rendered ? ii() : null),\n              (h = this.iterations.length),\n              Ga(l))\n            )\n              for (; h < l.length; )\n                (x = t.createIteration(h, h)),\n                  t.iterations.push(x),\n                  t.rendered && x.render(w),\n                  (h += 1);\n            else if (s(l)) {\n              if (this.indexRef && !this.keyRef) {\n                var k = this.indexRef.split(",");\n                (this.keyRef = k[0]), (this.indexRef = k[1]);\n              }\n              Za(l).forEach(function (e) {\n                (u && e in u) ||\n                  ((x = t.createIteration(e, h)),\n                  t.iterations.push(x),\n                  t.rendered && x.render(w),\n                  (h += 1));\n              });\n            }\n            if (this.rendered) {\n              var _ = this.parent.findParentNode(),\n                E = this.parent.findNextNode(this.owner);\n              _.insertBefore(w, E);\n            }\n          }\n        }\n        this.updating = !1;\n      }\n    }),\n    (up.updateLast = function () {\n      this.lastModel && this.lastModel.applyValue(this.length - 1);\n    }),\n    (up.updatePostShuffle = function () {\n      var t = this,\n        e = this.pendingNewIndices[0],\n        n = this.rendered ? this.parent.findParentNode() : null,\n        i = n && this.owner.findNextNode(),\n        r = n ? ii() : null;\n      this.pendingNewIndices.slice(1).forEach(function (t) {\n        e.forEach(function (n, i) {\n          e[i] = t[n];\n        });\n      });\n      var s,\n        a,\n        u,\n        h,\n        l,\n        f,\n        d = (this.length = this.context.get().length),\n        p = this.previousIterations,\n        m = this.iterations,\n        v = this.context.get(),\n        g = {},\n        y = new Array(e.length);\n      for (\n        e.forEach(function (t, e) {\n          return (y[t] = e);\n        }),\n          this.updateLast(),\n          s = u = 0;\n        d > s;\n\n      )\n        c(y[s])\n          ? ((h = m[s] = t.createIteration(s, s)),\n            n &&\n              ((l = p[u]),\n              (l = (l && n && l.firstNode()) || i),\n              h.render(r),\n              n.insertBefore(r, l)),\n            s++)\n          : ((a = e[u]),\n            -1 === a\n              ? (p[u] && p[u].unbind().unrender(!0), (p[u++] = 0))\n              : a > s\n              ? ((g[a] = p[u]), (p[u++] = null))\n              : ((m[s] = h = m[s] || g[s] || t.createIteration(s, s)),\n                (g[s] || u !== s) &&\n                  ((f = t.source && h.lastValue !== v[s]), zs(t, h, s, s)),\n                !n ||\n                  (!g[s] && p[u]) ||\n                  ((l = p[u + 1]),\n                  (l = (l && n && l.firstNode()) || i),\n                  g[s]\n                    ? n.insertBefore(h.detach(), l)\n                    : (h.render(r), n.insertBefore(r, l))),\n                (p[u++] = 0),\n                s++),\n            h &&\n              o(h) &&\n              ((h.shouldRebind || f) && (h.rebound(f), (h.shouldRebind = 0)),\n              h.update(),\n              h.shuffled()));\n      for (var b = p.length, w = 0; b > w; w++)\n        p[w] && p[w].unbind().unrender(!0);\n      this.shuffler && (this.values = Us(this, this.shuffler)),\n        (this.pendingNewIndices = null),\n        (this.previousIterations = null);\n    }),\n    (op.prototype.getContext = rn),\n    (op.prototype.getKeypath = ua);\n  var hp = (function (t) {\n      function e(e) {\n        t.call(this, e),\n          (this.isAlias = e.template.t === uu),\n          (this.sectionType = e.template.n || (this.isAlias && Nu) || null),\n          (this.templateSectionType = this.sectionType),\n          (this.subordinate = 1 === e.template.l),\n          (this.fragment = null);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.bind = function () {\n          t.prototype.bind.call(this),\n            this.subordinate &&\n              ((this.sibling = this.up.items[this.up.items.indexOf(this) - 1]),\n              (this.sibling.nextSibling = this)),\n            this.model || this.isAlias\n              ? ((this.dirty = !0), this.update())\n              : !this.sectionType ||\n                this.sectionType !== Cu ||\n                (this.sibling && this.sibling.isTruthy()) ||\n                (this.fragment = new Gp({\n                  owner: this,\n                  template: this.template.f,\n                }).bind());\n        }),\n        (n.bubble = function () {\n          !this.dirty && this["yield"]\n            ? ((this.dirty = !0), this.containerFragment.bubble())\n            : t.prototype.bubble.call(this);\n        }),\n        (n.detach = function () {\n          var e = this.fragment || this.detached;\n          return e ? e.detach() : t.prototype.detach.call(this);\n        }),\n        (n.findNextNode = function () {\n          return (this.containerFragment || this.up).findNextNode(this);\n        }),\n        (n.isTruthy = function () {\n          if (this.subordinate && this.sibling.isTruthy()) return !0;\n          var t = this.model\n            ? this.model.isRoot\n              ? this.model.value\n              : this.model.get()\n            : void 0;\n          return !(!t || (this.templateSectionType !== ju && qs(t)));\n        }),\n        (n.rebind = function (e, n, i) {\n          t.prototype.rebind.call(this, e, n, i) &&\n            this.fragment &&\n            this.sectionType !== Au &&\n            this.sectionType !== Cu &&\n            this.fragment.rebind(e);\n        }),\n        (n.rebound = function (e) {\n          this.model &&\n            (this.model.rebound\n              ? this.model.rebound(e)\n              : (t.prototype.unbind.call(this),\n                t.prototype.bind.call(this),\n                (this.sectionType === Nu ||\n                  this.sectionType === ju ||\n                  this.sectionType === Ou) &&\n                  this.fragment &&\n                  this.fragment.rebind(this.model),\n                e && this.bubble())),\n            this.fragment && this.fragment.rebound(e);\n        }),\n        (n.render = function (t, e) {\n          (this.rendered = !0), this.fragment && this.fragment.render(t, e);\n        }),\n        (n.shuffle = function (t) {\n          this.fragment && this.sectionType === Ou && this.fragment.shuffle(t);\n        }),\n        (n.unbind = function (e) {\n          t.prototype.unbind.call(this, e),\n            this.fragment && this.fragment.unbind(e);\n        }),\n        (n.unrender = function (t) {\n          this.rendered && this.fragment && this.fragment.unrender(t),\n            (this.rendered = !1);\n        }),\n        (n.update = function () {\n          var t = this;\n          if (\n            this.dirty &&\n            (this.fragment &&\n              this.sectionType !== Au &&\n              this.sectionType !== Cu &&\n              (this.fragment.context = this.model),\n            this.model || this.sectionType === Cu || this.isAlias)\n          ) {\n            this.dirty = !1;\n            var e = this.model\n                ? this.model.isRoot\n                  ? this.model.value\n                  : this.model.get()\n                : void 0,\n              n = !this.subordinate || !this.sibling.isTruthy(),\n              i = this.sectionType;\n            this["yield"] && this["yield"] !== e\n              ? ((this.up = this.containerFragment),\n                (this.container = null),\n                (this["yield"] = null),\n                this.rendered && this.fragment.unbind().unrender(!0),\n                (this.fragment = null))\n              : this.rendered &&\n                !this["yield"] &&\n                e instanceof fc &&\n                (this.rendered &&\n                  this.fragment &&\n                  this.fragment.unbind().unrender(!0),\n                (this.fragment = null)),\n              (null === this.sectionType ||\n                null === this.templateSectionType) &&\n                (this.sectionType = Hs(e, this.template.i)),\n              i &&\n                i !== this.sectionType &&\n                this.fragment &&\n                (this.rendered && this.fragment.unbind().unrender(!0),\n                (this.fragment = null));\n            var r,\n              s =\n                this.sectionType === Ou ||\n                this.sectionType === Nu ||\n                (n &&\n                  (this.sectionType === Cu\n                    ? !this.isTruthy()\n                    : this.isTruthy())) ||\n                this.isAlias;\n            if (s)\n              if (\n                (this.fragment || (this.fragment = this.detached),\n                this.fragment)\n              )\n                this.detached &&\n                  (Zs(this, this.fragment),\n                  (this.detached = !1),\n                  (this.rendered = !0)),\n                  this.fragment.bound || this.fragment.bind(this.model),\n                  this.fragment.update();\n              else if (this.sectionType === Ou)\n                r = new op({\n                  owner: this,\n                  template: this.template.f,\n                  indexRef: this.template.i,\n                }).bind(this.model);\n              else {\n                var a =\n                  this.sectionType !== Au && this.sectionType !== Cu\n                    ? this.model\n                    : null;\n                e instanceof fc &&\n                  ((this["yield"] = e),\n                  (this.containerFragment = this.up),\n                  (this.up = e.fragment),\n                  (this.container = e.ractive),\n                  (a = void 0)),\n                  (r = new Gp({ owner: this, template: this.template.f }).bind(\n                    a\n                  ));\n              }\n            else\n              this.fragment && this.rendered\n                ? $l !== !0\n                  ? this.fragment.unbind().unrender(!0)\n                  : (this.unrender(!1),\n                    (this.detached = this.fragment),\n                    Nl.promise().then(function () {\n                      t.detached && t.detach();\n                    }))\n                : this.fragment && this.fragment.unbind(),\n                (this.fragment = null);\n            r && (this.rendered && Zs(this, r), (this.fragment = r)),\n              this.nextSibling &&\n                ((this.nextSibling.dirty = !0), this.nextSibling.update());\n          }\n        }),\n        e\n      );\n    })(Es),\n    lp = (function (t) {\n      function e(e) {\n        t.call(this, e), (this.options = []);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.foundNode = function (t) {\n          if (this.binding) {\n            var e = rs(t);\n            e.length > 0 && (this.selectedOptions = e);\n          }\n        }),\n        (n.render = function (e, n) {\n          t.prototype.render.call(this, e, n), this.sync();\n          for (var i = this.node, r = i.options.length; r--; )\n            i.options[r].defaultSelected = i.options[r].selected;\n          this.rendered = !0;\n        }),\n        (n.sync = function () {\n          var t = this,\n            e = this.node;\n          if (e) {\n            var n = M(e.options);\n            if (this.selectedOptions)\n              return (\n                n.forEach(function (e) {\n                  t.selectedOptions.indexOf(e) >= 0\n                    ? (e.selected = !0)\n                    : (e.selected = !1);\n                }),\n                this.binding.setFromNode(e),\n                void delete this.selectedOptions\n              );\n            var i = this.getAttribute("value"),\n              r = this.getAttribute("multiple"),\n              s = r && Ga(i);\n            if (void 0 !== i) {\n              var a;\n              n.forEach(function (e) {\n                var n = e._ractive ? e._ractive.value : e.value,\n                  o = r ? s && t.valueContains(i, n) : t.compare(i, n);\n                o && (a = !0), (e.selected = o);\n              }),\n                a || r || (this.binding && this.binding.forceUpdate());\n            } else\n              this.binding &&\n                this.binding.forceUpdate &&\n                this.binding.forceUpdate();\n          }\n        }),\n        (n.valueContains = function (t, e) {\n          for (var n = this, i = t.length; i--; )\n            if (n.compare(e, t[i])) return !0;\n        }),\n        (n.compare = function (t, e) {\n          var n = this.getAttribute("value-comparator");\n          if (n) {\n            if (u(n)) return n(e, t);\n            if (e && t) return e[n] == t[n];\n          }\n          return e == t;\n        }),\n        (n.update = function () {\n          var e = this.dirty;\n          t.prototype.update.call(this), e && this.sync();\n        }),\n        e\n      );\n    })(_d),\n    cp = (function (t) {\n      function e(e) {\n        var n = e.template;\n        (e.deferContent = !0),\n          t.call(this, e),\n          this.attributeByName.value ||\n            (n.f && os({ template: n })\n              ? (this.attributes || (this.attributes = [])).push(\n                  sa({\n                    owner: this,\n                    template: { t: nu, f: n.f, n: "value" },\n                    up: this.up,\n                  })\n                )\n              : (this.fragment = new Gp({\n                  owner: this,\n                  cssIds: null,\n                  template: n.f,\n                })));\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.bubble = function () {\n          var t = this;\n          this.dirty ||\n            ((this.dirty = !0),\n            this.rendered &&\n              !this.binding &&\n              this.fragment &&\n              Nl.scheduleTask(function () {\n                (t.dirty = !1), (t.node.value = t.fragment.toString());\n              }),\n            this.up.bubble());\n        }),\n        e\n      );\n    })(Hd),\n    fp = (function (t) {\n      function e(e) {\n        t.call(this, e), (this.type = qo);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.detach = function () {\n          return si(this.node);\n        }),\n        (n.firstNode = function () {\n          return this.node;\n        }),\n        (n.render = function (t, e) {\n          Cr() || ((this.rendered = !0), ws(this, t, e, this.template));\n        }),\n        (n.toString = function (t) {\n          return t ? bt(this.template) : this.template;\n        }),\n        (n.unrender = function (t) {\n          this.rendered && t && this.detach(), (this.rendered = !1);\n        }),\n        (n.valueOf = function () {\n          return this.template;\n        }),\n        e\n      );\n    })(Af),\n    dp = fp.prototype;\n  dp.bind = dp.unbind = dp.update = f;\n  var pp,\n    mp = "hidden";\n  if (Ja) {\n    var vp;\n    if (mp in Ja) vp = "";\n    else\n      for (var gp = io.length; gp--; ) {\n        var yp = io[gp];\n        if (((mp = yp + "Hidden"), mp in Ja)) {\n          vp = yp;\n          break;\n        }\n      }\n    void 0 !== vp\n      ? (Ja.addEventListener(vp + "visibilitychange", Ws), Ws())\n      : ("onfocusout" in Ja\n          ? (Ja.addEventListener("focusout", Gs),\n            Ja.addEventListener("focusin", Qs))\n          : (Ya.addEventListener("pagehide", Gs),\n            Ya.addEventListener("blur", Gs),\n            Ya.addEventListener("pageshow", Qs),\n            Ya.addEventListener("focus", Qs)),\n        (pp = !0));\n  }\n  var bp;\n  if (Xa) {\n    var wp = {},\n      xp = mc("div").style;\n    bp = function (t) {\n      if (!wp[t]) {\n        var e = _e(t);\n        if (void 0 !== xp[t]) wp[t] = e;\n        else\n          for (var n = io.length; n--; ) {\n            var i = "-" + io[n] + "-" + e;\n            if (void 0 !== xp[i]) {\n              wp[t] = i;\n              break;\n            }\n          }\n      }\n      return wp[t];\n    };\n  } else bp = null;\n  var kp,\n    _p = bp,\n    Ep = new RegExp("^(?:" + io.join("|") + ")([A-Z])");\n  if (Xa) {\n    var Sp,\n      Ap,\n      Cp,\n      Op,\n      Np,\n      jp,\n      Tp = mc("div").style,\n      Vp = function (t) {\n        return t;\n      },\n      Pp = {},\n      Mp = {};\n    void 0 !== Tp.transition\n      ? ((Sp = "transition"), (Ap = "transitionend"), (Cp = !0))\n      : void 0 !== Tp.webkitTransition\n      ? ((Sp = "webkitTransition"), (Ap = "webkitTransitionEnd"), (Cp = !0))\n      : (Cp = !1),\n      Sp &&\n        ((Op = Sp + "Duration"),\n        (Np = Sp + "Property"),\n        (jp = Sp + "TimingFunction")),\n      (kp = function (t, e, n, i, r) {\n        setTimeout(function () {\n          function s() {\n            clearTimeout(d);\n          }\n          function a() {\n            c &&\n              f &&\n              (t.unregisterCompleteHandler(s),\n              t.ractive.fire(t.name + ":end", t.node, t.isIntro),\n              r());\n          }\n          function o(e) {\n            if (e.target === t.node) {\n              var n = i.indexOf(e.propertyName);\n              -1 !== n && i.splice(n, 1), i.length || (clearTimeout(d), l());\n            }\n          }\n          function l() {\n            (m[Np] = v.property),\n              (m[jp] = v.duration),\n              (m[Op] = v.timing),\n              t.node.removeEventListener(Ap, o, !1),\n              (f = !0),\n              a();\n          }\n          var c,\n            f,\n            d,\n            p = (t.node.namespaceURI || "") + t.node.tagName,\n            m = t.node.style,\n            v = { property: m[Np], timing: m[jp], duration: m[Op] };\n          t.node.addEventListener(Ap, o, !1),\n            (d = setTimeout(function () {\n              (i = []), l();\n            }, n.duration + (n.delay || 0) + 50)),\n            t.registerCompleteHandler(s),\n            (m[Np] = i.join(","));\n          var g = Ys(n.easing || "linear");\n          m[jp] = g;\n          var w = m[jp] === g;\n          (m[Op] = n.duration / 1e3 + "s"),\n            setTimeout(function () {\n              for (var r, s, l, d, v, g = i.length, x = null, _ = []; g--; ) {\n                if (((l = i[g]), (r = p + l), w && Cp && !Mp[r])) {\n                  var E = m[l];\n                  (m[l] = e[l]),\n                    r in Pp ||\n                      ((x = t.getStyle(l)),\n                      (Pp[r] = t.getStyle(l) != e[l]),\n                      (Mp[r] = !Pp[r]),\n                      Mp[r] && (m[l] = E));\n                }\n                (w && Cp && !Mp[r]) ||\n                  (null === x && (x = t.getStyle(l)),\n                  (s = i.indexOf(l)),\n                  -1 === s\n                    ? y(\n                        "Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!",\n                        { node: t.node }\n                      )\n                    : i.splice(s, 1),\n                  (d = /[^\\d]*$/.exec(x)[0]),\n                  (v = k(parseFloat(x), parseFloat(e[l]))),\n                  v\n                    ? _.push({ name: l, interpolator: v, suffix: d })\n                    : (m[l] = e[l]),\n                  (x = null));\n              }\n              if (_.length) {\n                var S;\n                h(n.easing)\n                  ? ((S = t.ractive.easing[n.easing]),\n                    S || (b(_o(n.easing, "easing")), (S = Vp)))\n                  : (S = u(n.easing) ? n.easing : Vp),\n                  new Vl({\n                    duration: n.duration,\n                    easing: S,\n                    step: function (t) {\n                      for (var e = _.length; e--; ) {\n                        var n = _[e];\n                        m[n.name] = n.interpolator(t) + n.suffix;\n                      }\n                    },\n                    complete: function () {\n                      (c = !0), a();\n                    },\n                  });\n              } else c = !0;\n              i.length\n                ? (m[Np] = i.join(","))\n                : ((m[Np] = "none"),\n                  t.node.removeEventListener(Ap, o, !1),\n                  (f = !0),\n                  a());\n            }, 0);\n        }, n.delay || 0);\n      });\n  } else kp = null;\n  var Ip = kp,\n    Rp = Ya && Ya.getComputedStyle,\n    Bp = Promise.resolve(),\n    Kp = { t0: "intro-outro", t1: "intro", t2: "outro" },\n    Lp = function (t) {\n      (this.owner = t.owner || t.up.owner || zn(t.up)),\n        (this.element = this.owner.attributeByName ? this.owner : zn(t.up)),\n        (this.ractive = this.owner.ractive),\n        (this.template = t.template),\n        (this.up = t.up),\n        (this.options = t),\n        (this.onComplete = []);\n    },\n    Dp = Lp.prototype;\n  (Dp.animateStyle = function (t, e, n) {\n    var i = this;\n    if (4 === arguments.length)\n      throw new Error(\n        "t.animateStyle() returns a promise - use .then() instead of passing a callback"\n      );\n    if (!pp) return this.setStyle(t, e), Bp;\n    var r;\n    return (\n      h(t) ? ((r = {}), (r[t] = e)) : ((r = t), (n = e)),\n      new Promise(function (t) {\n        if (!n.duration) return i.setStyle(r), void t();\n        for (var e = Za(r), s = [], a = Rp(i.node), o = e.length; o--; ) {\n          var u = e[o],\n            h = _p(u),\n            l = a[_p(u)],\n            c = i.node.style[h];\n          h in i.originals || (i.originals[h] = i.node.style[h]),\n            (i.node.style[h] = r[u]),\n            (i.targets[h] = i.node.style[h]),\n            (i.node.style[h] = c),\n            l != r[u] && (s.push(h), (r[h] = r[u]), (i.node.style[h] = l));\n        }\n        return s.length ? void Ip(i, r, n, s, t) : void t();\n      })\n    );\n  }),\n    (Dp.bind = function () {\n      var t = this.options,\n        e = t.template && t.template.v;\n      e &&\n        (("t0" === e || "t1" === e) && (this.element.intro = this),\n        ("t0" === e || "t2" === e) && (this.element.outro = this),\n        (this.eventName = Kp[e]));\n      var n = this.owner.ractive;\n      (this.name = t.name || t.template.n),\n        t.params && (this.params = t.params),\n        u(this.name)\n          ? ((this._fn = this.name), (this.name = this._fn.name))\n          : (this._fn = w("transitions", n, this.name)),\n        this._fn || b(_o(this.name, "transition"), { ractive: n }),\n        Qr(this, t.template);\n    }),\n    (Dp.getParams = function () {\n      if (this.params) return this.params;\n      if (this.fn) {\n        var t = Yr(this, this.template, this.up).map(function (t) {\n          return t ? t.get() : void 0;\n        });\n        return this.fn.apply(this.ractive, t);\n      }\n    }),\n    (Dp.getStyle = function (t) {\n      var e = Rp(this.node);\n      if (h(t)) return e[_p(t)];\n      if (!Ga(t))\n        throw new Error(\n          "Transition$getStyle must be passed a string, or an array of strings representing CSS properties"\n        );\n      for (var n = {}, i = t.length; i--; ) {\n        var r = t[i],\n          s = e[_p(r)];\n        "0px" === s && (s = 0), (n[r] = s);\n      }\n      return n;\n    }),\n    (Dp.processParams = function (t, e) {\n      return (\n        l(t)\n          ? (t = { duration: t })\n          : h(t)\n          ? (t =\n              "slow" === t\n                ? { duration: 600 }\n                : "fast" === t\n                ? { duration: 200 }\n                : { duration: 400 })\n          : t || (t = {}),\n        Ua({}, e, t)\n      );\n    }),\n    (Dp.registerCompleteHandler = function (t) {\n      C(this.onComplete, t);\n    }),\n    (Dp.setStyle = function (e, n) {\n      var i = this;\n      if (h(e)) {\n        var r = _p(e);\n        t(this.originals, r) || (this.originals[r] = this.node.style[r]),\n          (this.node.style[r] = n),\n          (this.targets[r] = this.node.style[r]);\n      } else {\n        var s;\n        for (s in e) t(e, s) && i.setStyle(s, e[s]);\n      }\n      return this;\n    }),\n    (Dp.shouldFire = function (t) {\n      if (!this.ractive.transitionsEnabled) return !1;\n      if (\n        "intro" === t &&\n        this.ractive.rendering &&\n        Js("noIntro", this.ractive, !0)\n      )\n        return !1;\n      if (\n        "outro" === t &&\n        this.ractive.unrendering &&\n        Js("noOutro", this.ractive, !1)\n      )\n        return !1;\n      var e = this.getParams();\n      if (!this.element.parent) return !0;\n      if (e && e[0] && s(e[0]) && "nested" in e[0]) {\n        if (e[0].nested !== !1) return !0;\n      } else if (Js("nestedTransitions", this.ractive) !== !1) return !0;\n      for (var n = this.element.parent; n; ) {\n        if (n[t] && n[t].starting) return !1;\n        n = n.parent;\n      }\n      return !0;\n    }),\n    (Dp.start = function () {\n      var t,\n        e = this,\n        n = (this.node = this.element.node),\n        i = (this.originals = {}),\n        r = (this.targets = {}),\n        s = this.getParams();\n      if (\n        ((this.complete = function (s) {\n          if (((e.starting = !1), !t)) {\n            if (\n              (e.onComplete.forEach(function (t) {\n                return t();\n              }),\n              !s && e.isIntro)\n            )\n              for (var a in r) n.style[a] === r[a] && (n.style[a] = i[a]);\n            e._manager.remove(e), (t = !0);\n          }\n        }),\n        !this._fn)\n      )\n        return void this.complete();\n      var a = this._fn.apply(this.ractive, [this].concat(s));\n      a && a.then(this.complete);\n    }),\n    (Dp.toString = function () {\n      return "";\n    }),\n    (Dp.unbind = function () {\n      if (!this.element.attributes || !this.element.attributes.unbinding) {\n        var t =\n          this.options && this.options.template && this.options.template.v;\n        ("t0" === t || "t1" === t) && (this.element.intro = null),\n          ("t0" === t || "t2" === t) && (this.element.outro = null);\n      }\n    }),\n    (Dp.unregisterCompleteHandler = function (t) {\n      V(this.onComplete, t);\n    });\n  var Fp = Lp.prototype;\n  Fp.destroyed =\n    Fp.firstNode =\n    Fp.rebound =\n    Fp.render =\n    Fp.unrender =\n    Fp.update =\n      f;\n  var zp,\n    Up,\n    $p = {};\n  try {\n    mc("table").innerHTML = "foo";\n  } catch (qp) {\n    (zp = !0),\n      (Up = {\n        TABLE: [\'<table class="x">\', "</table>"],\n        THEAD: [\'<table><thead class="x">\', "</thead></table>"],\n        TBODY: [\'<table><tbody class="x">\', "</tbody></table>"],\n        TR: [\'<table><tr class="x">\', "</tr></table>"],\n        SELECT: [\'<select class="x">\', "</select>"],\n      });\n  }\n  var Hp = (function (t) {\n      function e(e) {\n        t.call(this, e);\n      }\n      t && (e.__proto__ = t);\n      var n = (e.prototype = Object.create(t && t.prototype));\n      return (\n        (n.constructor = e),\n        (n.detach = function () {\n          var t = ii();\n          return (\n            this.nodes &&\n              this.nodes.forEach(function (e) {\n                return t.appendChild(e);\n              }),\n            t\n          );\n        }),\n        (n.find = function (t) {\n          var e,\n            n = this,\n            i = this.nodes.length;\n          for (e = 0; i > e; e += 1) {\n            var r = n.nodes[e];\n            if (1 === r.nodeType) {\n              if (vc(r, t)) return r;\n              var s = r.querySelector(t);\n              if (s) return s;\n            }\n          }\n          return null;\n        }),\n        (n.findAll = function (t, e) {\n          var n,\n            i = this,\n            r = e.result,\n            s = this.nodes.length;\n          for (n = 0; s > n; n += 1) {\n            var a = i.nodes[n];\n            if (1 === a.nodeType) {\n              vc(a, t) && r.push(a);\n              var o = a.querySelectorAll(t);\n              o && r.push.apply(r, o);\n            }\n          }\n        }),\n        (n.findComponent = function () {\n          return null;\n        }),\n        (n.firstNode = function () {\n          return this.rendered && this.nodes[0];\n        }),\n        (n.render = function (t, e, n) {\n          var i = this;\n          if (!this.nodes) {\n            var r = this.model ? this.model.get() : "";\n            this.nodes = Xs(r, t);\n          }\n          var s = this.nodes;\n          if (e) {\n            for (var a, o = -1; e.length && (a = this.nodes[o + 1]); )\n              for (var u = void 0; (u = e.shift()); ) {\n                var h = u.nodeType;\n                if (\n                  h === a.nodeType &&\n                  ((1 === h && u.outerHTML === a.outerHTML) ||\n                    ((3 === h || 8 === h) && u.nodeValue === a.nodeValue))\n                ) {\n                  i.nodes.splice(++o, 1, u);\n                  break;\n                }\n                t.removeChild(u);\n              }\n            o >= 0 && (s = this.nodes.slice(o)), e.length && (n = e[0]);\n          }\n          if (s.length) {\n            var l = ii();\n            s.forEach(function (t) {\n              return l.appendChild(t);\n            }),\n              n ? t.insertBefore(l, n) : t.appendChild(l);\n          }\n          this.rendered = !0;\n        }),\n        (n.toString = function () {\n          var t = this.model && this.model.get();\n          return (t = null != t ? "" + t : ""), Tr() ? yt(t) : t;\n        }),\n        (n.unrender = function () {\n          this.nodes &&\n            this.nodes.forEach(function (t) {\n              Nl.detachWhenReady({\n                node: t,\n                detach: function () {\n                  si(t);\n                },\n              });\n            }),\n            (this.rendered = !1),\n            (this.nodes = null);\n        }),\n        (n.update = function () {\n          this.rendered && this.dirty\n            ? ((this.dirty = !1),\n              this.unrender(),\n              this.render(\n                this.up.findParentNode(),\n                null,\n                this.up.findNextNode(this)\n              ))\n            : (this.dirty = !1);\n        }),\n        e\n      );\n    })(Ud),\n    Zp = {};\n  (Zp[uu] = hp),\n    (Zp[eu] = Hf),\n    (Zp[hu] = ra),\n    (Zp[ou] = rd),\n    (Zp[Ho] = qd),\n    (Zp[Jo] = Ps),\n    (Zp[Wo] = hp),\n    (Zp[Zo] = Hp),\n    (Zp[su] = Ps),\n    (Zp[nu] = Bf),\n    (Zp[Ku] = Kf),\n    (Zp[Ru] = nd),\n    (Zp[Iu] = Bd),\n    (Zp[Bu] = Lp),\n    (Zp[Xo] = Pr);\n  var Wp = {\n      doctype: rd,\n      form: Od,\n      input: Hd,\n      option: ep,\n      select: lp,\n      textarea: cp,\n    },\n    Gp = function (t) {\n      (this.owner = t.owner),\n        (this.isRoot = !t.owner.up),\n        (this.parent = this.isRoot ? null : this.owner.up),\n        (this.ractive =\n          t.ractive || (this.isRoot ? t.owner : this.parent.ractive)),\n        (this.componentParent =\n          this.isRoot && this.ractive.component\n            ? this.ractive.component.up\n            : this.owner.containerFragment || null),\n        !this.isRoot || this.ractive.delegate\n          ? (this.delegate = this.owner.containerFragment\n              ? this.owner.containerFragment &&\n                this.owner.containerFragment.delegate\n              : (this.componentParent && this.componentParent.delegate) ||\n                (this.parent && this.parent.delegate))\n          : (this.delegate = !1),\n        (this.context = null),\n        (this.rendered = !1),\n        "cssIds" in t\n          ? (this.cssIds = t.cssIds && t.cssIds.length && t.cssIds)\n          : (this.cssIds = this.parent ? this.parent.cssIds : null),\n        (this.dirty = !1),\n        (this.dirtyValue = !0),\n        (this.template = t.template || []),\n        this.createItems();\n    },\n    Qp = Gp.prototype;\n  (Qp.bind = function (t) {\n    var e = this;\n    (this.context = t),\n      this.owner.template.z &&\n        (this.aliases = oa(\n          this.owner.template.z,\n          this.owner.containerFragment || this.parent\n        ));\n    for (var n = this.items.length, i = 0; n > i; i++) e.items[i].bind();\n    return (this.bound = !0), this.dirty && this.update(), this;\n  }),\n    (Qp.bubble = function () {\n      (this.dirtyValue = !0),\n        this.dirty ||\n          ((this.dirty = !0),\n          this.isRoot\n            ? this.ractive.component\n              ? this.ractive.component.bubble()\n              : this.bound && Nl.addFragment(this)\n            : this.owner.bubble(this.index));\n    }),\n    (Qp.createItems = function () {\n      var t = this,\n        e = this.template.length;\n      this.items = [];\n      for (var n = 0; e > n; n++)\n        t.items[n] = sa({ up: t, template: t.template[n], index: n });\n    }),\n    (Qp.destroyed = function () {\n      for (var t = this, e = this.items.length, n = 0; e > n; n++)\n        t.items[n].destroyed();\n      this.pathModel && this.pathModel.destroyed(),\n        this.rootModel && this.rootModel.destroyed();\n    }),\n    (Qp.detach = function () {\n      for (var t = ii(), e = this.items, n = e.length, i = 0; n > i; i++)\n        t.appendChild(e[i].detach());\n      return t;\n    }),\n    (Qp.find = function (t, e) {\n      return I(this.items, function (n) {\n        return n.find(t, e);\n      });\n    }),\n    (Qp.findAll = function (t, e) {\n      this.items &&\n        this.items.forEach(function (n) {\n          return n.findAll && n.findAll(t, e);\n        });\n    }),\n    (Qp.findComponent = function (t, e) {\n      return I(this.items, function (n) {\n        return n.findComponent(t, e);\n      });\n    }),\n    (Qp.findAllComponents = function (t, e) {\n      this.items &&\n        this.items.forEach(function (n) {\n          return n.findAllComponents && n.findAllComponents(t, e);\n        });\n    }),\n    (Qp.findContext = function () {\n      var t = sn(this);\n      return t && t.context ? t.context : this.ractive.viewmodel;\n    }),\n    (Qp.findNextNode = function (t) {\n      var e = this;\n      if (t)\n        for (var n, i = t.index + 1; i < this.items.length; i++)\n          if (((n = e.items[i]), n && n.firstNode)) {\n            var r = n.firstNode(!0);\n            if (r) return r;\n          }\n      return this.isRoot\n        ? this.ractive.component\n          ? this.ractive.component.up.findNextNode(this.ractive.component)\n          : null\n        : this.parent\n        ? this.owner.findNextNode(this)\n        : void 0;\n    }),\n    (Qp.findParentNode = function () {\n      var t = this;\n      do {\n        if (t.owner.type === Yo) return t.owner.node;\n        if (t.isRoot && !t.ractive.component) return t.ractive.el;\n        t =\n          t.owner.type === su\n            ? t.owner.containerFragment\n            : t.componentParent || t.parent;\n      } while (t);\n      throw new Error("Could not find parent node");\n    }),\n    (Qp.firstNode = function (t) {\n      var e = I(this.items, function (t) {\n        return t.firstNode(!0);\n      });\n      return e ? e : t ? null : this.parent.findNextNode(this.owner);\n    }),\n    (Qp.getKey = function () {\n      return this.keyModel || (this.keyModel = new rp(this.key));\n    }),\n    (Qp.getIndex = function () {\n      return this.idxModel || (this.idxModel = new rp(this.index));\n    }),\n    (Qp.rebind = function (t) {\n      (this.context = t),\n        this.rootModel && (this.rootModel.context = this.context),\n        this.pathModel && (this.pathModel.context = this.context);\n    }),\n    (Qp.rebound = function (t) {\n      if (this.owner.template.z) {\n        var e = this.aliases;\n        for (var n in e)\n          e[n].rebound ? e[n].rebound(t) : (e[n].unreference(), (e[n] = 0));\n        oa(\n          this.owner.template.z,\n          this.owner.containerFragment || this.parent,\n          e\n        );\n      }\n      this.items.forEach(function (e) {\n        return e.rebound(t);\n      }),\n        t &&\n          (this.rootModel &&\n            this.rootModel.applyValue(\n              this.context.getKeypath(this.ractive.root)\n            ),\n          this.pathModel &&\n            this.pathModel.applyValue(this.context.getKeypath()));\n    }),\n    (Qp.render = function (t, e) {\n      if (this.rendered) throw new Error("Fragment is already rendered!");\n      this.rendered = !0;\n      for (var n = this.items, i = n.length, r = 0; i > r; r++)\n        n[r].render(t, e);\n    }),\n    (Qp.resetTemplate = function (t) {\n      var e = this.bound,\n        n = this.rendered;\n      if (\n        (e && (n && this.unrender(!0), this.unbind()),\n        (this.template = t),\n        this.createItems(),\n        e && (this.bind(this.context), n))\n      ) {\n        var i = this.findParentNode(),\n          r = this.findNextNode();\n        if (r) {\n          var s = ii();\n          this.render(s), i.insertBefore(s, r);\n        } else this.render(i);\n      }\n    }),\n    (Qp.shuffled = function () {\n      this.items.forEach(nt),\n        this.rootModel &&\n          this.rootModel.applyValue(this.context.getKeypath(this.ractive.root)),\n        this.pathModel && this.pathModel.applyValue(this.context.getKeypath());\n    }),\n    (Qp.toString = function (t) {\n      return this.items.map(t ? ut : ot).join("");\n    }),\n    (Qp.unbind = function (t) {\n      var e = this;\n      if (this.owner.template.z && !this.owner.yielder) {\n        for (var n in e.aliases) e.aliases[n].unreference();\n        this.aliases = {};\n      }\n      this.context = null;\n      for (var i = this.items.length, r = 0; i > r; r++) e.items[r].unbind(t);\n      return (this.bound = !1), this;\n    }),\n    (Qp.unrender = function (t) {\n      for (var e = this, n = this.items.length, i = 0; n > i; i++)\n        e.items[i].unrender(t);\n      this.rendered = !1;\n    }),\n    (Qp.update = function () {\n      var t = this;\n      if (this.dirty)\n        if (this.updating) this.isRoot && Nl.addFragmentToRoot(this);\n        else {\n          (this.dirty = !1), (this.updating = !0);\n          for (var e = this.items.length, n = 0; e > n; n++)\n            t.items[n].update();\n          this.updating = !1;\n        }\n    }),\n    (Qp.valueOf = function () {\n      if (1 === this.items.length) return this.items[0].valueOf();\n      if (this.dirtyValue) {\n        var t = {},\n          e = aa(this.items, t, this.ractive._guid),\n          n = As(e, t);\n        (this.value = n ? n.value : this.toString()), (this.dirtyValue = !1);\n      }\n      return this.value;\n    }),\n    (Gp.prototype.getContext = rn),\n    (Gp.prototype.getKeypath = ua);\n  var Yp = ["template", "partials", "components", "decorators", "events"],\n    Jp = qn("reverse").path,\n    Xp = qn("shift").path,\n    tm = qn("sort").path,\n    em = qn("splice").path,\n    nm = qn("unshift").path,\n    im = {\n      add: fn,\n      animate: vn,\n      attachChild: Nn,\n      compute: Pn,\n      detach: Mn,\n      detachChild: In,\n      find: Rn,\n      findAll: Bn,\n      findAllComponents: Kn,\n      findComponent: Ln,\n      findContainer: Dn,\n      findParent: Fn,\n      fire: Yn,\n      get: Jn,\n      getLocalContext: Xn,\n      getContext: ei,\n      insert: ui,\n      link: li,\n      observe: gi,\n      observeOnce: bi,\n      off: wi,\n      on: xi,\n      once: ki,\n      pop: Uc,\n      push: $c,\n      readLink: _i,\n      render: fa,\n      reset: da,\n      resetPartial: ma,\n      resetTemplate: va,\n      reverse: Jp,\n      set: ga,\n      shift: Xp,\n      sort: tm,\n      splice: em,\n      subtract: ya,\n      teardown: Mr,\n      toggle: ba,\n      toCSS: wa,\n      toCss: wa,\n      toHTML: xa,\n      toHtml: xa,\n      toText: ka,\n      transition: _a,\n      unlink: Ea,\n      unrender: Sa,\n      unshift: nm,\n      update: Zn,\n      updateModel: Aa,\n      use: Ca,\n    },\n    rm = [],\n    sm = /super\\s*\\(|\\.call\\s*\\(\\s*this/;\n  if (\n    (Ha(Fa, {\n      sharedGet: { value: Ma },\n      sharedSet: { value: Pa },\n      styleGet: { configurable: !0, value: Na.bind(Fa) },\n      styleSet: { configurable: !0, value: Ki.bind(Fa) },\n      addCSS: { configurable: !1, value: ja.bind(Fa) },\n      hasCSS: { configurable: !1, value: Va.bind(Fa) },\n    }),\n    Ya && !Ya.Ractive)\n  ) {\n    var am = "",\n      om =\n        document.currentScript ||\n        document.querySelector("script[data-ractive-options]");\n    om && (am = om.getAttribute("data-ractive-options") || ""),\n      ~am.indexOf("ForceGlobal") && (Ya.Ractive = Fa);\n  } else Ya && v("Ractive already appears to be loaded while loading 1.4.0-edge.");\n  return (\n    Ua(Fa.prototype, im, vo),\n    (Fa.prototype.constructor = Fa),\n    (Fa.defaults = Fa.prototype),\n    (dl.defaults = Fa.defaults),\n    (dl.Ractive = Fa),\n    Ha(Fa, {\n      DEBUG: { writable: !0, value: !0 },\n      DEBUG_PROMISES: { writable: !0, value: !0 },\n      extend: { value: Ra },\n      extendWith: { value: Ba },\n      escapeKey: { value: _ },\n      evalObjectString: { value: As },\n      findPlugin: { value: Da },\n      getContext: { value: ti },\n      getCSS: { value: Ci },\n      isInstance: { value: Oa },\n      joinKeys: { value: di },\n      macro: { value: La },\n      normaliseKeypath: { value: E },\n      parse: { value: Ie },\n      splitKeypath: { value: pi },\n      unescapeKey: { value: A },\n      use: { value: Ia },\n      enhance: { writable: !0, value: !1 },\n      svg: { value: no },\n      tick: {\n        get: function () {\n          return Ol && Ol.promise;\n        },\n      },\n      VERSION: { value: "1.4.0-edge" },\n      adaptors: { writable: !0, value: {} },\n      components: { writable: !0, value: {} },\n      decorators: { writable: !0, value: {} },\n      easing: { writable: !0, value: go },\n      events: { writable: !0, value: {} },\n      extensions: { value: [] },\n      helpers: { writable: !0, value: vo.helpers },\n      interpolators: { writable: !0, value: Eo },\n      partials: { writable: !0, value: {} },\n      transitions: { writable: !0, value: {} },\n      cssData: { configurable: !0, value: {} },\n      perComponentStyleElements: { get: Ei, set: Ei },\n      sharedData: { value: Bl },\n      Ractive: { value: Fa },\n      Context: { value: Fl.Context.prototype },\n    }),\n    qa(Fa, "_cssModel", { configurable: !0, value: new hf(Fa) }),\n    qa(Fa.prototype, "rendered", {\n      get: function () {\n        return this.fragment && this.fragment.rendered;\n      },\n    }),\n    Fa\n  );\n});\n//# sourceMappingURL=ractive.min.js.map\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/js/ractive.min.js?')},"./frontend/js/views/Footer.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var FooterModel = __webpack_require__(/*! ../models/Version */ "./frontend/js/models/Version.js");\n//var Ractive = require("ractive");\n\nmodule.exports = Ractive.extend({\n  template: __webpack_require__(/*! ../../tpl/footer */ "./frontend/tpl/footer.js"),\n  onrender: function () {\n    var model = new FooterModel();\n    model.bindComponent(this).fetch();\n  },\n});\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/js/views/Footer.js?')},"./frontend/js/views/Navigation.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('//var Ractive = require("ractive");\nvar UserModel = __webpack_require__(/*! ../models/User */ "./frontend/js/models/User.js");\n\nconsole.log("Just rendering the navigation");\nvar checkIfLogged = function () {\n  var userModel = new UserModel();\n  this.data.isLogged = userModel.isLogged();\n};\nmodule.exports = Ractive.extend({\n  // template: require("../../tpl/navigation"),\n\n  template: `\n  <nav>\n  <ul>\n    <li><a on-click="goto:home">Home</a></li>\n    {{#if !isLogged}}\n    <li><a on-click="goto:register">Register</a></li>\n    <li><a on-click="goto:login">Login</a></li>\n    {{else}}\n    <li class="right"><a on-click="goto:logout">Logout</a></li>\n    <li class="right"><a on-click="goto:profile">Profile</a></li>\n    <li class="right"><a on-click="goto:find-friends">Find friends</a></li>\n    {{/if}}\n  </ul>\n</nav>`,\n  onconstruct: function () {\n    checkIfLogged.call(this);\n  },\n});\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/js/views/Navigation.js?')},"./frontend/tpl/find-friends.js":module=>{eval('module.exports = {\n  v: 4,\n  t: [\n    { t: 7, e: "header", f: [{ t: 7, e: "navigation" }] },\n    " ",\n    {\n      t: 7,\n      e: "div",\n      a: { class: "hero" },\n      f: [{ t: 7, e: "h1", f: ["Find friends"] }],\n    },\n    " ",\n    {\n      t: 7,\n      e: "form",\n      a: { onsubmit: "return false;" },\n      f: [\n        {\n          t: 4,\n          n: 50,\n          r: "loading",\n          f: [{ t: 7, e: "p", f: ["Loading. Please wait."] }],\n        },\n        {\n          t: 4,\n          n: 51,\n          f: [\n            {\n              t: 7,\n              e: "label",\n              a: { for: "friend-name" },\n              f: ["Please, type the name of your friend:"],\n            },\n            " ",\n            {\n              t: 7,\n              e: "input",\n              a: {\n                type: "text",\n                id: "friend-name",\n                value: [{ t: 2, r: "friendName" }],\n              },\n            },\n            " ",\n            {\n              t: 7,\n              e: "input",\n              a: { type: "button", value: "Find" },\n              v: { click: "find" },\n            },\n          ],\n          r: "loading",\n        },\n      ],\n    },\n    " ",\n    {\n      t: 4,\n      n: 50,\n      x: { r: ["foundFriends"], s: "_0!==null" },\n      f: [\n        {\n          t: 7,\n          e: "div",\n          a: { class: "friends-list" },\n          f: [\n            {\n              t: 4,\n              n: 52,\n              r: "foundFriends",\n              f: [\n                {\n                  t: 7,\n                  e: "div",\n                  a: { class: "friend-list-item" },\n                  f: [\n                    {\n                      t: 7,\n                      e: "h2",\n                      f: [\n                        { t: 2, r: "firstName" },\n                        " ",\n                        { t: 2, r: "lastName" },\n                      ],\n                    },\n                    " ",\n                    {\n                      t: 7,\n                      e: "input",\n                      a: { type: "button", value: "Add as a friend" },\n                      v: { click: { n: "add", d: [{ t: 2, r: "id" }] } },\n                    },\n                  ],\n                },\n              ],\n            },\n          ],\n        },\n      ],\n    },\n    {\n      t: 4,\n      n: 50,\n      x: { r: ["message"], s: \'_0!==""\' },\n      f: [\n        {\n          t: 7,\n          e: "div",\n          a: { class: "friends-list" },\n          f: [{ t: 7, e: "p", f: [{ t: 3, r: "message" }] }],\n        },\n      ],\n    },\n    { t: 7, e: "appfooter" },\n  ],\n};\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/tpl/find-friends.js?')},"./frontend/tpl/footer.js":module=>{eval('module.exports = {\n  v: 4,\n  t: [{ t: 7, e: "footer", f: ["Version: ", { t: 2, r: "version" }] }],\n};\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/tpl/footer.js?')},"./frontend/tpl/profile.js":module=>{eval('module.exports = {\n  v: 4,\n  t: [\n    { t: 7, e: "header", f: [{ t: 7, e: "navigation" }] },\n    " ",\n    {\n      t: 7,\n      e: "div",\n      a: { class: "hero" },\n      f: [{ t: 7, e: "h1", f: ["Profile"] }],\n    },\n    " ",\n    {\n      t: 7,\n      e: "form",\n      f: [\n        {\n          t: 4,\n          n: 50,\n          x: { r: ["error"], s: \'_0&&_0!=""\' },\n          f: [\n            {\n              t: 7,\n              e: "div",\n              a: { class: "error" },\n              f: [{ t: 3, r: "error" }],\n            },\n          ],\n        },\n        " ",\n        {\n          t: 4,\n          n: 50,\n          x: { r: ["success"], s: \'_0&&_0!=""\' },\n          f: [\n            {\n              t: 7,\n              e: "div",\n              a: { class: "success" },\n              f: [{ t: 3, r: "success" }],\n            },\n          ],\n        },\n        " ",\n        { t: 7, e: "label", a: { for: "first-name" }, f: ["First name"] },\n        " ",\n        {\n          t: 7,\n          e: "input",\n          a: {\n            type: "text",\n            id: "first-name",\n            value: [{ t: 2, r: "firstName" }],\n          },\n        },\n        " ",\n        { t: 7, e: "label", a: { for: "last-name" }, f: ["Last name"] },\n        " ",\n        {\n          t: 7,\n          e: "input",\n          a: {\n            type: "text",\n            id: "last-name",\n            value: [{ t: 2, r: "lastName" }],\n          },\n        },\n        " ",\n        { t: 7, e: "label", a: { for: "password" }, f: ["Change password"] },\n        " ",\n        {\n          t: 7,\n          e: "input",\n          a: {\n            type: "password",\n            id: "password",\n            value: [{ t: 2, r: "password" }],\n          },\n        },\n        " ",\n        {\n          t: 7,\n          e: "input",\n          a: { type: "button", value: "update" },\n          v: { click: "updateProfile" },\n        },\n        " ",\n        {\n          t: 7,\n          e: "input",\n          a: {\n            type: "button",\n            value: "delete account",\n            class: "right attention",\n          },\n          v: { click: "deleteProfile" },\n        },\n      ],\n    },\n    " ",\n    {\n      t: 4,\n      n: 50,\n      x: { r: ["friends.length"], s: "_0>0" },\n      f: [\n        {\n          t: 7,\n          e: "div",\n          a: { class: "hero" },\n          f: [{ t: 7, e: "h1", f: ["Friends"] }],\n        },\n        " ",\n        {\n          t: 7,\n          e: "div",\n          a: { class: "friends-list" },\n          f: [\n            {\n              t: 4,\n              n: 52,\n              r: "friends",\n              i: "index",\n              f: [\n                {\n                  t: 7,\n                  e: "div",\n                  a: { class: "friend-list-item" },\n                  f: [\n                    {\n                      t: 7,\n                      e: "h2",\n                      f: [\n                        {\n                          t: 2,\n                          rx: {\n                            r: "friends",\n                            m: [{ t: 30, n: "index" }, "firstName"],\n                          },\n                        },\n                        " ",\n                        {\n                          t: 2,\n                          rx: {\n                            r: "friends",\n                            m: [{ t: 30, n: "index" }, "lastName"],\n                          },\n                        },\n                      ],\n                    },\n                  ],\n                },\n              ],\n            },\n          ],\n        },\n      ],\n    },\n    { t: 7, e: "appfooter" },\n  ],\n};\n\n\n//# sourceURL=webpack://GruntjsTest/./frontend/tpl/profile.js?')}},__webpack_module_cache__={};function __webpack_require__(n){var e=__webpack_module_cache__[n];if(void 0!==e)return e.exports;e=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n].call(e.exports,e,e.exports,__webpack_require__),e.exports}__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}(),__webpack_require__("./frontend/js/app.js"),__webpack_require__("./frontend/js/ractive.js"),__webpack_require__("./frontend/js/ractive.min.js"),__webpack_require__("./frontend/js/controllers/FindFriends.js"),__webpack_require__("./frontend/js/controllers/Home.js"),__webpack_require__("./frontend/js/controllers/Login.js"),__webpack_require__("./frontend/js/controllers/Profile.js"),__webpack_require__("./frontend/js/controllers/Register.js"),__webpack_require__("./frontend/js/lib/Ajax.js"),__webpack_require__("./frontend/js/lib/Router.js"),__webpack_require__("./frontend/js/models/Base.js"),__webpack_require__("./frontend/js/models/Friends.js"),__webpack_require__("./frontend/js/models/User.js"),__webpack_require__("./frontend/js/models/Version.js"),__webpack_require__("./frontend/js/views/Footer.js");var __webpack_exports__=__webpack_require__("./frontend/js/views/Navigation.js")})();